{
  "hash": "9ddcdb70eb50bf1851ebb1e65abc6834",
  "result": {
    "markdown": "---\ntitle: \"Chapter 5 Clustering\"\nexecute:\n  warning: false\n  message: false\n---\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-1_8c4f4ea35d743b82f4d77ddbab92c516'}\n\n```{.r .cell-code}\n# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\n```\n:::\n\n\n# Load RData\n\nLoad the RData which contain all files from previous chapter.\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-2_94c8b72fec57179ab8ef7a30bb43728d'}\n\n```{.r .cell-code}\nload(\"data/intermediate_data/chapter4.RData\")\n```\n:::\n\n\n# 1. Clustering cells\n\nNow that we have our high quality cells integrated, we want to know the different cell types present within our population of cells.\n\nSeurat uses a graph-based clustering approach, which embeds cells in a graph structure, using a K-nearest neighbor (KNN) graph (by default), with edges drawn between cells with similar gene expression patterns. Then, it attempts to partition this graph into highly interconnected 'quasi-cliques' or 'communities'.\n\nWe will use the `FindClusters` function to perform the graph-based clustering. The \\`resolution\\` is an important argument that sets the \"granularity\" of the downstream clustering and will need to be optimized for every individual experiment.\n\n::: callout-note\nIncreased resolution values lead to a greater number of clusters, which is often required for larger datasets.\n:::\n\nThe `FindClusters` function allows us to enter a series of resolutions and will calculate the \"granularity\" of the clustering. This is very helpful for testing which resolution works for moving forward without having to run the function for each resolution.\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-3_45c3fe9c0490e5ab41b6d8e4e8113fdf'}\n\n```{.r .cell-code}\n# Determine the K-nearest neighbor graph\nintegrate.filtered.rna <- FindNeighbors(object = integrate.filtered.rna, dims = 1:10)\n                                \n# Determine the clusters for various resolutions                                \nintegrate.filtered.rna <- FindClusters(object = integrate.filtered.rna,\n                               resolution = c(0.2, 0.4, 0.6,  0.8, 1, 1.2, 1.4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 4160\nNumber of edges: 140485\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9462\nNumber of communities: 9\nElapsed time: 0 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 4160\nNumber of edges: 140485\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9198\nNumber of communities: 11\nElapsed time: 0 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 4160\nNumber of edges: 140485\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8962\nNumber of communities: 13\nElapsed time: 0 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 4160\nNumber of edges: 140485\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8749\nNumber of communities: 15\nElapsed time: 0 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 4160\nNumber of edges: 140485\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8577\nNumber of communities: 16\nElapsed time: 0 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 4160\nNumber of edges: 140485\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8420\nNumber of communities: 17\nElapsed time: 0 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 4160\nNumber of edges: 140485\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8293\nNumber of communities: 19\nElapsed time: 0 seconds\n```\n:::\n:::\n\n\nThe `meta.data` has a separate column for each of the different resolution calculated. We can look at how many clusters in each resolution.\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-4_bb0778af81f45d8998fe46aa8b585a44'}\n\n```{.r .cell-code}\nintegrate.filtered.rna@meta.data %>% \n  dplyr::select(contains(\"integrat\")) %>% \n  map_int(~ unique(.x) %>% length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nintegrated_snn_res.0.2 integrated_snn_res.0.4 integrated_snn_res.0.6 \n                     9                     11                     13 \nintegrated_snn_res.0.8   integrated_snn_res.1 integrated_snn_res.1.2 \n                    15                     16                     17 \nintegrated_snn_res.1.4 \n                    19 \n```\n:::\n:::\n\n\nWe start with the resolution of 0.6. We will assign the identity of the clusters using the `Idents` function.\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-5_dcfe8219f9de4568e7b67766fffc2409'}\n\n```{.r .cell-code}\nIdents(object = integrate.filtered.rna) <- \"integrated_snn_res.0.6\"\n\n# UMAP visualization\nDimPlot(integrate.filtered.rna,\n        reduction = \"umap\",\n        label = TRUE,\n        label.size = 6)\n```\n\n::: {.cell-output-display}\n![](05_clustering_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n::: callout-note\n## Exercise\n\nChange the other resolutions. How do the clusters change?\n:::\n\n# 2. Distribution of cells per cluster\n\nThe number of clusters are sensitive to the resolution. We have PBMC from both samples, and we expect each cluster contains cells from both samples.\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-6_e689e1abdec66fbf74f1094db15cc2d1'}\n\n```{.r .cell-code}\nFetchData(integrate.filtered.rna, \n                     vars = c(\"ident\", \"Sample_Name\")) %>%\n  dplyr::count(ident, Sample_Name) %>%\n  tidyr::spread(ident, n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sample_Name   0   1   2   3   4   5   6   7  8  9 10 11 12\n1       naive 355 243 428 226   8   5 281  70 96 62 13 35 28\n2     treated 508 332 140 217 322 304  14 177 53 71 82 59 31\n```\n:::\n:::\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-7_c9209d82e84ccda27c219f7dea9702a1'}\n\n```{.r .cell-code}\n# UMAP of cells in each cluster by sample\nDimPlot(integrate.filtered.rna, \n        label = TRUE, \n        split.by = \"Sample_Name\")  + NoLegend()\n```\n\n::: {.cell-output-display}\n![](05_clustering_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n# 3. Exploring known cell type markers\n\nWe can explore some known cell type markers to get an idea about the identity of clusters.\n\nCell Type Markers:\n\nCD14+ monocytes: CD14, LYZ\n\nConventional dendritic cells: FCER1A, CST3\n\nB cells: CD79A, MS4A1\n\nT cells: CD3D\n\nCD4+ T cells: CD3D, IL7R, CCR7\n\nCD8+ T cells: CD3D, CD8A\n\nNK cells: GNLY, NKG7\n\nMacrophages: MARCO, ITGAM, ADGRE1\n\nThe `FeaturePlot` makes it easy to visualize a handful of genes using the gene IDs stored in the Seurat object. We can easily explore the expression of known gene markers on top of our UMAP visualizations. Let's go through and determine the identities of the clusters. To access the normalized expression levels of all genes, we can use the normalized count stored in the `RNA` assay slot.\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-8_588083a9855a205f9e47cec911b61fb7'}\n\n```{.r .cell-code}\nDefaultAssay(integrate.filtered.rna) <- \"RNA\"\n```\n:::\n\n\nCD14+ monocytes: CD14, LYZ\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-9_1b3c30fb185aba2e45f62f8553d53574'}\n\n```{.r .cell-code}\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD14\", \"LYZ\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n```\n\n::: {.cell-output-display}\n![](05_clustering_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nB cells: CD79A, MS4A1\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-10_8759750003ffc03094d3a099865f45e9'}\n\n```{.r .cell-code}\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD79A\", \"MS4A1\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n```\n\n::: {.cell-output-display}\n![](05_clustering_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nNK cells: GNLY, NKG7\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-11_b93336db7204087bc5200f82899d99cd'}\n\n```{.r .cell-code}\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"GNLY\", \"NKG7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n```\n\n::: {.cell-output-display}\n![](05_clustering_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nT cells: CD3D\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-12_c2481c98ca3dcb8138fe898d45875b52'}\n\n```{.r .cell-code}\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n```\n\n::: {.cell-output-display}\n![](05_clustering_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nCD4+ T cells: CD3D, IL7R, CCR7\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-13_9dfc07d0abbfadcad162aff07c49b32b'}\n\n```{.r .cell-code}\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"IL7R\", \"CCR7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n```\n\n::: {.cell-output-display}\n![](05_clustering_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nCD8+ T cells: CD3D, CD8A\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-14_840ef05b021e52f09509cc05f685596d'}\n\n```{.r .cell-code}\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"CD8A\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n```\n\n::: {.cell-output-display}\n![](05_clustering_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n# 4. Save\n\nSave the files into RData for documentation.\n\n\n::: {.cell hash='05_clustering_cache/html/unnamed-chunk-15_12629ba464c60247445ee800df6eed6d'}\n\n```{.r .cell-code}\n# save(integrate.filtered.rna, expMat, file = \"data/intermediate_data/chapter5.RData\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}