{
  "hash": "4e72aa911d1688a769125da138d709fc",
  "result": {
    "markdown": "---\ntitle: \"Chapter 9 Combine scRNAseq and AbSeq\"\nexecute:\n  warning: false\n  message: false\n---\n\n::: {.cell hash='09_combining_cache/html/unnamed-chunk-1_6173dfaa99f460da669ac0e16ebaad61'}\n\n```{.r .cell-code}\n# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\n```\n:::\n\n\n# Load RData\n\nLoad the RData which contains all files from the previous chapter.\n\n\n::: {.cell hash='09_combining_cache/html/unnamed-chunk-2_8cbd265a0d48c2b89535cf217bd8bb0b'}\n\n```{.r .cell-code}\nload(\"data/intermediate_data/chapter8.RData\")\n```\n:::\n\n\nWhen the experiment has RNA profiling (scRNA) and protein profiling (AbSeq) in single cell resolution, each measurement is one modality. The combined analysis of scRNA and AbSeq is so called \"multimodal analysis\".\n\nSeurat package also provides the framework to analyze multimodal data. The framework is the the weighted nearest neighbors (WNN) approach, which enables simultaneous clustering of cells based on weighted combination of both modalities.\n\n::: callout-note\nRNA profiling and protein profiling should be analyzed separately before combing for downstream analysis.\n:::\n\n# 1. Processing AbSeq\n\nWhen we analyzed the scRNAseq in the previous chapters, the dataset was filtered and only high quality cells are kept. AbSeq dataset is filtered to have the same cells.\n\n\n::: {.cell hash='09_combining_cache/html/unnamed-chunk-3_9ac000d20c7c6266a9820f673ea61394'}\n\n```{.r .cell-code}\n# get AbSeq from expMat\nab <- expMat$`Antibody Capture`\n\n# filter abseq data based on cell id from rna seurat object\nab <- ab[, colnames(integrate.filtered.rna)]\n```\n:::\n\n\nCreating a new Seurat object with AbSeq.\n\n\n::: {.cell hash='09_combining_cache/html/unnamed-chunk-4_13d6d3bc74f056d25bb42d1723a4c4d1'}\n\n```{.r .cell-code}\n# create a new assay to store AbSeq information\nab <- CreateAssayObject(counts = ab)\n\n# create a new Seurat object to store the combined analysis\ncombined <- integrate.filtered.rna\ncombined[[\"AB\"]] <- ab\n\n# Validate that the object now contains multiple assays\ncombined\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n40809 features across 4160 samples within 7 assays \nActive assay: RNA (19347 features, 0 variable features)\n 6 other assays present: integrated, refAssay, prediction.score.celltype.l1, prediction.score.celltype.l2, prediction.score.celltype.l3, AB\n 4 dimensional reductions calculated: pca, umap, integrated_dr, ref.umap\n```\n:::\n:::\n\n\nNext, we normalize the AbSeq counts.\n\nThe recommended normalization method for AbSeq is CLR, Centered Log Ratio. Due to the unspecific binding background signal of antibody, log-normalization doesn't work well in AbSeq data.\n\nThere are 20 AbSeq in the experiment. We are going to use all of them as variable features.\n\n\n::: {.cell hash='09_combining_cache/html/unnamed-chunk-5_528c97ce5fb23c7ade49dc2b4adae16f'}\n\n```{.r .cell-code}\n# switch the default assay to AbSeq\nDefaultAssay(combined) <- 'AB'\n\n# set variable features\nVariableFeatures(combined) <- rownames(combined[[\"AB\"]])\n\n# set a name for the dimentionality reduction to avoid overwriting\ncombined <- NormalizeData(combined, normalization.method = 'CLR', margin = 2) %>% \n  ScaleData() %>% \n  RunPCA(reduction.name = 'apca', approx = F)\n```\n:::\n\n\n# 2. Weighted nearest neighbour (WNN)\n\nThe weighted nearest neighbor (WNN) is a statistical framework implemented in Seurat for the multimodal analysis. WNN requires pre-processing and dimentionality reduction on both assays independently upfront.\n\n\n::: {.cell hash='09_combining_cache/html/unnamed-chunk-6_d154144072b51036809dc3b70ffb307b'}\n\n```{.r .cell-code}\ncombined <- FindMultiModalNeighbors(combined, \n                                    reduction.list = list(\"pca\", \"apca\"), \n                                    dims.list = list(1:15, 1:18), \n                                    modality.weight.name = \"RNA.weight\")\n```\n:::\n\n\n-   `reduction.list` Dimentionality reduction to use from each element\n\n-   `dims.list` Number of PCs to include from each element\n\n-   `modality.weight.name` Give a name to the weight of each element\n\nNow, we run UMAP using the calculated WNN.\n\nFor each cell, we calculate its closest neighbors in the dataset based on a weighted combination of RNA and protein similarities. We specify the dimensionality of each modality (similar to specifying the number of PCs to include in scRNA-seq clustering). We use the same number of PCs as we did in previous steps.\n\n\n::: {.cell hash='09_combining_cache/html/unnamed-chunk-7_a8cec9192b668759e737f14581566862'}\n\n```{.r .cell-code}\n# run UMAP\ncombined <- RunUMAP(combined, \n                    nn.name = \"weighted.nn\", \n                    reduction.name = \"wnn.umap\", \n                    reduction.key = \"wnnUMAP_\")\n\n# find clusters\ncombined <- FindClusters(combined, \n                         graph.name = \"wsnn\", \n                         resolution = 0.4, \n                         verbose = FALSE)\n```\n:::\n\n\nLook at the results in UMAP.\n\n\n::: {.cell hash='09_combining_cache/html/unnamed-chunk-8_4123b6e50f9740b18e49eb331f501c2e'}\n\n```{.r .cell-code}\n# visualize the result in UMAP\np1 <- DimPlot(combined, reduction = 'wnn.umap', \n              label = TRUE, repel = TRUE, label.size = 2.5, \n              group.by = \"predicted.celltype.l1\")\n\np2 <- DimPlot(combined, reduction = 'wnn.umap', \n              label = TRUE, repel = TRUE, label.size = 2.5)\n\np1|p2\n```\n\n::: {.cell-output-display}\n![](09_combining_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nLet's compare the UMAPs from RNA only and from WNN. The T cells cluster better in WNN UMAP. Because AbSeq is often handpicked and cell type specific, bringing AbSeq in can have a better resolution.\n\n\n::: {.cell hash='09_combining_cache/html/unnamed-chunk-9_ef82152080764cacb79e60e9ba1bf4c3'}\n\n```{.r .cell-code}\n# compare the UMAPs based on RNA and on WNN\np1 <- DimPlot(combined, reduction = 'umap', group.by = 'predicted.celltype.l1', \n              label = TRUE, repel = TRUE, label.size = 2.5) + \n  NoLegend() + ggtitle(\"RNA\")\n\np2 <- DimPlot(combined, reduction = 'wnn.umap', group.by = 'predicted.celltype.l1', \n              label = TRUE, repel = TRUE, label.size = 2.5) + \n  NoLegend() + ggtitle(\"WNN\")\n\np1|p2\n```\n\n::: {.cell-output-display}\n![](09_combining_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n# 3. AbSeq visualization\n\nWe have several assays stored in the Seurat object. We can easily switch between them and work on different assays.\n\n::: callout-important\nIt is important to know which assay you are working on. We may get unexpected results if working on the wrong assay.\n:::\n\nLet's look at the protein and gene expression side by side. By setting the default assay, we can visualize one or the other.\n\nCD19 is a B cell marker. We can plot the UMAP with annotation side by side with the CD19 AbSeq.\n\n\n::: {.cell hash='09_combining_cache/html/unnamed-chunk-10_ea4571f702a096293d811320ba17b3f6'}\n\n```{.r .cell-code}\n# switch default assay to AbSeq to plot protein expression\nDefaultAssay(combined) <- \"AB\"\np1 <- FeaturePlot(combined, \"CD19-CD19-AHS0030-pAbO\", \n                  cols = c(\"lightgrey\", \"darkgreen\"), \n                  reduction = 'wnn.umap')\n\n# switch default to RNA to plot gene expression\nDefaultAssay(combined) <- \"RNA\"\np2 <- FeaturePlot(combined, \"CD19\", reduction = 'wnn.umap')\n\n# place plots side-by-side\np1 | p2\n```\n\n::: {.cell-output-display}\n![](09_combining_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n# 4. Save\n\nSave the files into RData for documentation.\n\n\n::: {.cell hash='09_combining_cache/html/unnamed-chunk-11_5f39e99f41f8c0a80339640a944d5996'}\n\n```{.r .cell-code}\n# save(combined, expMat, ab, integrate.filtered.rna, file = \"data/intermediate_data/chapter9.RData\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}