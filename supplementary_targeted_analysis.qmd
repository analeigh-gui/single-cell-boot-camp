---
title: "Supplementary: Targeted assays"
execute:
  warning: false
  message: false
format: 
  html:
    embed-resources: true
---

```{r}
#| message: false
# libraries for this chapter
library(tidyverse)
library(Seurat)
library(data.table)
library(clustree)
library(HGNChelper)
library(openxlsx)
```

The BD Rhapsody™ Targeted mRNA Kits profile a subset of genes, from dozens to hundreds. These genes are in the targeted panel.

In Chapter 2, we introduce filtering low quality cell labels using WTA assays. WTA assays profile whole transcriptome which can have up to 30,000 genes. Because the number of profiling genes is substantially higher in WTA assays, and the targeted assays often do not include mitochondrial genes, the filtering threthold for low quality cell labels in targeted assays is different from WTA.

# 1. Metrics for quality control in Targeted assay

Because Targeted assays often do not include mitochondrial genes, the filtering threthold for low quality cell labels rely primarily on `nCount_RNA` and `nFeature_RNA`.

# 2. Assessing the quality metrics in Targeted assay

The BD Rhapsody™ Targeted mRNA demo dataset can be downloaded from: <https://bd-rhapsody-public.s3.amazonaws.com/Rhapsody-Demo-Data/16HIRP-targeted-EB-20kPBMC.zip>

This Targeted mRNA dataset was generated from 20,000 resting PBMC using the pre-designed BD Rhapsody™ Immune Response Panel HS.

## 2.1 Data imports

::: callout-note
When creating the Seurat object, it is important to specify `min.cells = 1` and `min.features = 1`.
:::

```{r}
seuratObj <- readRDS("16HIRP-targeted-EB-20kPBMC/16HIRP_Seurat.rds")

# update Seurat object
seuratObj[["RNA"]] <- as(object = seuratObj[["RNA"]], Class = "Assay5") 
```

## 2.2 `nCount_RNA` UMI counts per cell

```{r}
seuratObj@meta.data %>% 
  ggplot(aes(x=nCount_RNA)) + 
  geom_density(alpha = 0.2) + 
  scale_x_log10() + 
  theme_classic() +
  ylab("Cell density") +
  ggtitle("nCount_RNA")
```

## 2.3 `nFeature_RNA` Gene counts per cell

```{r}
seuratObj@meta.data %>% 
  ggplot(aes(x=nFeature_RNA)) + 
  geom_density(alpha = 0.2) + 
  scale_x_log10() + 
  theme_classic() +
  ylab("Cell density") +
  ggtitle("nFeature_RNA")
```

## 2.4 Combine metrics to come up the filtering threshold

```{r}
#| warning: false
seuratObj@meta.data %>% 
  ggplot(aes(x=nCount_RNA, y=nFeature_RNA)) + 
  geom_point() + 
  scale_colour_gradient(low = "gray90", high = "black") +
  stat_smooth(method=lm) +
  scale_x_log10() + 
  scale_y_log10() + 
  theme_classic() +
  geom_vline(xintercept = 90, colour = "red") +
  geom_vline(xintercept = 3000, colour = "red") +
  geom_hline(yintercept = 30, colour = "red") +
  geom_hline(yintercept = 200, colour = "red") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

Majority of cells have between 30 - 200 gene counts. The cells on the right with high nCount_RNA are likely multiplets. We will filter the cell groups with the identified threshold.

# 3. Filter data

## 3.1 Filter on cells

Based on the quality metrics, we use the following thresholds to filter out low quality cells:

`nCount_RNA` \> 90

`nCount_RNA` \< 3000

`nFeature_RNA` \> 30

`nFeature_RNA` \< 200

```{r}
filtered <- subset(x = seuratObj, 
                   subset = (nCount_RNA > 90) & 
                         (nCount_RNA < 3000) &
                         (nFeature_RNA > 30) &
                         (nFeature_RNA < 200))
```

## 3.2 Re-assess metrics

After filtering, we look back to the metrics to ensure the filtered data matches expectations and is suitable for downstream analysis. We plot QC metrics using the filtered data.

```{r}
#| warning: false
filtered@meta.data %>% 
  ggplot(aes(x=nCount_RNA, y=nFeature_RNA)) + 
  geom_point() + 
  scale_colour_gradient(low = "gray90", high = "black") +
  stat_smooth(method=lm) +
  scale_x_log10() + 
  scale_y_log10() + 
  theme_classic() +
  geom_vline(xintercept = 90, colour = "black") +
  geom_vline(xintercept = 3000, colour = "black") +
  geom_hline(yintercept = 25, colour = "red") +
  geom_hline(yintercept = 200, colour = "red") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

The feature number and cell number before filtering:

```{r}
seuratObj
```

The feature number and cell number after filtering:

```{r}
filtered
```

# 4. Normalization

We will perform normalization on UMI counts using `LogNormalize`.

`LogNormalize` divides the UMI counts of a gene in a cell into the total UMI counts in that cell. After division, we take the natural log.

```{r}
filtered <- NormalizeData(filtered, 
                          normalization.method = "LogNormalize")
```

::: callout-important
## Question

Where are the normalized counts stored?
:::

::: {.callout-tip collapse="T"}
## Answer

The normalized counts are stored in the `data` layer of assay `RNA`.

```{r}
filtered[["RNA"]]@layers$data %>% 
  .[1:10, 1:10]
```
:::

After normalization, we scale the data and identify highly variable features. Data scaling is to remove the bias from high expressors which is required by PCA calculation.

```{r}
# Scale data
filtered <- ScaleData(filtered, features = rownames(filtered))

# Find variable features
# Targeted assay contains a small set of genes. All genes are often defined as variable features.
filtered <- FindVariableFeatures(filtered)
```

# 5. PCA and UMAP

The PCA is calculated with the highly variable features. Each PC can explain some variance of the data. The first PC can explain the most variance, and gradually decrease through the PCs. We can visualize the PCs by Elbow plot.

```{r}
filtered <- RunPCA(filtered, npcs = 50, verbose = FALSE)
```

```{r}
ElbowPlot(filtered, ndims = 50)
```

Only the top PCs will be used for UMAP. Elbow plot can help to select the top PCs. We used the PCs until where the elbow is to calculate UMAP.

For this dataset, we use the first top 20 PCs.

```{r}
filtered <- RunUMAP(filtered, reduction = "pca", dims = 1:20)

DimPlot(filtered)
```

# 6. Clustering

```{r}
# Determine the K-nearest neighbor graph
filtered <- FindNeighbors(object = filtered, dims = 1:20)
                                
# Determine the clusters for various resolutions                                
filtered <- FindClusters(object = filtered,
                                 resolution = c(0.1, 0.2, 0.4, 0.6,  0.8, 1, 1.2, 1.4),
                                 verbose = F)
```

We use `clustree` to help determining which resolution to choose.

```{r fig.height=10}
clustree(filtered, prefix = "RNA_snn_res.")
```

We can see that some clusters are very distinct and do not change with the value of k. On the other side of the tree we see a single cluster that splits into the multiple clusters. After this the tree becomes messier and there are nodes with multiple incoming edges. This is a good indication that we have over clustered the data. We choose k = 0.2 for clustering.

```{r}
Idents(filtered) <- filtered$RNA_snn_res.0.2
DimPlot(filtered, group.by = "RNA_snn_res.0.2", label = T)
```

# 7. Explore known cell type markers

Let's use Violin plot to explore the know cell type markers for CD8 T cells.

```{r}
VlnPlot(filtered, features = c("CD4", "CD8A", "CD8B"), stack = T, flip = T)
```

::: callout-note
## Question

Which cluster is CD8 T cells?
:::
