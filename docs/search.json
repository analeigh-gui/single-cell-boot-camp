[
  {
    "objectID": "01_data_import.html",
    "href": "01_data_import.html",
    "title": "Chapter 1 Data Import",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\n\nDemo data\nThe demo data is generated from freshly isolated human PBMCs. The PBMCs were grown for 24 hours in the presence of CD3/CD28 stimulation (“treated”) and compared to PBMCs grown for 24 hours in regular media (“naive”). Cells were then labeled with a 20plex AbSeq panel consisting of lineage markers and T-cell activation markers, as well as unique Sample Tags from the BD Rhapsody™ Human Single Cell Multiplexing Kit (resting PBMC: ST1; treated PBMC: ST2). The cells were mixed at a 1:1 ratio and processed using the BD Rhapsody™ Single-Cell Analysis System. Sequencing libraries for RNA and AbSeq antibodies were generated using the BD Rhapsody WTA Amplification kit.\n\n\n\n\n\n\nNote\n\n\n\nPlease review the setup chapter to ensure that R packages are installed and the demo data (in folder “raw_data”) is downloaded.\n\n\n1. Data import\nThe expression matrix stores the UMI counts of a feature (gene or protein). Rhapsody single cell platform outputs a rds file containing the expression matrix as a Seurat object. The Seurat object also includes the sample tag information.\n\nseuratObj &lt;- readRDS(\"BD-Demo-WTA-AbSeq-SMK/BD-Demo-WTA-AbSeq-SMK_Seurat.rds\")\n\n# update Seurat object\nseuratObj[[\"RNA\"]] &lt;- as(object = seuratObj[[\"RNA\"]], Class = \"Assay5\") \n\n# get bioproduct names for RNA and AbSeq\nab_name &lt;- grep(\"pAbO\", rownames(seuratObj), value = T, ignore.case = T)\nrna_name &lt;- rownames(seuratObj)[-which(rownames(seuratObj) %in% ab_name)]\n\n# get rna and AbSeq UMI counts, meta data\nab &lt;- GetAssayData(seuratObj[[\"RNA\"]], features = ab_name)\nrna &lt;- GetAssayData(seuratObj[[\"RNA\"]], features = rna_name)\n\n# recreate seurat object\nseuratObj[[\"RNA\"]] &lt;- CreateAssay5Object(counts = rna)\nseuratObj[[\"ADT\"]] &lt;- CreateAssay5Object(counts = ab)\n\nClick on the seuratObj on the right.\nA window will pop up and you should be able to see the structure of seuratObj.\n\nseuratObj contains two assays: RNA and ADT. RNA stores Gene Expression; and ADT stores AbSeq. We will first focus on RNA analysis.\nseuratObj contains a slot meta.data.\n\nmeta.data stores information related to each cell. We will add more information into the meta.data later. For now, it has the below columns:\n\norig.ident Sample identity or sample name. By default, it is “SeuratProject”.\nnCount_RNA UMI counts per gene per cell.\nnFeature_RNA Genes counts per cell.\nCell_Type_Experiment Cell annotation based on 100 marker genes of immune cell types.\nSample_Tag The cell is from which sample tag.\nSample_Name The cell is from which sample.\nPutative_Cell_Algorithm Which algorithm is used to call the cell. Default is “Basic”.\nnCount_ADT UMI counts per AB per cell.\nnFeature_ADT AB counts per cell.\n2. Remove Multiplet and Undetermined\nThe Multiplet are cell labels with more than one SMK tags. They could be Multiplets from one microwell containing two cells, or single cells with high ambient SMK noise.\nThe Undetermined are cell labels without sufficient SMK tag reads. They could be noisy cell labels, or single cells without SMK tag reads.\n\nseuratObj@meta.data %&gt;% \n  group_by(Sample_Name) %&gt;% \n  tally(name = \"cell_count\") %&gt;% \n  ggplot(aes(x=Sample_Name, y=cell_count, fill= Sample_Name)) + \n  geom_bar(stat = \"identity\") +\n  geom_text(aes(y = cell_count,\n                label = cell_count,\n                vjust= -0.5, size = 2.5), show.legend = FALSE) + \n  theme_classic()\n\n\n\n\nMultiplet and Undetermined are removed from the downstream analysis by subset.\n\nseuratObj &lt;- subset(seuratObj, subset = Sample_Name %in% c(\"Multiplet\", \"Undetermined\"), invert = T)\n\n3. Save\nSave the files into RData for documentation.\n\nsave(seuratObj, file = \"data/chapter1.RData\")"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Introduction",
    "section": "",
    "text": "How to use the materials?\nThis repository contains the teaching materials for the Single Cell Boot Camp - Analyzing scRNA-seq with R.\nIt has:\nTwo chapters of precourse preparation: Precourse Preparation - R / Theory\nNine chapters of the analysis workflow: Chapter 1 - 9.\n\n\n\n\n\n\nImportant\n\n\n\nStudents who go through the teaching materials and run the code on their local desktops will have a much better learning outcome.\nAs we are NOT going to cover the R programming and SOLELY focusing on the analysis workflow, this is particularly important for students who are not familiar with R. So, please do block some time and try to digest the materials before attending the Boot Camp.\nIf you are familiar with R, you can skip the Precourse Preparation and jump to Chapter 1 - 9.\n\n\nFor further information, suggestions and bug report, please contact: biox_support_emea@bd.com\n\n\nDescription\nThe Single Cell Boot Camp: Analysis of scRNA-seq with R is to provide an overview of the analysis of single-cell RNA-seq using R. It is designed for early-stage researchers who want to adopt single-cell analysis in their toolbox. The workshop consists of theory in presentation and application in hands-on practice.\nThe workshop starts with a fast-paced training session on the common workflow of single-cell RNA-seq analysis, then continues with sessions on the common workflow of scRNA-seq using bioinformatics packages like Seurat.\n\n\nPrerequisites\nEach participant are expected to have:\n1. An introductory background in statistics, specifically in the below concepts: Median, log2 fold change, p-value, adjusted p-value, variance, PCA.\n2. Basic familiarity with R and tidyr package, specifically in the below functions: %&gt;% (pipe), filter, mutate, pivot_longer, pivot_wider, map, pmap, select, left_join.\nIf you would like to learn on your own with publicly available resources:\nChapter 1 - 4 from MordernDive.\n\nIf you would like to participate in an instructor-led R course:\nR for Biologist from Edinburgh Genomics. For details, please contact Edinburgh Genomics.\n\n\nExpected outcome\nBy the end of the workshop, participants will be familiar with the following topics: Common workflow of single cell analysis (pre-processing, quality control, filtering, normalization, Clustering, Cell type annotation).\n\n\nReference\nThe building of materials for the course references and relies on many excellent and well written public avaialbe materials.\n\nSeurat https://satijalab.org/seurat/\nSingle Cell Best Practices: https://www.sc-best-practices.org/preamble.html\nOrchestrating Single-Cell Analysis with Bioconductor: https://bioconductor.org/books/release/OSCA/\nMary Piper, Meeta Mistry, Jihe Liu, William Gammerdinger, & Radhika Khetani. (2022, January 6). hbctraining/scRNA-seq_online: scRNA-seq Lessons from HCBC (first release). Zenodo. https://doi.org/10.5281/zenodo.5826256\n\n\n\nDisclaimer\nRecommendations given by representatives of BD in the context of the creation and setup of customer-specific applications and assays, the composition of antibody panels and suggestions for data analysis are provided in a diligent manner. However, the Customer acknowledges that (i) such recommendations should not be treated as a substitute for the Customer’s own examination, (ii) BD does not make any promises nor guarantees that recommendations are accurate and complete and will meet the Customer’s present or future needs or will produce positive or specific results and (iii) Customer remains solely responsible for validating and deciding on any such recommendations.\nBD therefore accepts no liability whatsoever in connection with any such recommendation and/or any results generated on the basis of such recommendations and, to the fullest extent permitted by law, expressly disclaims any and all warranties and any liability in this respect. In particular, the Customer assumes sole responsibility for the validation, use, selection, and suitability of the recommendations for its needs and objectives.\n\n\nLicense\nSee the LICENSE file for license rights and limitations (MIT)."
  },
  {
    "objectID": "precourse_preparation_R.html",
    "href": "precourse_preparation_R.html",
    "title": "Precourse Preparation",
    "section": "",
    "text": "This tutorial will help you to understand the basic concepts in R. It will cover the following topics:\n\nWorking with Dataframes\nTidyverse library\nUnderstanding the Seurat object"
  },
  {
    "objectID": "precourse_preparation_R.html#what-is-data-frame",
    "href": "precourse_preparation_R.html#what-is-data-frame",
    "title": "Precourse Preparation",
    "section": "1.1 What is data frame",
    "text": "1.1 What is data frame\nData frame is data structure in R that store values of any type. You can think of it as a table with columns and rows storing the data as in below example.\n\nCredit: https://www.geeksforgeeks.org/r-data-frames/\nOften in data science language the columns are named as variables, the rows are observations and each entry in a table is a value.\nSome of the most common examples of input files that can be loaded into R as data frames are spreadsheets, TSVs, CSVs files. TSV and CSV stands for tab-separated or coma-separated values.\nAnother way to view data frame is as list of vectors of the same length. The vector can be defined as type of data structure that contains elements of the same type. Below you can find example on how create the table presented in Figure 1 from vectors.\n\n#define vectors which will create columns with data in data frame\n\n## Vector of names\nName &lt;- c(\"Avrey Bradley\",\"John Holland\",\"Jonas Jerebko\",\"Jordan Midkey\",\"Terry Rozier\",\"Jared Sullinger\",\"Evan Turner\")\n\n## Vector of team's names\nTeam &lt;- c(\"Boston Celtics\", \"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\")\n\n## Vector of values\nNumber &lt;- c(0.0,30.0,8.0,NaN,12.0,7.0,11.0)\n\n## Vector of positions\nPosition &lt;- c(\"PG\",\"SG\",\"PF\",\"PF\",\"PG\",\"C\",\"SG\")\n\n## Vector of age\nAge &lt;- c(25.0,27.0,29.0,21.0,22.0,NaN,27.0)\n\n#create data frame from vectors\ndata.frame(Name,Team,Number,Position,Age)\n\n             Name           Team Number Position Age\n1   Avrey Bradley Boston Celtics      0       PG  25\n2    John Holland Boston Celtics     30       SG  27\n3   Jonas Jerebko Boston Celtics      8       PF  29\n4   Jordan Midkey Boston Celtics    NaN       PF  21\n5    Terry Rozier Boston Celtics     12       PG  22\n6 Jared Sullinger Boston Celtics      7        C NaN\n7     Evan Turner Boston Celtics     11       SG  27"
  },
  {
    "objectID": "precourse_preparation_R.html#convenient-version-of-data-frame-tibble",
    "href": "precourse_preparation_R.html#convenient-version-of-data-frame-tibble",
    "title": "Precourse Preparation",
    "section": "1.2 Convenient version of data frame: “Tibble”",
    "text": "1.2 Convenient version of data frame: “Tibble”\nThe tibble is package that manipulate data frames. The tibble type of table looks like data frame but have some advantages over using regular data frames.\nFor example, while loading data as classical data frame, the spaces in names are conversed to periods or “x” before numeric columns is added. While using tibbles, the input names and types remain unchanged. In this tutorial we will work mainly with tibble data frame type."
  },
  {
    "objectID": "precourse_preparation_R.html#working-with-data-frames-in-r",
    "href": "precourse_preparation_R.html#working-with-data-frames-in-r",
    "title": "Precourse Preparation",
    "section": "1.3 Working with data frames in R",
    "text": "1.3 Working with data frames in R\n1.3.1 Example data\nIn this part of tutorial we will work on table downloaded from supplementary data of Salcher, Stefan et al. publication (doi:10.1016/j.ccell.2022.10.008). The table contains the metadata of patients for which samples were processed on different single-cell platforms.\n1.3.2 Loading the data\nDepending on the input format there are different dedicated libraries to load data into R. Here we start from excel spreadsheet and use function from readxl library. The readxl library is part of tidyverse packages that will be covered in second chapter of this tutorial.\n\ndf_example &lt;- read_excel(\"precourse_preparation_data/mmc4.xlsx\",  skip = 2)\n\nNOTE:\n\nThe two first rows in the table are empty and therefore skipped while loading.\nOne of the columns in excel spreadsheet is empty (column N). The R assign automatically the default name to that column and keep it within data frame.\nAll the missing entries in rows will be filled with “NA” values automatically.\n1.3.3 Viewing the content\nThere are different ways to view the content of data frame. The “View” function will take you to separate window where you see the table displayed and interact with it directly.\n\nView(df_example)\n\nThe “str” function lists directly in the console: the type of data (tibble), dimensions (322x18), columns with first values displayed and type of values.\n\nstr(df_example)\n\ntibble [322 × 18] (S3: tbl_df/tbl/data.frame)\n $ ...1                    : num [1:322] 0 1 2 3 4 5 6 7 8 9 ...\n $ study                   : chr [1:322] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" ...\n $ dataset                 : chr [1:322] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" ...\n $ patient                 : chr [1:322] \"Adams_Kaminski_2020_001C\" \"Adams_Kaminski_2020_002C\" \"Adams_Kaminski_2020_003C\" \"Adams_Kaminski_2020_8CO\" ...\n $ uicc_stage              : chr [1:322] NA NA NA NA ...\n $ tumor_stage             : chr [1:322] NA NA NA NA ...\n $ sex                     : chr [1:322] \"male\" \"female\" \"female\" \"male\" ...\n $ ever_smoker             : chr [1:322] \"no\" \"no\" \"no\" \"yes\" ...\n $ driver_genes            : chr [1:322] NA NA NA NA ...\n $ condition               : chr [1:322] \"non-cancer\" \"non-cancer\" \"non-cancer\" \"COPD\" ...\n $ age                     : num [1:322] 22 25 67 65 66 49 62 57 66 20 ...\n $ platform                : chr [1:322] \"10x\" \"10x\" \"10x\" \"10x\" ...\n $ platform_fine           : chr [1:322] \"10x_3p_v2\" \"10x_3p_v2\" \"10x_3p_v2\" \"10x_3p_v2\" ...\n $ ...14                   : logi [1:322] NA NA NA NA NA NA ...\n $ tissue: normal          : num [1:322] 1 1 1 1 1 1 1 1 1 1 ...\n $ tissue: normal_adjacent : num [1:322] 0 0 0 0 0 0 0 0 0 0 ...\n $ tissue: tumor_primary   : num [1:322] 0 0 0 0 0 0 0 0 0 0 ...\n $ tissue: tumor_metastasis: num [1:322] 0 0 0 0 0 0 0 0 0 0 ...\n\n\n1.3.4 Extracting information\nExtracting data from an R data frame means to access its rows or columns. First let’s list all columns available in the dataset.\n\ncolnames(df_example)\n\n [1] \"...1\"                     \"study\"                   \n [3] \"dataset\"                  \"patient\"                 \n [5] \"uicc_stage\"               \"tumor_stage\"             \n [7] \"sex\"                      \"ever_smoker\"             \n [9] \"driver_genes\"             \"condition\"               \n[11] \"age\"                      \"platform\"                \n[13] \"platform_fine\"            \"...14\"                   \n[15] \"tissue: normal\"           \"tissue: normal_adjacent\" \n[17] \"tissue: tumor_primary\"    \"tissue: tumor_metastasis\"\n\n\nTo extract values from single column of the data frame different options can be used:\n\nUsing $ operator and providing the column name\n\n\nhead(df_example$study) # head allows to display only 10 first elements \n\n[1] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n[4] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n\n\n\nUsing [ , ] and providing the column number (index)\n\n\ndf_example[10, 2]\n\n# A tibble: 1 × 1\n  study              \n  &lt;chr&gt;              \n1 Adams_Kaminski_2020\n\n\n\nUsing [[]] and providing column number (index)\n\n\nhead(df_example[[2]]) # head allows to display only 10 first elements \n\n[1] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n[4] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n\n\n\nUsing column name\n\n\ndf_example[10 ,c(\"study\")]\n\n# A tibble: 1 × 1\n  study              \n  &lt;chr&gt;              \n1 Adams_Kaminski_2020\n\n\nTo extract multiple columns or rows at the same time the following rules apply:\n\n\nExtract rows range, include all columns.\n\n\ndf_example[c(2:4),] #display rows from 2-4 and all columns\n\n# A tibble: 3 × 18\n   ...1 study           dataset patient uicc_stage tumor_stage sex   ever_smoker\n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;      \n1     1 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n2     2 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n3     3 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  yes        \n# ℹ 10 more variables: driver_genes &lt;chr&gt;, condition &lt;chr&gt;, age &lt;dbl&gt;,\n#   platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\n\nExtract rows, include all columns.\n\n\ndf_example[c(2,4),] #display rows 2 and 4 and all columns\n\n# A tibble: 2 × 18\n   ...1 study           dataset patient uicc_stage tumor_stage sex   ever_smoker\n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;      \n1     1 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n2     3 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  yes        \n# ℹ 10 more variables: driver_genes &lt;chr&gt;, condition &lt;chr&gt;, age &lt;dbl&gt;,\n#   platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\n\nExtract columns range, include all rows.\n\n\ndf_example[10, c(2:4)] #display columns from 2-4 and all rows\n\n# A tibble: 1 × 3\n  study               dataset             patient                 \n  &lt;chr&gt;               &lt;chr&gt;               &lt;chr&gt;                   \n1 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_081C\n\n\n\nExtract columns, include all rows.\n\n\ndf_example[10, c(2,4)] #display columns 2 and 4 and all rows\n\n# A tibble: 1 × 2\n  study               patient                 \n  &lt;chr&gt;               &lt;chr&gt;                   \n1 Adams_Kaminski_2020 Adams_Kaminski_2020_081C\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise\n\nExtract rows from 5-10 and columns from 3-8.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer\n\n\ndf_example[c(5:10),c(3,8)]\n\n# A tibble: 6 × 2\n  dataset             ever_smoker\n  &lt;chr&gt;               &lt;chr&gt;      \n1 Adams_Kaminski_2020 yes        \n2 Adams_Kaminski_2020 yes        \n3 Adams_Kaminski_2020 yes        \n4 Adams_Kaminski_2020 yes        \n5 Adams_Kaminski_2020 no         \n6 Adams_Kaminski_2020 no         \n\n\n\n\n\n1.3.4 Modifying information\nThe columns or rows can be removed or added to data frame as needed. It is possible to drop specific columns indicating the column indexes.\n\nmodified_df_example &lt;- df_example[, -c(1,2,5)]    # Drop columns 1,2,5 and include all columns\nmodified_df_example[10, ] # data frame with excluded columns \n\n# A tibble: 1 × 15\n  dataset     patient tumor_stage sex   ever_smoker driver_genes condition   age\n  &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;     &lt;dbl&gt;\n1 Adams_Kami… Adams_… &lt;NA&gt;        male  no          &lt;NA&gt;         non-canc…    20\n# ℹ 7 more variables: platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;,\n#   `tissue: normal` &lt;dbl&gt;, `tissue: normal_adjacent` &lt;dbl&gt;,\n#   `tissue: tumor_primary` &lt;dbl&gt;, `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\nThe same principle apply to excluding the rows\n\nmodified_df_example &lt;- df_example[-c(1,2,5),]     # Drop rows 1,2,5 and include all columns\nmodified_df_example[10, ]\n\n# A tibble: 1 × 18\n   ...1 study           dataset patient uicc_stage tumor_stage sex   ever_smoker\n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;      \n1    12 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n# ℹ 10 more variables: driver_genes &lt;chr&gt;, condition &lt;chr&gt;, age &lt;dbl&gt;,\n#   platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\nWe can remove column with specific name. To drop column, we chose all the columns (called by “colnames”) except (!=) “patient”.\n\nmodified_df_example &lt;- df_example[ , colnames(df_example) != \"patient\"]    # Drop column \"patient\"\nmodified_df_example[10, ]\n\n# A tibble: 1 × 17\n   ...1 study      dataset uicc_stage tumor_stage sex   ever_smoker driver_genes\n  &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;       \n1     9 Adams_Kam… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  no          &lt;NA&gt;        \n# ℹ 9 more variables: condition &lt;chr&gt;, age &lt;dbl&gt;, platform &lt;chr&gt;,\n#   platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\nThe new columns can be added to data frame. To add new column, use $ to indicate the column name for a new column as in the example below.\nHere we assign the values from already existing column to a new column. The new column is added at the end of the data table.\n\ndf_example$technology_type &lt;- df_example$platform # add new column named \"technology_type\" with values from \"platform\" existing column\ndf_example[10, ncol(df_example)] #show all rows and last column\n\n# A tibble: 1 × 1\n  technology_type\n  &lt;chr&gt;          \n1 10x            \n\n\nThe values from chosen column can be replaced with other values. In example below we search in df_example data frame in technology_type column for rows that contain “BD-Rhapsody” text. For those values we assign “microwell-based”.\n\ndf_example$technology_type[df_example$technology_type == \"BD-Rhapsody\"] &lt;- \"microwell-based\"\ndf_example$technology_type[df_example$technology_type == \"10x\"] &lt;- \"droplet-based\"\n\ndf_example[10, c(\"platform\",\"technology_type\")] #display columns\n\n# A tibble: 1 × 2\n  platform technology_type\n  &lt;chr&gt;    &lt;chr&gt;          \n1 10x      droplet-based  \n\n\nThe last useful function to cover in this chapter is summary(). The function gives the statistical summary of each of the columns when applied on data frame. It can be applied on slice of data as for example only on one column or chosen columns and rows.\n\nsummary(df_example)\n\n      ...1           study             dataset            patient         \n Min.   :  0.00   Length:322         Length:322         Length:322        \n 1st Qu.: 80.25   Class :character   Class :character   Class :character  \n Median :160.50   Mode  :character   Mode  :character   Mode  :character  \n Mean   :160.50                                                           \n 3rd Qu.:240.75                                                           \n Max.   :321.00                                                           \n                                                                          \n  uicc_stage        tumor_stage            sex            ever_smoker       \n Length:322         Length:322         Length:322         Length:322        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n                                                                            \n driver_genes        condition              age          platform        \n Length:322         Length:322         Min.   :20.00   Length:322        \n Class :character   Class :character   1st Qu.:56.00   Class :character  \n Mode  :character   Mode  :character   Median :63.00   Mode  :character  \n                                       Mean   :60.73                     \n                                       3rd Qu.:69.00                     \n                                       Max.   :90.00                     \n                                       NA's   :89                        \n platform_fine       ...14         tissue: normal   tissue: normal_adjacent\n Length:322         Mode:logical   Min.   :0.0000   Min.   :0.0000         \n Class :character   NA's:322       1st Qu.:0.0000   1st Qu.:0.0000         \n Mode  :character                  Median :0.0000   Median :0.0000         \n                                   Mean   :0.2267   Mean   :0.3261         \n                                   3rd Qu.:0.0000   3rd Qu.:1.0000         \n                                   Max.   :1.0000   Max.   :1.0000         \n                                                                           \n tissue: tumor_primary tissue: tumor_metastasis technology_type   \n Min.   :0.0000        Min.   :0.0000           Length:322        \n 1st Qu.:0.0000        1st Qu.:0.0000           Class :character  \n Median :1.0000        Median :0.0000           Mode  :character  \n Mean   :0.5497        Mean   :0.1398                             \n 3rd Qu.:1.0000        3rd Qu.:0.0000                             \n Max.   :1.0000        Max.   :1.0000                             \n                                                                  \n\n\n\nsummary(df_example$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  20.00   56.00   63.00   60.73   69.00   90.00      89"
  },
  {
    "objectID": "precourse_preparation_R.html#pipe",
    "href": "precourse_preparation_R.html#pipe",
    "title": "Precourse Preparation",
    "section": "2.1 Pipe",
    "text": "2.1 Pipe\nA pipe is a type of operator in R: %&gt;%. It takes the output of one function and passes it as the first argument of the next function, allowing us to chain together several steps in R.\n\nCredit: tidyverse.org\nThe pipe sends the data on left side of the pipe to be the first argument of the function on the right side of the pipe.\n\n16 %&gt;% sqrt() # is equivalent to sqrt(16)\n\n[1] 4\n\n\nWe can pipe multiple functions together. The operations are performed from the left to the right sequentially.\n\n16 %&gt;% sqrt() %&gt;% log2() # is equivalent to log2(sqrt(16))\n\n[1] 2\n\n\nBelow you can find exercises with more examples of piping mathematical functions in R together.\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise: What would be the equivalent mathematical expression to below piped sequence of operations?\n\n\n26 %&gt;% -22 %&gt;% sqrt() %&gt;% +4\n\n[1] 6\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer:\n\n\nsqrt(26-22) + 4\n\n[1] 6\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise: How below mathematical operation can be shown with pipe option?\n\n\nsqrt(log2(64)) - 8\n\n[1] -5.55051\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer\n\n\n64 %&gt;% log2() %&gt;% sqrt() %&gt;% -8\n\n[1] -5.55051"
  },
  {
    "objectID": "precourse_preparation_R.html#example-data-1",
    "href": "precourse_preparation_R.html#example-data-1",
    "title": "Precourse Preparation",
    "section": "2.2 Example data",
    "text": "2.2 Example data\nIn this chapter we will work on expression matrix table which is one of the output files from BD Rhapsody Sequencing Analysis Pipeline.\nThe table is provided in csv format. Below is example of how to load the table.\n\nexpMat &lt;- fread(file = \"precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE)\n\n# file: provide full directory to file\n# sep: indicate separator, in this case coma\n# header = True is indicating to take the first row as a column names\n\nDisplaying first rows and columns of the table gives us a glimpse on what the data contain.\n\nexpMat[c(1:5),c(1:5)]\n\n         V1  A1BG A1BG.AS1  A1CF   A2M\n      &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1:  3261781     0        0     0     0\n2:  9155806     0        0     0     0\n3:  4304661     0        0     0     0\n4:  2216902     0        0     0     0\n5: 13160139     0        0     0     0\n\n\nThe gene names are displayed in columns and rows contain information about the cells. The column named V1 hold information about the cell index that is given to each cell in primary analysis.\nWe will set the V1 column as row names. In that way all the columns will contain the gene or protein counts.\n\n#use first column as row names\nexpMat &lt;- data.frame(expMat, row.names = 1)\n\nThe same set of above operations can be performed with pipe in one line of code. We read the file and convert first column to row names and save as data frame. The result is assigned to expMat variable by using the arrow.\n\n#pipe operations\nexpMat &lt;- fread(file = \"precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE) %&gt;% data.frame(row.names = 1)"
  },
  {
    "objectID": "precourse_preparation_R.html#select",
    "href": "precourse_preparation_R.html#select",
    "title": "Precourse Preparation",
    "section": "2.3 select()",
    "text": "2.3 select()\nFunctionality: Select only the columns (variables) that you want to see. Gets rid of all other columns.\nImagine you are interested to extract the data only for one gene existing in your dataset. You can use the gene name, for example “CD4”, to indicate in select function which column should be selected.\n\n# choosing the column of CD4 gene\nexpMat %&gt;% dplyr::select(\"CD4\") -&gt; CD4_column\n\nIn the table we work on, the protein and gene expression information are provided. All the protein markers are labeled with “pAbO” abbreviation, in addition to marker name. We can select all the columns that contain pAbO in name and save to new table.\n\n#choosing all the columns with AbSeq counts and saving to abseq_data\nexpMat %&gt;% dplyr::select(contains(\"pAbO\")) -&gt; abseq_data\n\nAll the columns that does not contain the “pAbO” are representing genes. To create a gene data, we can use the contains() function with exclamation mark as in below example.\nThe “!” is used for negation in R language and is interpreted as “do not”. Below expression will be interpreted as “select from expMat columns that do not contain pAbO.”.\n\n# choosing all columns that does not contain AbSeq counts (mRNA only)\nexpMat %&gt;% dplyr::select(!contains(\"pAbO\")) -&gt; mrna_data"
  },
  {
    "objectID": "precourse_preparation_R.html#mutate",
    "href": "precourse_preparation_R.html#mutate",
    "title": "Precourse Preparation",
    "section": "2.4 mutate()",
    "text": "2.4 mutate()\nFunctionality: Adds new columns or modifies current variables in the dataset.\nThe mutate function allows in easy way to add new columns in existing tables. Let’s say we want to add column named “measurement_type” and fill with “protein expression” in abseq data table we created in previous step.\n\n#add new column with the same value\nabseq_data %&gt;% mutate(data_modality = \"protein_expression\") -&gt; abseq_data \n\nThe new column will be added at the end of table. We can show the column by selecting the column name.\n\n#display results\nabseq_data %&gt;% dplyr::select(\"data_modality\") %&gt;% head\n\n              data_modality\n3261781  protein_expression\n9155806  protein_expression\n4304661  protein_expression\n2216902  protein_expression\n13160139 protein_expression\n11951658 protein_expression\n\n\nMutate function can be used in combination with other functions.\nIn this example we will calculate sum of expression count for each cell and store information in table. We summarize the counts from all rows ad add as a new column. The rowSums function is useful for calculating the sum of counts in each row.\n\nrowSums(mrna_data) -&gt; mRNA_count_sum\n\n#display results\nhead(mRNA_count_sum)\n\n 3261781  9155806  4304661  2216902 13160139 11951658 \n   35231    34733    33238    31618    31664    30786 \n\n\nAfter running rowSums we got for each cell the number of counts. The values can be added in mrna data table as a new column.\n\nmrna_data %&gt;% mutate(counts = mRNA_count_sum) -&gt; mrna_data\nmrna_data %&gt;% dplyr::select(counts) %&gt;% head\n\n         counts\n3261781   35231\n9155806   34733\n4304661   33238\n2216902   31618\n13160139  31664\n11951658  30786\n\n\nThe same result can be generated with option below, where the rowSums function is nested inside the mutate function.\n\nmrna_data %&gt;% mutate(counts = rowSums(mrna_data)) -&gt; mrna_data\n\nNotice that mrna_data is given twice in that case as an argument. The mrna_data is taken by mutate function as first argument and then in rowSums function as second argument.\nIn above example we used pipe to direct the mrna_data to mutate() function as argument. However the mrna_data was not forwarded by pipe to rowSums. For that reason we had to type it in the rowSums function. By default pipe operator forwards data only as first argument to a function. If you want the pipe to forward data as well as second (and next) argument to function you can use a dot.\n\nmrna_data %&gt;% mutate(counts = rowSums(.)) -&gt; mrna_data"
  },
  {
    "objectID": "precourse_preparation_R.html#summarise",
    "href": "precourse_preparation_R.html#summarise",
    "title": "Precourse Preparation",
    "section": "2.5 summarise()",
    "text": "2.5 summarise()\nFunctionality: Collapses all rows and returns a one-row summary.\nIn the example below, summarize function allow us to calculate the max/min, median and mean values for counts.\n\nmrna_data %&gt;% summarise(mean = mean(counts),    #mean counts\n                             median = median(counts),    #median counts\n                             max = max(counts),    #maximum count\n                             min = min(counts))   #minimum count\n\n      mean median    max  min\n1 9142.064   4392 105693 1146\n\n\nIn above summary we have the overview of the expression range and how minimum and maximum values of molecules expressed differ. Some of cells will have very low transcriptome size in comparison to others."
  },
  {
    "objectID": "precourse_preparation_R.html#if_else",
    "href": "precourse_preparation_R.html#if_else",
    "title": "Precourse Preparation",
    "section": "2.6 if_else()",
    "text": "2.6 if_else()\nThe if_else() function in R is a conditional function. It allows to test the hypothesis and perform actions based on answer.\nLet’s assume we want to label the cells according to transcriptom size. Based on threshold of counts we give a label of “low_transcriptome” or “high_transcriptome” for a cell status. We can make assumption that all cells with sum of counts lower then thousand are low transcriptome cells and remaining cells are categorized as high transcriptome cells.\nThe if_else function with combination of mutate will help us to achieve the goal.\nFirst we need to know what is the structure of if_else statement. The first argument of if_else function is the hypotheses or the statement. In our case we want to test if count for cell is below or above the threshold. Second argument of a function is an action to perform if the statement is true. Third argument of if_else function is an action to perform when the statement is false.\n\nIn our case the hypothesis to test is if counts in a cell are below or above the threshold. We can set the condition to have a counts above 2000. If the counts are above the threshold the statement is true. When the statement is true the action is to set the label as “high_transcriptome”. When the statement is false we set the label as “low_transciptome”.\n\nif_else(mrna_data$counts &gt; 2000, \"high_transcriptome\", \"low_transcriptome\") -&gt; cell_status\n\nIn that way we created a cell status for cells based on counts. We should see in a cell_status that was generated two labels. To verify if that is the case we can display unique values of a created vector.\n\nunique(cell_status)\n\n[1] \"high_transcriptome\" \"low_transcriptome\" \n\n\nIf we would like to add that information as a new column to data table, we can use mutate function as in previous examples.\n\n#calcuate and add cell_status to mrna table\nmrna_data %&gt;% mutate(cell_status = if_else(mrna_data[\"counts\"] &gt; 2000, \"high_transcriptome\", \"low_transcriptome\")) -&gt; mrna_data\n\n#display cell status column \nmrna_data %&gt;% dplyr::select(cell_status) %&gt;% head\n\n                cell_status\n3261781  high_transcriptome\n9155806  high_transcriptome\n4304661  high_transcriptome\n2216902  high_transcriptome\n13160139 high_transcriptome\n11951658 high_transcriptome"
  },
  {
    "objectID": "precourse_preparation_R.html#count",
    "href": "precourse_preparation_R.html#count",
    "title": "Precourse Preparation",
    "section": "2.7 count()",
    "text": "2.7 count()\nFunctionality: Collapses the rows and counts the number of observations per group of values.\nThe count function is a quick way to have an overview on number of occurrences. For example to we can use count() to see how many cells were categorized as low or high transcriptome cells.\n\nmrna_data %&gt;% count(cell_status)\n\n         cell_status    n\n1 high_transcriptome 5204\n2  low_transcriptome  597\n\n\nThe function works on text as well as on numbers. In below example, the result summarizes the number of occurrences (rows) having a different counts for CD3.\n\nmrna_data %&gt;% count(CD4)\n\n   CD4    n\n1    0 4457\n2    1  664\n3    2  276\n4    3  152\n5    4   79\n6    5   59\n7    6   40\n8    7   32\n9    8   21\n10   9    9\n11  10    6\n12  11    2\n13  12    1\n14  14    1\n15  17    1\n16  18    1\n\n\nWe interpret the result in following way: there was 4457 rows with zero count for CD4. In other words, there was 4457 cells with zero count for CD4."
  },
  {
    "objectID": "precourse_preparation_R.html#group_by",
    "href": "precourse_preparation_R.html#group_by",
    "title": "Precourse Preparation",
    "section": "2.8 group_by()",
    "text": "2.8 group_by()\nFunctionality: Takes existing data and groups specific variables together for future operations.\nThe group() function takes an existing table and convert it into grouped table where operations are performed by group.\nLet’s have a look into following example and assume that we want to compare the mean and median counts for low and high transcriptome cells. In that case we can group data by cell status and calculate average values for those groups.\n\nmrna_data %&gt;% \n  group_by(cell_status) %&gt;% \n  summarize(mean = mean(counts),\n            median = median(counts),\n            n = n())  #calculates the total number of observations\n\n# A tibble: 2 × 4\n  cell_status          mean median     n\n  &lt;chr&gt;               &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;\n1 high_transcriptome 10006.  4684.  5204\n2 low_transcriptome   1611.  1638    597\n\n\nIn the above code, we have grouped by cell status, meaning that calculations performed on our data will account for high transcriptome and low transcriptome cells separately. Following code execution, the console displays the mean count, the median count and the total number of cells (n()) for low transcriptome and for high transcriptome cells (group_by(cell_status))."
  },
  {
    "objectID": "precourse_preparation_R.html#filter",
    "href": "precourse_preparation_R.html#filter",
    "title": "Precourse Preparation",
    "section": "2.8 filter()",
    "text": "2.8 filter()\nFunctionality: Only retain specific rows of data that meet the specified requirement(s).\nFilter function display from the data values that meet defined condition. For example, we can filter all cells with low transcriptome cell status and retain only high transcriptome cells.\n\nmrna_data %&gt;% filter(cell_status == \"high_transcriptome\") -&gt; signal_cells\n\n#display last column\nsignal_cells %&gt;% dplyr::select(last_col()) %&gt;% head\n\n         cell_status\n1 high_transcriptome\n2 high_transcriptome\n3 high_transcriptome\n4 high_transcriptome\n5 high_transcriptome\n6 high_transcriptome"
  },
  {
    "objectID": "precourse_preparation_R.html#rename",
    "href": "precourse_preparation_R.html#rename",
    "title": "Precourse Preparation",
    "section": "2.9 rename()",
    "text": "2.9 rename()\nFunctionality: Renames a column/variable by name and index.\nRenames the cell_status variable as SIGNAL_CELLS (notice that the new label goes first in the argument).\n\nmrna_data %&gt;% rename(SIGNAL_CELLS = cell_status) -&gt; mrna_data\n\n#display results\nmrna_data %&gt;% dplyr::select(last_col()) %&gt;% head #chose last column from mrna_data\n\n               SIGNAL_CELLS\n3261781  high_transcriptome\n9155806  high_transcriptome\n4304661  high_transcriptome\n2216902  high_transcriptome\n13160139 high_transcriptome\n11951658 high_transcriptome"
  },
  {
    "objectID": "precourse_preparation_R.html#seurat-object-structure",
    "href": "precourse_preparation_R.html#seurat-object-structure",
    "title": "Precourse Preparation",
    "section": "3.1 Seurat Object Structure",
    "text": "3.1 Seurat Object Structure\nSeurat object stores information about the single cell multiomics data and the analysis that was done during downstream workflow. As we move through the workflow and make calculations, the results are added to Seurat object and stored in different “boxes”. Those different “boxes” are called slots.\nLet’s load the Seurat object into R. We will use the Seurat object that is created during workshop in first step, prior to proceeding with next analysis steps, as normalization, clustering etc.\n\nseurat.obj_00 &lt;- readRDS(\"data/precourse_preparation_data/example_seuratObj.rds\")\n\nLoaded Seurat object was created including mRNA counts table obtained from primary analysis. While Seurat object is generated the following information are added to Seurat slots by default: assays, meta data, active assay, active identity, project name and version.\n\nThe remaining Seurat slots highlighted in grey are empty and filled in with information while it is calculated over analysis."
  },
  {
    "objectID": "precourse_preparation_R.html#assays",
    "href": "precourse_preparation_R.html#assays",
    "title": "Precourse Preparation",
    "section": "3.2 Assays",
    "text": "3.2 Assays\nThe assays slot contain different assays loaded into Seurat object. Those can be for example mRNA expression data or protein expression data. The assay slot contains layers that stores ‘transformations’ of the data, including raw counts (counts slot), normalized data (data slot), and scaled data for dimensional reduction (scale.data slot)\nThe assays layers can be listed by Layers(). The layer content can be accessed by function LayerData. In example below we access the data layer from assay slot and display it as data frame.\n\nLayerData(seurat.obj_00, assay = \"RNA\", layer = \"counts\") %&gt;% \n  .[1:10, 1:10]\n\n10 x 10 sparse Matrix of class \"dgCMatrix\"\n                             \nA1BG      . . . . . . . . . .\nA1BG-AS1  . . . . . . . . . .\nA1CF      . . . . . . . . . .\nA2M       . . . . . . . . . .\nA2M-AS1   . . . . . . . . . .\nA2ML1     . . . . . . . . . .\nA2ML1-AS1 . . . . . . . . . .\nA2ML1-AS2 . . . . . . . . . .\nA2MP1     . . . . . . . . . .\nA3GALT2   . . . . . . . . . .\n\n\nIn current Seurat object we have one layer for active RNA assay\n\nLayers(seurat.obj_00)\n\n[1] \"counts\"\n\n\nAdditional layers will be added while analysis is done. For example, when data are normalized or scaled the “data” and “scale.data” layers are added to the object.\n\nseurat.obj_00 &lt;- NormalizeData(seurat.obj_00)\nseurat.obj_00 &lt;- ScaleData(seurat.obj_00)"
  },
  {
    "objectID": "precourse_preparation_R.html#meta-data",
    "href": "precourse_preparation_R.html#meta-data",
    "title": "Precourse Preparation",
    "section": "3.3 Meta Data",
    "text": "3.3 Meta Data\nMeta.data slot stores information calculated for cells as for example number of features in each cell, number of counts or cell clusters calculated in downstream process.\nThe meta.data information is stored in a table that can be accessed in Seurat object as below.\n\nseurat.obj_00[[]] %&gt;% \n  .[1:10, ]\n\n        orig.ident nCount_RNA nFeature_RNA nCount_AbO nFeature_AbO\n3091 SeuratProject       2191         1133       9310           35\n3517 SeuratProject       3051         1324       8566           36\n3921 SeuratProject       1672          951       9324           36\n4283 SeuratProject       2091         1117      11314           38\n4318 SeuratProject       2330         1220      12217           36\n5027 SeuratProject       1942         1087       7923           34\n5088 SeuratProject       1784         1045       7025           33\n5418 SeuratProject       2813         1451       7061           36\n5763 SeuratProject       1812          966       2328           33\n5768 SeuratProject       3126         1429      12918           38\n\n\nTo view list of all available meta.data in Seurat object we can view the column names from the data table.\n\nseurat.obj_00[[]] %&gt;% colnames() %&gt;% head\n\n[1] \"orig.ident\"   \"nCount_RNA\"   \"nFeature_RNA\" \"nCount_AbO\"   \"nFeature_AbO\"\n\n\nWe can extract information of interest from data table by indicating to chosen column names.\n\nseurat.obj_00[[c(\"nCount_AbO\", \"nFeature_RNA\")]] %&gt;% \n  .[1:10, ]\n\n     nCount_AbO nFeature_RNA\n3091       9310         1133\n3517       8566         1324\n3921       9324          951\n4283      11314         1117\n4318      12217         1220\n5027       7923         1087\n5088       7025         1045\n5418       7061         1451\n5763       2328          966\n5768      12918         1429\n\n\nIt is possible to add new information to meta data. It can be any information about the cells as experimental batch or sub-population identity.\n\n#add meta data\nseurat.obj_00 &lt;- AddMetaData(seurat.obj_00, #indicate object\n            \"experiment_1\", #metadata to be added\n            \"batch\") #column name for metadata\n\n#display results\nseurat.obj_00[[c(\"batch\")]] %&gt;% \n  .[1:10, ]\n\n [1] \"experiment_1\" \"experiment_1\" \"experiment_1\" \"experiment_1\" \"experiment_1\"\n [6] \"experiment_1\" \"experiment_1\" \"experiment_1\" \"experiment_1\" \"experiment_1\""
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "",
    "section": "",
    "text": "MIT License\nCopyright (c) 2023 material-share\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "03_normalization.html",
    "href": "03_normalization.html",
    "title": "Chapter 3 Normalization",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)"
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup R and RStudio on Desktop",
    "section": "",
    "text": "1. R and RStudio\nPlease follow the instruction to set up the most up to date R and RStudio on desktop: https://posit.co/download/rstudio-desktop/\n2. Install R packages\n\n\n\n\n\n\nNote\n\n\n\nInstall the packages in the order listed below. The package names are case sensitive.\n\n\n\n\nOnly for windows machines: Please download and install RTools from https://cran.r-project.org/bin/windows/Rtools/.\nInstall the packages listed below one by one from CRAN using the install.packages() function.\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"Matrix\")\ninstall.packages(\"RCurl\")\ninstall.packages(\"scales\")\ninstall.packages(\"data.table\")\ninstall.packages(\"readxl\")\ninstall.packages(\"BiocManager\")\ninstall.packages(\"ggpubr\")\ninstall.packages(\"Seurat\")\n\nInstall the packages listed below one by one from bioconductor using the BiocManager::install() function.\n\nBiocManager::install(\"ensembldb\")\nBiocManager::install(\"org.Hs.eg.db\")\nBiocManager::install(\"clusterProfiler\")\nBiocManager::install(\"AnnotationDbi\")\nBiocManager::install(\"biomaRt\")\nBiocManager::install(\"enrichplot\")\nBiocManager::install(\"HGNChelper\")\nOptional: The materials are updated to Seurat V5. If you want to use Seurat V4, you can follow the below instruction to install Seurat V4. Please note that you may need to adapt the code to fit Seurat V4 structure.\nFirst check the version of installed SeuratObject and Seurat.\n\npackageVersion(\"SeuratObject\")\npackageVersion(\"Seurat\")\n\nIf the version is 5.0.x, please follow the below instructions to remove the existing Seurat package and install Seurat V4.\n\nremove.packages(\"SeuratObject\")\nremove.packages(\"Seurat\")\n\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/SeuratObject/SeuratObject_4.1.4.tar.gz\" \ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/Seurat/Seurat_4.4.0.tar.gz\" \ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\nValidate the installation is successful by running packageVersion.\n\npackageVersion(\"SeuratObject\")\npackageVersion(\"Seurat\")\n\n\nCheck that all the packages were installed successfully by loading them one by one at a time using the library() function.\n\n\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(BiocManager)\nlibrary(Matrix)\nlibrary(RCurl)\nlibrary(readxl)\nlibrary(scales)\nlibrary(ggpubr)\nlibrary(data.table)\nlibrary(AnnotationHub)\nlibrary(ensembldb)\nlibrary(HGNChelper)\nlibrary(clusterProfiler)\nlibrary(AnnotationDbi)\nlibrary(biomaRt)\nlibrary(enrichplot)\n\n3. Download dataset and code\nPlease follow the below steps if you would like to run the materials locally.\n\n\nDataset: Please download the data here: Data.\n\nGithub folder: You will also need to download the entire repository as a .zip from https://github.com/material-share/material-share-single-cell-boot-camp/tree/master.\n\n\nAfter download, unzip the repository and put the Data folder in the repository.\n\nTo run the analysis, double click on single-cell-boot-camp.Rproj. One should be able to bring out the RStudio console on desktop.\n4. Contribution\nIf you would like to contribute, report bugs, or suggest any tools or workflow, please open on issue: https://github.com/material-share/material-share-single-cell-boot-camp/issues."
  },
  {
    "objectID": "precourse_preparation_theory.html",
    "href": "precourse_preparation_theory.html",
    "title": "Precourse Preparation - Theory",
    "section": "",
    "text": "Our body has many cell types with different functions and they interact with each other in a daily basis. We can imagine it like a bustling city with different workers specializing in different tasks.\nSingle-cell RNA sequencing (scRNAseq) can help to understand the cell types and their functionality. It’s like taking a close-up picture of each cell and see which genes are active.\nThis technique can be applied to:\n\nInvestigating different types of cells in a specific tissue. Example: Understanding the various cell types in the brain.\nDiscovering noval cell types or states. Example: Identifying unique cell types in the immune system.\nFiguring out how genes change their activity as cells differentiate over time. Example: Tracking gene expression dynamics such as stem cells differentiation.\nFinding genes that are active in certain cell types under certain conditions. Example: Finding genes that switch on and off in lung cells in asthma.\nExamining how gene activity changes within a cell type under certain conditions. Example: Studying how nerve cells in the spinal cord change their gene activity in response to injury."
  },
  {
    "objectID": "precourse_preparation_theory.html#bd-rhapsody-single-cell-assays",
    "href": "precourse_preparation_theory.html#bd-rhapsody-single-cell-assays",
    "title": "Precourse Preparation - Theory",
    "section": "2.1 BD Rhapsody Single-Cell Assays",
    "text": "2.1 BD Rhapsody Single-Cell Assays\n\nThe BD Rhapsody™ System, along with diverse range of assays, enables simultaneous measurement of multiple cell parameters across tens of thousands of individual cells in parallel. By combining available assays, researchers can generate robust and intricate datasets, unlocking powerful insights:\nGene Expression: The primary purpose of scRNA-seq is to measure the expression of genes within individual cells. This allows to understand which genes are active or inactive in each cell and to identify different cell types based on their gene expression profiles.\nAntibody-Based Protein Analysis: You can use antibodies conjugated with unique barcodes to simultaneously measure the expression of specific proteins in individual cells. This enables protein-level analysis alongside gene expression.\nSample multiplexing with antibody-based techniques: involves using generic antibody conjugated with unique barcodes to label the cells for different samples. Each sample is labeled and idenfied with unique antibody barcode.\nImmune Repertoire Profiling: Rhapsody can be used for immune profiling, allowing researchers to analyze the diversity and clonality of T-cell and B-cell receptor repertoires. This is valuable for studying the immune response and identifying antigen-specific cells.\nAntigen-Specific T-cell Analysis: Immudex’s technology combined with the Rhapsody system, enables the precise profiling of T cells that recognize specific antigens, like viral epitopes or tumor-related antigens. This expands immune profiling possibilities, aiding vaccine development, immunotherapy research, and the study of immune-related diseases.\nFrom scRNA-seq for gene expression profiling to antibody-based protein analysis, these assays empower researchers to explore and dissect the multifaceted world of cellular functions and molecular dynamics with precision"
  },
  {
    "objectID": "precourse_preparation_theory.html#analysis-of-single-cell-data",
    "href": "precourse_preparation_theory.html#analysis-of-single-cell-data",
    "title": "Precourse Preparation - Theory",
    "section": "2.2 Analysis of Single Cell Data",
    "text": "2.2 Analysis of Single Cell Data\nThe analysis of single cell data can be split into two parts. The primary analysis transforms raw data into an expression matrix, where each row represents a gene, each column represents a cell, and each entry in the matrix contains the count of molecules for a particular gene or protein in a specific cell. Secondary analysis focus on extracting meaningful biological insights from this expression matrix, such as identifying cell types, studying differential gene expression, and understanding cellular processes and functions.\n\nThe workshop will focus on providing insights into secondary analysis. At the same time the primary analysis lays the foundation for secondary and downstream analyses. The next chapter covers information about primary analysis useful to know while working with single-cell data."
  },
  {
    "objectID": "precourse_preparation_theory.html#from-sequencing-data-to-expression-matrix",
    "href": "precourse_preparation_theory.html#from-sequencing-data-to-expression-matrix",
    "title": "Precourse Preparation - Theory",
    "section": "2.3 From Sequencing Data to Expression Matrix",
    "text": "2.3 From Sequencing Data to Expression Matrix\nThe analysis of sequencing data is handled by the software provided by BD to Rhapsody users that enables fast and easy data processing. In this chapter we will cover a key features of the pipeline and explain key concepts necessary to understand while working with single cell data.\n\n2.3.1 BD Rhapsody Sequencing Analysis Pipeline\nThe BD Rhapsody sequencing analysis pipeline is a series of computational and analytical steps used to process and extract meaningful information from the raw sequencing data generated by the BD Rhapsody system.\nThe goal of sequencing analysis is to transform text-based genomic data into numerical data, and we achieve this through a series of steps in our pipeline. The steps of the pipeline are listed in simplified graphics below.\n\nThe main steps of the pipeline include quality control of raw sequencing data, molecule counting, identifying the putative cells and sample of origin if multiple samples were processed in one experiment.\nCrucial Steps in the process are decoding the unique barcodes associated with individual cells and the information about gene expression. Additionally, we use a technique called Unique Molecular Identifiers (UMIs) to count gene expression accurately. These steps enable us to precisely identify and quantify the activity of genes in each cell, forming the basis for further analysis.\n\n\n2.3.2 Expression Counts by UMIs\nUnique Molecular Identifiers (UMIs) are used to distinguish between molecules expressed in a cell by providing a way to count individual molecules accurately. Here’s how they work to differentiate and quantify molecules in a cell:\n\nAdding UMIs during RNA sequencing preparation: UMIs are small, unique sequences of DNA that are added to the capture sequences of the bead during the production. Each bead contains tens of thousands of unique UMI barcodes which are followed by the polyA capture sequence. During the cell processing, the polyadenylated molecules in a cell, as mRNAs are captured on the bead. Each UMI is specific to the molecule it’s attached to and become it’s unique tag (see Figure below).\n\n\n\n\nCreating copies of RNA molecules: After adding UMIs, scientists make many copies of all the RNA molecules in the cell by running PCR. This step ensures that there are enough copies to work with.\nSequencing the molecules: The copies of RNA molecules, including the attached UMIs, are then sequenced. Sequencing means reading the genetic code of these molecules to determine their identity.\n\nAnalyzing the data: When the sequencing is done, scientists look at the data. Here’s where UMIs become important:\n\nRemoving duplicates: Because UMIs are unique to each original RNA molecule, any duplicates (multiple copies of the same RNA molecule) with the same UMI are likely the result of PCR (Polymerase Chain Reaction) amplification during the sequencing process. Scientists can identify and remove these duplicates to get an accurate count of different RNA molecules.\nCounting unique molecules: By looking at the UMIs, scientists can count how many unique RNA molecules were originally present in the cell. This helps them understand which genes were active in the cell and to what extent.\nQuantifying gene expression: By counting the unique UMIs associated with each gene, scientists can measure the expression level of genes in the cell. Genes with more UMIs were more active in the cell, while genes with fewer UMIs were less active.\n\nIn summary, UMIs are used to distinguish between molecules expressed in a cell by providing a unique identifier for each original molecule. This helps in accurately counting and quantifying gene expression, which is crucial for understanding how genes function in single cells and studying cellular processes in detail.\n\n\n2.3.3 Output Files\nWe handle various types of data all at once during primary analysis. This includes data related to gene expression at first but can include as well protein expression or information about T-cell receptors (TCR), B-cell receptors (BCR), and sample tags depending on experimental part. The assays run during experiments determine what type of data will be generated and what output files are available for the users for downstream analysis.\nThe information about cells is stored in multiple output files. In below you can find summary of what output files relates to which information about the cell.\n\nThe primary analysis output files are taken as an input to secondary analysis. During the workshop we will work with data that include mRNA, protein and sample tag information. You will get to know how to load the expression matrice in MEX format for downstream analysis."
  },
  {
    "objectID": "02_quality_control.html",
    "href": "02_quality_control.html",
    "title": "Chapter 2 Quality Control",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)"
  },
  {
    "objectID": "02_quality_control.html#ncount_rna-umi-counts-per-cell",
    "href": "02_quality_control.html#ncount_rna-umi-counts-per-cell",
    "title": "Chapter 2 Quality Control",
    "section": "3.1 nCount_RNA UMI counts per cell",
    "text": "3.1 nCount_RNA UMI counts per cell\nWe look at nCount_RNA for the sum of UMI counts per cell.\n\nrna@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=nCount_RNA, fill= Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  ggtitle(\"nCount_RNA\")"
  },
  {
    "objectID": "02_quality_control.html#nfeature_rna-gene-counts-per-cell",
    "href": "02_quality_control.html#nfeature_rna-gene-counts-per-cell",
    "title": "Chapter 2 Quality Control",
    "section": "3.2 nFeature_RNA Gene counts per cell",
    "text": "3.2 nFeature_RNA Gene counts per cell\nWe look at nFeature_RNA for sum of gene counts per cell. The majority of cells have gene counts more than 300.\n\nrna@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=nFeature_RNA, fill= Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  ggtitle(\"nFeature_RNA\")"
  },
  {
    "objectID": "02_quality_control.html#percent.mt-mitochondrial-percentage-per-cell",
    "href": "02_quality_control.html#percent.mt-mitochondrial-percentage-per-cell",
    "title": "Chapter 2 Quality Control",
    "section": "3.3 percent.mt Mitochondrial percentage per cell",
    "text": "3.3 percent.mt Mitochondrial percentage per cell\nWe look at percent.mt for mitochondrial percentage per cell. The majority of cells have mitochondrial percentage below 25%.\n\nrna@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=percent.mt, fill=Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  ggtitle(\"percent.mt\")"
  },
  {
    "objectID": "02_quality_control.html#combine-metrics-to-come-up-filtering-threshold",
    "href": "02_quality_control.html#combine-metrics-to-come-up-filtering-threshold",
    "title": "Chapter 2 Quality Control",
    "section": "3.4 Combine metrics to come up filtering threshold",
    "text": "3.4 Combine metrics to come up filtering threshold\nWe can combine the metrics to decide the filtering threshold.\n\nrna@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500, colour = \"red\") +\n  geom_hline(yintercept = 300, colour = \"red\") +\n  facet_wrap(~Sample_Name) +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n\n\n\nThe data is fitted with a linear regression line. We expect when UMI counts increase, gene counts also increase.\nUpper right quadrant: Cells with high number of genes and UMI counts. We generally consider these cells to be good-quality cells.\nBottom right quadrant: Cells with low number of genes and UMI counts. We generally consider these cells are low-quality cells.\nDarker cells: Cells with high mitochondrial percentage. Many of these cells have low gene counts. This could indicate damaged/dying cells whose cytoplasmic mRNA leaked out through a broken membrane, so only mRNA located in the mitochondria is still conserved."
  },
  {
    "objectID": "02_quality_control.html#filter-on-cells",
    "href": "02_quality_control.html#filter-on-cells",
    "title": "Chapter 2 Quality Control",
    "section": "4.1 Filter on cells",
    "text": "4.1 Filter on cells\nBased on the quality metrics, we use the following thresholds to filter out low quality cells:\nnCount_RNA &gt; 500\nnFeature_RNA &gt; 300\nnFeature_RNA &lt; 5000\npercent.mt &lt; 25%\n\nfiltered.rna &lt;- subset(x = rna, \n                       subset = (nCount_RNA &gt;= 500) & \n                         (nFeature_RNA &gt;= 300) &\n                         (nFeature_RNA &lt;= 5000) &\n                         (percent.mt &lt; 25))\n\n\n\n\n\n\n\nImportant\n\n\n\nThe filtering thresholds should be decided based on assessing the quality metrics. They may change depending on the sample types, sequencing depth and other factors."
  },
  {
    "objectID": "02_quality_control.html#filter-on-genes",
    "href": "02_quality_control.html#filter-on-genes",
    "title": "Chapter 2 Quality Control",
    "section": "4.2 Filter on genes",
    "text": "4.2 Filter on genes\nAfter filtering on cells, some genes may have zero counts or are only expressed in few cells. These genes do not bring much information, and they reduce the average expression of a cell.\nWe keep only genes that are expressed in five or more cells. GetAssayData is a convenient command to get information from the Seurat object. We use GetAssayData to extract the UMI counts.\n\n# Extract counts\ncounts &lt;- GetAssayData(object = filtered.rna, slot = \"counts\")\n\n# Output a logical matrix specifying for each gene whether or not \n# there are more than zero counts per cell\nnonzero &lt;- counts &gt; 0\n\n# Sum all TRUE values and return TRUE \n# if equal or more than 5 TRUE values per gene\nkeep_genes &lt;- Matrix::rowSums(nonzero) &gt;= 5\n\n# Only keep those genes\nfiltered_counts &lt;- counts[keep_genes, ]\n\n# Create Seurat object\nfiltered.rna &lt;- CreateSeuratObject(filtered_counts, meta.data = filtered.rna@meta.data)\n\n\n\n\n\n\n\nImportant\n\n\n\nIn this example, we keep only genes that are expressed in five or more cells."
  },
  {
    "objectID": "sessioninfo.html",
    "href": "sessioninfo.html",
    "title": "SessionInfo",
    "section": "",
    "text": "Note\n\n\n\n\nsessionInfo()\n\nR version 4.3.0 (2023-04-21)\nPlatform: x86_64-apple-darwin20 (64-bit)\nRunning under: macOS 14.1.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Amsterdam\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] sessioninfo_1.2.2\n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.0    fastmap_1.1.1     cli_3.6.1        \n [5] tools_4.3.0       htmltools_0.5.7   rstudioapi_0.15.0 yaml_2.3.7       \n [9] rmarkdown_2.25    knitr_1.45        jsonlite_1.8.7    xfun_0.41        \n[13] digest_0.6.33     rlang_1.1.2       evaluate_0.23"
  },
  {
    "objectID": "04_integration.html",
    "href": "04_integration.html",
    "title": "Chapter 4 Integration",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\n\nLoad RData\nLoad the RData which contains all files from previous chapter.\n\nload(\"data/intermediate_data/chapter3.RData\")\n\n1. To integrate or not to integrate?\nThe goal of integration is to find corresponding cell states across conditions (or experiments). We want to identify cell types which are present in all samples/conditions/modalities within our dataset. We expect to observe a representation of cells from samples/conditions/modalities in every cluster.\nWe first look at how cells cluster without integration to determine whether integration is necessary. Integration is considered if cells cluster separately on samples/conditions/modalities, etc.\n\n# Run the standard workflow for visualization\nfiltered.rna &lt;- RunUMAP(filtered.rna, dims = 1:15)\n\nDimPlot(filtered.rna, group.by = \"Sample_Name\")\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nJudging by the UMAP, do the two samples need to be integrated?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe same cell types from the two samples are not aligned. One may consider to perform integration.\n\n\n\n2. Perform integration\nFirst, we select the variable features. The features should be selected in each dataset.\n\n# split the dataset into a list of two seurat objects (treated and naive)\nsplit.filtered.rna &lt;- SplitObject(filtered.rna, split.by = \"Sample_Name\")\n\n# normalize and identify variable features for each dataset independently\nsplit.filtered.rna &lt;- lapply(X = split.filtered.rna, FUN = function(x) {\n    x &lt;- NormalizeData(x)\n    x &lt;- FindVariableFeatures(x, selection.method = \"vst\", nfeatures = 2000)\n})\n\n# Select the most variable features to use for integration\ninteg.features &lt;- SelectIntegrationFeatures(object.list = split.filtered.rna, \n                                            nfeatures = 2000) \n\nNext, we perform the integration across samples. This step can take a while to run.\n\nanchors &lt;- FindIntegrationAnchors(object.list = split.filtered.rna,\n                                  anchor.features = integ.features)\n\nFinally, we can integrate across samples. By default, normalization.method is set to LogNormalize.\n\nintegrate.filtered.rna &lt;- IntegrateData(anchorset = anchors)\n\n3. UMAP visualization\nAfter integration, we look at the integrated data on UMAP. To calculate UMAP, we need to first calculate PCA and select top PCs.\nMethods to select top PCs were used a lot more often when the data was normalized with LogNormalize.\n\nintegrate.filtered.rna &lt;- ScaleData(integrate.filtered.rna, verbose = FALSE)\nintegrate.filtered.rna &lt;- RunPCA(integrate.filtered.rna, npcs = 50, verbose = FALSE)\n\nElbow plot can help to select top PCs. The PC number, where the elbow is, is used to calculate UMAP.\n\nElbowPlot(integrate.filtered.rna, ndims = 50)\n\n\n\n\nFor this dataset, we use the first top 20 PCs. For other datasets, one may need to adjust the PCs according to the elbow plot.\n\nintegrate.filtered.rna &lt;- RunUMAP(integrate.filtered.rna, \n                                  reduction = \"pca\", \n                                  dims = 1:10)\n\nintegrate.filtered.rna &lt;- FindNeighbors(integrate.filtered.rna, \n                                        reduction = \"pca\", \n                                        dims = 1:10)\n\n\n# Plot UMAP                             \nDimPlot(integrate.filtered.rna, group.by = \"Sample_Name\")   \n\n\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nChange the number of PCs and see how the UMAP changes.\nTips: You can change the PC numbers by dims argument in RunUMAP.\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nDimplot has many arguments to control the plots.\n\nSearch Dimplot in the “Help” tab and read the documentation.\nChange group.by to split.by. What is the difference?\n\n\n\nWhen we compare the similarity between the naive and treated clusters in the plots with or without integration, it is clear that this dataset benefits from the integration.\n\np1 &lt;- DimPlot(filtered.rna, group.by = \"Sample_Name\") + NoLegend()\np2 &lt;- DimPlot(integrate.filtered.rna, group.by = \"Sample_Name\")  + NoLegend()\n\np1|p2\n\n\n\n\n4. Save\nSave the files into RData for documentation.\n\n# save(integrate.filtered.rna, expMat, file = \"data/intermediate_data/chapter4.RData\")"
  },
  {
    "objectID": "09_combining.html",
    "href": "09_combining.html",
    "title": "Chapter 9 Combine scRNAseq and AbSeq",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\n\nLoad RData\nLoad the RData which contains all files from the previous chapter.\n\nload(\"data/intermediate_data/chapter7.RData\")\n\nWhen the experiment has RNA profiling (scRNA) and protein profiling (AbSeq) in single cell resolution, each measurement is one modality. The combined analysis of scRNA and AbSeq is so called “multimodal analysis”.\nSeurat package also provides the framework to analyze multimodal data. The framework is the the weighted nearest neighbors (WNN) approach, which enables simultaneous clustering of cells based on weighted combination of both modalities.\n\n\n\n\n\n\nNote\n\n\n\nRNA profiling and protein profiling should be analyzed separately before combing for downstream analysis.\n\n\n1. Processing AbSeq\nWhen we analyzed the scRNAseq in the previous chapters, the dataset was filtered and only high quality cells are kept. AbSeq dataset is filtered to have the same cells.\n\n# get AbSeq from expMat\nab &lt;- expMat$`Antibody Capture`\n\n# filter abseq data based on cell id from rna seurat object\nab &lt;- ab[, colnames(integrate.filtered.rna)]\n\nCreating a new Seurat object with AbSeq.\n\n# create a new assay to store AbSeq information\nab &lt;- CreateAssayObject(counts = ab)\n\n# create a new Seurat object to store the combined analysis\ncombined &lt;- integrate.filtered.rna\ncombined[[\"AB\"]] &lt;- ab\n\n# Validate that the object now contains multiple assays\ncombined\n\nAn object of class Seurat \n40809 features across 4160 samples within 7 assays \nActive assay: RNA (19347 features, 0 variable features)\n 6 other assays present: integrated, refAssay, prediction.score.celltype.l1, prediction.score.celltype.l2, prediction.score.celltype.l3, AB\n 4 dimensional reductions calculated: pca, umap, integrated_dr, ref.umap\n\n\nNext, we normalize the AbSeq counts.\nThe recommended normalization method for AbSeq is CLR, Centered Log Ratio. Due to the unspecific binding background signal of antibody, log-normalization doesn’t work well in AbSeq data.\nThere are 20 AbSeq in the experiment. We are going to use all of them as variable features.\n\n# switch the default assay to AbSeq\nDefaultAssay(combined) &lt;- 'AB'\n\n# set variable features\nVariableFeatures(combined) &lt;- rownames(combined[[\"AB\"]])\n\n# set a name for the dimentionality reduction to avoid overwriting\ncombined &lt;- NormalizeData(combined, normalization.method = 'CLR', margin = 2) %&gt;% \n  ScaleData() %&gt;% \n  RunPCA(reduction.name = 'apca', approx = F)\n\n2. Weighted nearest neighbour (WNN)\nThe weighted nearest neighbor (WNN) is a statistical framework implemented in Seurat for the multimodal analysis. WNN requires pre-processing and dimentionality reduction on both assays independently upfront.\n\ncombined &lt;- FindMultiModalNeighbors(combined, \n                                    reduction.list = list(\"pca\", \"apca\"), \n                                    dims.list = list(1:15, 1:18), \n                                    modality.weight.name = \"RNA.weight\")\n\n\nreduction.list Dimentionality reduction to use from each element\ndims.list Number of PCs to include from each element\nmodality.weight.name Give a name to the weight of each element\n\nNow, we run UMAP using the calculated WNN.\nFor each cell, we calculate its closest neighbors in the dataset based on a weighted combination of RNA and protein similarities. We specify the dimensionality of each modality (similar to specifying the number of PCs to include in scRNA-seq clustering). We use the same number of PCs as we did in previous steps.\n\n# run UMAP\ncombined &lt;- RunUMAP(combined, \n                    nn.name = \"weighted.nn\", \n                    reduction.name = \"wnn.umap\", \n                    reduction.key = \"wnnUMAP_\")\n\n# find clusters\ncombined &lt;- FindClusters(combined, \n                         graph.name = \"wsnn\", \n                         resolution = 0.4, \n                         verbose = FALSE)\n\nLook at the results in UMAP.\n\n# visualize the result in UMAP\np1 &lt;- DimPlot(combined, reduction = 'wnn.umap', \n              label = TRUE, repel = TRUE, label.size = 2.5, \n              group.by = \"predicted.celltype.l1\")\n\np2 &lt;- DimPlot(combined, reduction = 'wnn.umap', \n              label = TRUE, repel = TRUE, label.size = 2.5)\n\np1|p2\n\n\n\n\nLet’s compare the UMAPs from RNA only and from WNN. The T cells cluster better in WNN UMAP. Because AbSeq is often handpicked and cell type specific, bringing AbSeq in can have a better resolution.\n\n# compare the UMAPs based on RNA and on WNN\np1 &lt;- DimPlot(combined, reduction = 'umap', group.by = 'predicted.celltype.l1', \n              label = TRUE, repel = TRUE, label.size = 2.5) + \n  NoLegend() + ggtitle(\"RNA\")\n\np2 &lt;- DimPlot(combined, reduction = 'wnn.umap', group.by = 'predicted.celltype.l1', \n              label = TRUE, repel = TRUE, label.size = 2.5) + \n  NoLegend() + ggtitle(\"WNN\")\n\np1|p2\n\n\n\n\n3. AbSeq visualization\nWe have several assays stored in the Seurat object. We can easily switch between them and work on different assays.\n\n\n\n\n\n\nImportant\n\n\n\nIt is important to know which assay you are working on. We may get unexpected results if working on the wrong assay.\n\n\nLet’s look at the protein and gene expression side by side. By setting the default assay, we can visualize one or the other.\nCD19 is a B cell marker. We can plot the UMAP with annotation side by side with the CD19 AbSeq.\n\n# switch default assay to AbSeq to plot protein expression\nDefaultAssay(combined) &lt;- \"AB\"\np1 &lt;- FeaturePlot(combined, \"CD19-CD19-AHS0030-pAbO\", \n                  cols = c(\"lightgrey\", \"darkgreen\"), \n                  reduction = 'wnn.umap')\n\n# switch default to RNA to plot gene expression\nDefaultAssay(combined) &lt;- \"RNA\"\np2 &lt;- FeaturePlot(combined, \"CD19\", reduction = 'wnn.umap')\n\n# place plots side-by-side\np1 | p2\n\n\n\n\n4. Save\nSave the files into RData for documentation.\n\n# save(combined, expMat, ab, integrate.filtered.rna, file = \"data/intermediate_data/chapter9.RData\")"
  },
  {
    "objectID": "05_clustering.html",
    "href": "05_clustering.html",
    "title": "Chapter 5 Clustering",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(clustree)\nlibrary(HGNChelper)\n\nLoad RData\nLoad the RData which contains all files from the previous chapter.\n\nload(\"data/intermediate_data/chapter4.RData\")\n\n1. Clustering\nNow that we have our high quality cells integrated, we want to know the different cell types present within our population of cells.\nSeurat uses a graph-based clustering approach, which embeds cells in a graph structure, using a K-nearest neighbor (KNN) graph (by default), with edges drawn between cells with similar gene expression patterns. Then, it attempts to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.\nWe will use the FindClusters function to perform the graph-based clustering. The resolution is an important argument that sets the “granularity” of the downstream clustering and will need to be optimized for every individual experiment.\n\n\n\n\n\n\nImportant\n\n\n\nIncreasing resolution value leads to a greater number of clusters, which is often required for larger datasets.\n\n\nThe FindClusters function allows us to enter a series of resolutions and will calculate the “granularity” of the clustering. This is very helpful for testing which resolution works for moving forward without having to run the function for each resolution.\n\n# Determine the K-nearest neighbor graph\nintegrate.filtered.rna &lt;- FindNeighbors(object = integrate.filtered.rna, dims = 1:10)\n                                \n# Determine the clusters for various resolutions                                \nintegrate.filtered.rna &lt;- FindClusters(object = integrate.filtered.rna,\n                                       resolution = c(0.2, 0.4, 0.6,  0.8, 1, 1.2, 1.4),\n                                       verbose = F)\n\nThe meta.data has a separate column for each of the different resolution calculated. We can look at how many clusters in each resolution.\n\nintegrate.filtered.rna@meta.data %&gt;% \n  dplyr::select(contains(\"integrat\")) %&gt;% \n  map_int(~ unique(.x) %&gt;% length)\n\nintegrated_snn_res.0.2 integrated_snn_res.0.4 integrated_snn_res.0.6 \n                     9                     11                     13 \nintegrated_snn_res.0.8   integrated_snn_res.1 integrated_snn_res.1.2 \n                    15                     16                     17 \nintegrated_snn_res.1.4 \n                    19 \n\n\n\nclustree(integrate.filtered.rna, prefix = \"integrated_snn_res.\")\n\n\n\n\nWe start with the resolution of 0.6. We assign the identity of the clusters using the Idents function to specify that we want to look at the clusters calculating with resolution = 0.6.\n\nIdents(object = integrate.filtered.rna) &lt;- \"integrated_snn_res.0.6\"\n\n# UMAP visualization\nDimPlot(integrate.filtered.rna,\n        reduction = \"umap\",\n        label = TRUE,\n        label.size = 6)\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nChange to other resolution values. How do the clusters change?\n\n\n2. Distribution of cells per cluster\nThe number of clusters are sensitive to the resolution. The demo dataset has PBMC and we expect each cluster contains cells from both samples.\n\nFetchData(integrate.filtered.rna, \n          vars = c(\"ident\", \"Sample_Name\")) %&gt;%\n  dplyr::count(ident, Sample_Name) %&gt;%\n  tidyr::spread(ident, n)\n\n  Sample_Name   0   1   2   3   4   5   6   7  8  9 10 11 12\n1       naive 355 243 428 226   8   5 281  70 96 62 13 35 28\n2     treated 508 332 140 217 322 304  14 177 53 71 82 59 31\n\n\nWe can split the UMAP by sample.\n\n# UMAP of cells in each cluster by sample\nDimPlot(integrate.filtered.rna, \n        label = TRUE, \n        split.by = \"Sample_Name\")  + NoLegend()\n\n\n\n\n3. Exploring known cell type markers\nWe can explore some known cell type markers to get an idea about the identity of clusters.\nSome typical cell type markers:\n\nCD14+ monocytes: CD14, LYZ\nConventional dendritic cells: FCER1A, CST3\nB cells: CD79A, MS4A1\nT cells: CD3D\nCD4+ T cells: CD3D, IL7R, CCR7\nCD8+ T cells: CD3D, CD8A\nNK cells: GNLY, NKG7\nMacrophages: MARCO, ITGAM, ADGRE1\n\nThe FeaturePlot makes it easy to visualize a handful of genes using the gene IDs stored in the Seurat object. We can easily explore the expression of known gene markers on top of our UMAPs. Let’s go through and determine the identities of the clusters. To access the normalized expression levels of all genes, we can use the normalized counts stored in the RNA assay slot.\n\nDefaultAssay(integrate.filtered.rna) &lt;- \"RNA\"\n\n\nCD14+ monocytes: CD14, LYZ\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD14\", \"LYZ\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nB cells: CD79A, MS4A1\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD79A\", \"MS4A1\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nNK cells: GNLY, NKG7\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"GNLY\", \"NKG7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nT cells: CD3D\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nCD4+ T cells: CD3D, IL7R, CCR7\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"IL7R\", \"CCR7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nCD8+ T cells: CD3D, CD8A\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"CD8A\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n4. Save\nSave the files into RData for documentation.\n\n# save(integrate.filtered.rna, expMat, file = \"data/intermediate_data/chapter5.RData\")"
  },
  {
    "objectID": "06_marker_identification.html",
    "href": "06_marker_identification.html",
    "title": "Chapter 6 Marker Identification",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(HGNChelper)"
  },
  {
    "objectID": "06_marker_identification.html#findallmarkers",
    "href": "06_marker_identification.html#findallmarkers",
    "title": "Chapter 6 Marker Identification",
    "section": "1.1 FindAllMarkers\n",
    "text": "1.1 FindAllMarkers\n\nThis type of analysis is typically for evaluating a single sample group/condition. With the FindAllMarkers function, we are comparing each cluster to all other clusters to identify potential marker genes. The cells in each cluster are treated as replicates, and essentially a differential expression analysis is performed with some statistical test. By default, the test is Wilcoxon Rank Sum test.\nThe FindAllMarkers function has three arguments to determine if a gene is a marker gene.\n\nlogfc.threshold Limit testing to genes that show, on average, at least an X-fold difference (log-scale) between the two groups of cells. The default is 0.25. Increasing logfc.threshold speeds up the function but can miss weaker signals.\nmin.pct Only test genes that are detected in a minimum fraction of cells in either of the two populations. It is meant to speed up the function by not testing infrequently expressed genes. The default is 0.1.\nonly.pos Only return positive markers (FALSE by default).\n\nOne may change the arguments depending on how stringent to be.\nWe look at the marker genes in the clusters in sample “treated”.\n\ntreated.markers &lt;- FindAllMarkers(subset(integrate.filtered.rna, subset = Sample_Name == \"treated\"), \n                                  assay = \"RNA\",\n                                  only.pos = TRUE, \n                                  min.pct = 0.25, \n                                  logfc.threshold = 0.25)\n\nLet’s look at the top 2 significant marker genes in each cluster.\n\ntreated.markers %&gt;%\n    group_by(cluster) %&gt;%\n    slice_max(n = 2, order_by = avg_log2FC)\n\n# A tibble: 26 × 7\n# Groups:   cluster [13]\n       p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene      \n       &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;     \n 1 9.89e-158       2.63 0.744 0.212 1.91e-153 0       MAL       \n 2 3.62e-104       2.10 0.734 0.379 7.01e-100 0       PCED1B-AS1\n 3 0               5.06 0.961 0.055 0         1       GNLY      \n 4 3.65e-259       4.13 0.892 0.108 7.07e-255 1       CCL5      \n 5 5.52e- 12       1.07 0.75  0.515 1.07e-  7 2       HSPD1     \n 6 6.86e- 17       1.00 0.957 0.787 1.33e- 12 2       NPM1      \n 7 5.53e- 82       2.41 0.594 0.119 1.07e- 77 3       RGS1      \n 8 5.81e- 25       1.82 0.304 0.09  1.12e- 20 3       FOXP3     \n 9 1.24e-122       2.25 0.916 0.276 2.39e-118 4       LTA       \n10 1.65e-159       1.97 0.941 0.225 3.20e-155 4       MIR155HG  \n# ℹ 16 more rows\n\n\nWe get a table with the information on marker genes.\np_val P-value before multiple testing.\navg_log2FC Log2 fold change on the average gene expression between one cluster and the rest of cluster combined.\npct.1 Percentage of cells expressing the gene in one group. Here is one cluster.\npct.2 Percentage of cells expressing the gene in another group. Here is the rest of cluster combined.\np_val_adj p-value with multiple testing correction."
  },
  {
    "objectID": "06_marker_identification.html#findconservedmarkers",
    "href": "06_marker_identification.html#findconservedmarkers",
    "title": "Chapter 6 Marker Identification",
    "section": "1.2 FindConservedMarkers\n",
    "text": "1.2 FindConservedMarkers\n\nWe have two samples, naïve and treated. We can find conserved markers between the conditions with the function, FindConservedMarkers.\nThis function internally separates out cells by sample group/condition, then performs differential gene expression testing for a single specified cluster against all other clusters.\nGene-level p-values are computed for each condition and then combined across groups using meta-analysis methods from the MetaDE R package.\nMany of the arguments in FindConservedMarkers are shared with FindAllMarkers. Here, we list some additional arguments when using FindConservedMarkers.\n\nident.1 This function only evaluates one cluster at a time; here, you would specify the cluster of interest.\ngrouping.var The variable (column name) in your metadata specifies the separation of cells into groups.\n\n\nfcm &lt;- FindConservedMarkers(integrate.filtered.rna,\n                     assay = \"RNA\",\n                     ident.1 = \"1\",\n                     grouping.var = \"Sample_Name\",\n                     only.pos = TRUE,\n                     min.diff.pct = 0.25,\n                     min.pct = 0.25,\n                     logfc.threshold = 0.25)\n\nhead(fcm)\n\n       naive_p_val naive_avg_log2FC naive_pct.1 naive_pct.2 naive_p_val_adj\nGNLY  0.000000e+00         4.823298       0.947       0.024    0.000000e+00\nGZMA 8.973490e-245         3.778985       0.835       0.041   1.736101e-240\nPRF1 1.103550e-125         2.671046       0.453       0.021   2.135038e-121\nNKG7 1.504853e-212         3.572770       0.823       0.060   2.911439e-208\nCCL5 9.363098e-161         3.319940       0.852       0.120   1.811479e-156\nCST7 5.390018e-149         3.014122       0.634       0.053   1.042807e-144\n     treated_p_val treated_avg_log2FC treated_pct.1 treated_pct.2\nGNLY  0.000000e+00           5.060457         0.961         0.055\nGZMA  0.000000e+00           3.813904         0.976         0.082\nPRF1  0.000000e+00           3.855625         0.907         0.068\nNKG7 8.396253e-261           3.398566         0.982         0.150\nCCL5 3.653151e-259           4.133251         0.892         0.108\nCST7 6.882951e-236           3.135928         0.759         0.068\n     treated_p_val_adj      max_pval minimump_p_val\nGNLY      0.000000e+00  0.000000e+00   0.000000e+00\nGZMA      0.000000e+00 8.973490e-245   0.000000e+00\nPRF1      0.000000e+00 1.103550e-125   0.000000e+00\nNKG7     1.624423e-256 1.504853e-212  1.679251e-260\nCCL5     7.067750e-255 9.363098e-161  7.306301e-259\nCST7     1.331645e-231 5.390018e-149  1.376590e-235\n\n\nWe also get a table with information on marker genes. The statistics are computed for each group (naïve vs. treated), and the last two columns are the combined p-value across the two groups.\n\ncondition_p_val P-value before multiple testing.\ncondition_avg_log2FC Log2 fold change on the average of gene expression between one cluster and the rest of the clusters combined.\ncondition_pct.1 Percentage of cells expressing the gene in one group.\ncondition_pct.2 Percentage of cells expressing the gene in another group.\ncondition_p_val_adj P-value with multiple testing correction.\n\n\n\n\n\n\n\nNote\n\n\n\nThe more significant the difference between pct.1 and pct.2, the higher the confidence for the marker gene. If pct.1 is 0.9 and pct.2 is 0.8, it is not as interesting as if pct.2 is 0.1.\nMarker genes express in a specific cell type. If pct.1 is low, such as 0.3, it is not as interesting as if it is 0.9.\n\n\nWe can visualize the marker gene expression by FeaturePlot and VlnPlot.\n\nFeaturePlot(object = integrate.filtered.rna, \n            features = c(\"GNLY\", \"GZMA\"),\n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE,\n            repel = TRUE)\n\n\n\n\n\nVlnPlot(object = integrate.filtered.rna, \n        features = c(\"GNLY\", \"GZMA\"),\n        stack = T, flip = T)"
  },
  {
    "objectID": "06_marker_identification.html#findmarkers",
    "href": "06_marker_identification.html#findmarkers",
    "title": "Chapter 6 Marker Identification",
    "section": "1.3 FindMarkers\n",
    "text": "1.3 FindMarkers\n\nWe can use the FindMarkers to determine the differentially expressed genes between two clusters.\n\nexample_findmarkers &lt;- FindMarkers(integrate.filtered.rna,\n                          assay = \"RNA\",\n                          ident.1 = 1,\n                          ident.2 = 2) %&gt;% \n  rownames_to_column(\"gene\")"
  },
  {
    "objectID": "06_marker_identification.html#reference-based",
    "href": "06_marker_identification.html#reference-based",
    "title": "Chapter 6 Marker Identification",
    "section": "2.1 Reference-based",
    "text": "2.1 Reference-based\nWe look at the publicly available dataset with annotation and build a reference set based on its information. Then we can “transfer” the annotation from the reference to the query. Seurat provides the interface to connect with Azimuth.\n\n\n\n\n\n\nNote\n\n\n\nBecause the annotation information is based on the reference set, the reference ideally is similar to the query. They may come from the same tissue, same organism, similar experimental procedure, etc.\n\n\n\nintegrate.filtered.rna &lt;- Azimuth::RunAzimuth(integrate.filtered.rna,\n                                              reference = \"pbmcref\",\n                                              verbose = F)\n\nAn AzimuthData object - reference version: 1.0.0 \nContains 3 meta.data field(s) to transfer.\n\n\nWe can look at the automatic annotation on UMAP.\n\np1 &lt;- DimPlot(integrate.filtered.rna, reduction = \"umap\", \n              group.by = \"predicted.celltype.l1\", \n              label = TRUE, label.size = 3 ,repel = TRUE) + \n  NoLegend()\n\np2 &lt;- DimPlot(integrate.filtered.rna, reduction = \"umap\", \n              group.by = \"integrated_snn_res.0.6\", \n              label = TRUE, label.size = 3 ,repel = TRUE) + \n  NoLegend()\n\np1|p2"
  },
  {
    "objectID": "06_marker_identification.html#marker-based",
    "href": "06_marker_identification.html#marker-based",
    "title": "Chapter 6 Marker Identification",
    "section": "2.1 Marker-based",
    "text": "2.1 Marker-based\nWe use ScType (https://github.com/IanevskiAleksandr/sc-type/blob/master/README.md) to annotate cell population based on known immune markers.\nScType also has an open source portal: https://sctype.app/.\n\n# load ScType R functions\nsource(\"https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R\"); source(\"https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R\")\n\n# get cell-type-specific gene sets from our in-built database (DB)\n# list downloaded from https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_short.xlsx\n# e.g. Immune system, Liver, Pancreas, Kidney, Eye, Brain\ngs_list &lt;-  gene_sets_prepare(\"data/ScTypeDB_short.xlsx\", \"Immune system\") \n\n# assign cell types\n# NOTE: scRNAseqData parameter should correspond to your input scRNA-seq matrix. \n# In case Seurat is used, it is either pbmc[[\"RNA\"]]@scale.data (default), pbmc[[\"SCT\"]]@scale.data, in case sctransform is used for normalization,\n# or pbmc[[\"integrated\"]]@scale.data, in case a joint analysis of multiple single-cell datasets is performed.\nes.max &lt;-  sctype_score(scRNAseqData = integrate.filtered.rna@assays[[\"integrated\"]]@scale.data, \n                        scaled = TRUE, \n                        gs = gs_list$gs_positive, \n                        gs2 = gs_list$gs_negative)\n\n# merge by cluster\ncL_resutls = do.call(\"rbind\", lapply(unique(integrate.filtered.rna@meta.data$integrated_snn_res.0.6), function(cl){\n    es.max.cl = sort(rowSums(es.max[ ,rownames(integrate.filtered.rna@meta.data[integrate.filtered.rna@meta.data$integrated_snn_res.0.6==cl, ])]), decreasing = !0)\n    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(integrate.filtered.rna@meta.data$integrate.filtered.rna==cl)), 10)\n}))\n\nsctype_scores = cL_resutls %&gt;% group_by(cluster) %&gt;% top_n(n = 1, wt = scores)  \n\n# set low-confident (low ScType score) clusters to \"unknown\"\nsctype_scores$type[as.numeric(as.character(sctype_scores$scores)) &lt; sctype_scores$ncells/4] = \"Unknown\"\n\n\nintegrate.filtered.rna@meta.data$customclassif = \"\"\n\nfor(j in unique(sctype_scores$cluster)){\n  cl_type = sctype_scores[sctype_scores$cluster==j,]; \n  integrate.filtered.rna@meta.data$customclassif[integrate.filtered.rna@meta.data$integrated_snn_res.0.6 == j] = as.character(cl_type$type[1])\n}\n\nDimPlot(integrate.filtered.rna, reduction = \"umap\", label = TRUE, repel = TRUE, group.by = 'customclassif')"
  },
  {
    "objectID": "07_differential_expression_analysis.html",
    "href": "07_differential_expression_analysis.html",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(ggpubr)"
  },
  {
    "objectID": "07_differential_expression_analysis.html#setup",
    "href": "07_differential_expression_analysis.html#setup",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.1 Setup",
    "text": "2.1 Setup\nLet’s assume we have three biological replicates in each condition (we make them up for the purpose of illustration).\n\n# make a fake group information\nintegrate.filtered.rna$group &lt;- sample(x = c('A', 'B', 'C'), size = ncol(integrate.filtered.rna), replace = TRUE)\n\n# pseudo-bulk by per condition per cell type\ncd4t.bulk &lt;- Seurat:::PseudobulkExpression(integrate.filtered.rna, \n                                        assays = \"RNA\",\n                                     pb.method = 'aggregate',\n                                     group.by = c('Sample_Name', 'predicted.celltype.l1', 'group'),\n                                     slot = \"counts\",\n                                     return.seurat = T)\n  \n# tidy up names\ncd4t.bulk$Sample_Name &lt;- cd4t.bulk %&gt;% colnames() %&gt;% \n  str_split(., pattern = \"_\") %&gt;% \n  lapply(., \"[\", 1) %&gt;% \n  unlist()\n\ncd4t.bulk$cellType &lt;- cd4t.bulk %&gt;% colnames() %&gt;% \n  str_split(., pattern = \"_\") %&gt;% \n  lapply(., \"[\", 2) %&gt;% \n  unlist\n\ncd4t.bulk$celltype.stim &lt;- paste(cd4t.bulk$Sample_Name, cd4t.bulk$cellType, sep = \"_\")\n\n# perform pseudobulk\nIdents(cd4t.bulk) &lt;- \"celltype.stim\"\n\ncd4t.bulk &lt;- FindMarkers(cd4t.bulk, \n                         ident.1 = \"treated_CD4 T\", \n                         ident.2 = \"naive_CD4 T\", \n                         test.use = \"DESeq2\")\n\n\n# compare the DE P-values between the single-cell level and the pseudobulk level results\ncd4t.bulk &lt;- cd4t.bulk %&gt;% \n  `colnames&lt;-`(paste0(names(cd4t.bulk), \".bulk\")) %&gt;% \n  mutate(gene = rownames(cd4t.bulk))\n\ncd4t.sc &lt;- cd4t.sc %&gt;% \n  `colnames&lt;-`(paste0(names(cd4t.sc), \".sc\")) %&gt;% \n  mutate(gene = rownames(cd4t.sc))\n\nmerge_dat &lt;- merge(cd4t.bulk, cd4t.sc, by = \"gene\") %&gt;% \n  arrange(p_val.bulk)\n\n# Number of genes that are marginally significant in both; marginally significant only in bulk; and marginally significant only in single-cell\ncommon &lt;- merge_dat$gene[which(merge_dat$p_val.bulk &lt; 0.05 & \n                                merge_dat$p_val.sc &lt; 0.05)]\nonly_sc &lt;- merge_dat$gene[which(merge_dat$p_val.bulk &gt; 0.05 & \n                                  merge_dat$p_val.sc &lt; 0.05)]\nonly_bulk &lt;- merge_dat$gene[which(merge_dat$p_val.bulk &lt; 0.05 & \n                                    merge_dat$p_val.sc &gt; 0.05)]\n\nThe majority of DEGs are shared in both pseudobulk and single-cell analysis."
  },
  {
    "objectID": "07_differential_expression_analysis.html#select-cell-groups",
    "href": "07_differential_expression_analysis.html#select-cell-groups",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.2 Select cell groups",
    "text": "2.2 Select cell groups\nLet’s take a look at the cell type annotation in UMAP.\n\n# # visualize cell types in UMAP\n# DimPlot(integrate.filtered.rna, \n#         reduction = \"umap\", \n#         group.by = \"predicted.celltype.l1\", \n#         label = TRUE, \n#         label.size = 3,\n#         repel = TRUE, \n#         split.by = \"Sample_Name\") + NoLegend()\n\nWe see some of the cell types have only a few cells.\nLet’s look at how many cells are in each cell type per dummy group.\n\n# Cell counts in per cell type per group\nFetchData(integrate.filtered.rna, \n                     vars = c(\"predicted.celltype.l1\", \"dummy_group\", \"Sample_Name\")) %&gt;%\n  dplyr::count(predicted.celltype.l1, Sample_Name, dummy_group) %&gt;%\n  tidyr::spread(predicted.celltype.l1, n)\n\n  Sample_Name dummy_group  B CD4 T CD8 T DC Mono  NK other other T\n1       naive     naive_1 22   309    65  3  127  68    19      14\n2       naive     naive_2 22   302    54  5  118  75    17       3\n3       naive     naive_3 24   311    58  4  113  93    12      12\n4     treated   treated_1 61   501    34 NA   36 137    15       1\n5     treated   treated_2 61   478    21 NA   35 123    21       2\n6     treated   treated_3 57   502    27 NA   36 137    22       3\n\n\nDendritic cells, other T cells, and the group of other don’t have sufficient cells per dummy group. For demonstration, we will not include these cell types for pseudo-bulk analysis. We will focus on “CD4 T”, “Mono”, and “NK”.\n\nsubset.rna &lt;- subset(integrate.filtered.rna, \n                     subset = predicted.celltype.l1 %in% \n                       c(\"CD4 T\", \"Mono\", \"NK\"))"
  },
  {
    "objectID": "07_differential_expression_analysis.html#setup-singlecellexperiment",
    "href": "07_differential_expression_analysis.html#setup-singlecellexperiment",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.3 Setup SingleCellExperiment\n",
    "text": "2.3 Setup SingleCellExperiment\n\nThe muscat package requires the input object as the SingleCellExperiment object. We first transform the Seurat object into SCE object.\nmuscat requires three pieces of meta data information: sample_id sample IDs, corresponds to dummy_group in the meta.data cluster_id cell types, corresponds to predicted.celltype.l1 in the meta.data group_id sample groups, corresponds to sample in the meta.data\nLet’s first tidy up the meta data.\n\nsubset.rna@meta.data &lt;- subset.rna@meta.data %&gt;% \n  dplyr::select(Sample_Name, predicted.celltype.l1, dummy_group) %&gt;% \n  `colnames&lt;-`(c(\"group_id\", \"cluster_id\", \"sample_id\"))\n\nSeurat has a convenient function to convert Seurat object into SingleCellExperiment object, as.SingleCellExperiment.\n\n# construct experiment_info\nexperiment_info &lt;- subset.rna@meta.data %&gt;% \n  group_by(sample_id, group_id) %&gt;% \n  dplyr::summarise(n_cells = length(group_id))\n\n# convert seurat object into SingleCellExperiment object\nsubset.rna &lt;- as.SingleCellExperiment(subset.rna, assay = \"RNA\")\n\nThe SCE object doesn’t contain the experiment_info. We add the information into the SCE object.\n\n# assign experiment info into the created SingleCellExperiment\nsubset.rna@metadata[[\"experiment_info\"]] &lt;- experiment_info"
  },
  {
    "objectID": "07_differential_expression_analysis.html#aggregation",
    "href": "07_differential_expression_analysis.html#aggregation",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.4 Aggregation",
    "text": "2.4 Aggregation\nWe first aggregate measurements for each sample (in each cell type) to obtain pseudobulk data.\n\n# aggregate counts per cell type per dummy group\nsubset.pb &lt;- aggregateData(subset.rna,\n                           assay = \"counts\", \n                           fun = \"sum\",\n                           by = c(\"cluster_id\", \"sample_id\"))\n\nWe can look at how the pseudobulk samples cluster on the MDS plot.\n\nmuscat::pbMDS(subset.pb)\n\n\n\n\nNext, we can run DS analysis by specifying method as DESeq2.\n\n# change group_id into a factor\nsubset.pb$group_id &lt;- subset.pb$group_id %&gt;% factor(levels = c(\"treated\", \"naive\"))\n\n# run DS analysis with DESeq2\nres &lt;- pbDS(subset.pb, method = \"DESeq2\", verbose = F)\n\nThe result is stored in the table slot of res.\nWe will focus on the deferentially expressed genes in CD4 T cells.\n\ncd4t &lt;- res$table$naive$`CD4 T`\n\n# Filter the results with p_adj.loc &lt; 0.05, abs(logFC) &gt; 1\ncd4t.sig &lt;- dplyr::filter(cd4t, p_adj.loc &lt; 0.05, abs(logFC) &gt; 1) %&gt;% \n  arrange(p_adj.loc)\n\nhead(cd4t.sig)\n\n      gene cluster_id baseMean     logFC      lfcSE      stat p_val p_adj.loc\n1    ACTG1      CD4 T 2668.781 -2.659041 0.06523691 -40.75976     0         0\n2     ENO1      CD4 T 1551.952 -3.948824 0.10421979 -37.88939     0         0\n3 HSP90AA1      CD4 T 3313.136 -3.417375 0.07281262 -46.93383     0         0\n4 HSP90AB1      CD4 T 3142.790 -3.156739 0.06430620 -49.08919     0         0\n5     IL7R      CD4 T 1673.366  3.774151 0.05618277  67.17631     0         0\n6   MALAT1      CD4 T 2329.629  2.337009 0.05494380  42.53454     0         0\n  p_adj.glb contrast\n1         0    naive\n2         0    naive\n3         0    naive\n4         0    naive\n5         0    naive\n6         0    naive\n\n\n\np_adj.loc is produced by correcting for multiple testing across all genes tested within a cluster.\np_adj.glb is produced by correcting for multiple testing across all genes tested in all clusters.\n\nWe can plot the DEGs from CD4+ T cells in a heatmap.\n\n# scale the RNA data\nintegrate.filtered.rna &lt;- ScaleData(integrate.filtered.rna, features = rownames(integrate.filtered.rna), assay = \"RNA\")\n\n# plot heatmap\nintegrate.filtered.rna %&gt;%\n  subset(., subset = predicted.celltype.l1 == \"CD4 T\") %&gt;% \n  DoHeatmap(features = cd4t.sig$gene[1:40])"
  },
  {
    "objectID": "08_enrichment_analysis.html",
    "href": "08_enrichment_analysis.html",
    "title": "Chapter 8 Enrichment Analysis",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(org.Hs.eg.db)\nlibrary(clusterProfiler)\nlibrary(AnnotationDbi)\nlibrary(enrichplot)\nlibrary(biomaRt)\n\nLoad RData\nLoad the RData which contains all files from the previous chapter.\n\nload(\"data/intermediate_data/chapter7.RData\")\n\nOftentimes, enrichment analysis takes the differentially expressed genes and looks at which gene ontology (GO) terms are enriched.\nGO terms defines concepts/classes used to describe gene function and relationships between these concepts. clusterProfiler is an R package implementing many methods to analyze and visualize functional profiles from a group of features. It classifies functions in three aspects.\n\nMF: Molecular Function: molecular activities of gene products.\nCC: Cellular Component: where gene products are active.\nBP: Biological Process: pathways and larger processes made up of the activities of multiple gene products.\n\nThis chapter uses the differentially expressed genes in CD4+ T cells from last chapter as an example.\n1. Get Entrez ID\nclusterProfiler prefers the input of Entrez ID. We use biomaRt package to convert the gene symbol into Entrez ID.\n\n\n\n\n\n\nNote\n\n\n\nbiomaRt is handy to get information about features. You can use it to get gene symbols, genomic coordinates, transcript sequences, etc. You can explore what data is stored in biomaRt with listAttributes.\n\n\nThe differentially expressed genes in CD4+ T cells between naïve and treated PBMCs are stored in the matrix cd4t. The gene symbol in this list can be converted into Entrez ID by biomaRt.\nFirstly, connect to the Ensembl database and specify we want to retrieve information from the dataset of Homo Sapien.\n\nmart &lt;- useMart(biomart = \"ensembl\", dataset = \"hsapiens_gene_ensembl\")\n\n\nbiomart BioMart database connect to. Here, we want to connect to ensembl database.\ndataset Dataset to use. Here specify hsapiens_gene_ensembl.\n\nNext, we can give a list of gene symbols and retrieve the Entrez ID through getBM.\n\nresults &lt;- getBM(attributes = c(\"entrezgene_id\", \"external_gene_name\"),\n                 filters = \"external_gene_name\", \n                 values = cd4t.bulk$gene,\n                 mart = mart)\n\n\nattributes Attributes to retrieve. We want to have the gene symbols and Entrez ID in the results.\nfilters Which filter to use to filter the dataset.\nvalues A list of features as a query.\nmart Object of class Mart, created with the useMart function.\n\nA table of two columns is created and stored in the matrix of results.\n\nresults %&gt;% head\n\n  entrezgene_id external_gene_name\n1         81532               MOB2\n2         79602            ADIPOR2\n3        196513              DCP1B\n4         55449          DHRS4-AS1\n5         80344             DCAF11\n6         51016               EMC9\n\n\nNot every gene has the Entrez ID. We keep only genes that have a matched Entrez ID.\n\ncd4t.bulk &lt;- left_join(cd4t.bulk, results, by = c(\"gene\" = \"external_gene_name\")) %&gt;% \n  filter(!is.na(entrezgene_id)) %&gt;% \n  filter(!is.na(p_val_adj.bulk))\n\n2. GO over-representation analysis\nOver Representation Analysis (ORA) is a widely used approach to determine whether known biological functions or processes are over-represented (= enriched) in an experimentally-derived gene list, e.g. a list of differentially expressed genes (DEGs).\nWe use the enrichGO to get the enriched GO terms in the list of DEGs.\n\ncd4t.bulk.sig &lt;- dplyr::filter(cd4t.bulk, p_val_adj.bulk &lt; 0.01, abs(avg_log2FC.bulk) &gt; 1)\n\n# get the enriched GO terms\nego &lt;- enrichGO(gene = cd4t.bulk.sig$entrezgene_id,\n                keyType = \"ENTREZID\",\n                OrgDb = org.Hs.eg.db,\n                ont = \"BP\",\n                pAdjustMethod = \"BH\",\n                pvalueCutoff = 0.01,\n                qvalueCutoff = 0.05,\n                readable = TRUE)\n\n\ngene A list of Entrez gene id.\nkeyType The keytype of input gene.\nOrgDb The database with detailed information about the species.\norg.Hs.eg.db Specify the database of Homo Sapien.\nont One of “BP” (biological process), “MF” (molecular function), and “CC” (cellular component) subontologies, or “ALL” for all three.\npAdjustMethod Multiple testing method for p-value.\npvalueCutoff Adjusted pvalue cutoff on enrichment tests to report.\nqvalueCutoff Tge qvalue cutoff on enrichment tests to report as significant.\nreadable Whether mapping gene ID to gene Name.\n\nLet’s convert the ego object into a data frame and visualize the results in a bar plot.\n\nego.table &lt;- as.data.frame(ego)\n\n\nGeneRatio The gene counts from the input list found in the gene set of a GO term / gene counts of input list.\nBgRatio The gene counts of a geneset / size of all of the unique genes in the collection of genesets.\n\n\nfilter(ego, Description %in% grep(\"T cell\", ego.table$Description, ignore.case = T, value = T)) %&gt;% \nbarplot(showCategory = 18)\n\n\n\n\n3. Gene set enrichment analysis - Optional\nAll genes can be used as input of gene set enrichment analysis (GSEA). We first rank the genes based on stat.\n\n# order genes\ncd4t.bulk &lt;- cd4t.bulk[order(-cd4t.bulk$avg_log2FC.bulk), ]\n\ngene_list &lt;- cd4t.bulk$avg_log2FC.bulk\nnames(gene_list) &lt;- cd4t.bulk$entrezgene_id\n\nWe use gseGO to perform GSEA and convert the results into a dataframe.\n\n# perform GSEA\ngse &lt;- gseGO(gene_list,\n             keyType = \"ENTREZID\",\n             ont = \"BP\",\n             OrgDb = \"org.Hs.eg.db\")\n\n# convert the results into a dataframe\ngse.table &lt;- as.data.frame(gse) %&gt;% \n  mutate(geneSetID = 1:dim(.)[1])\n\nenrichmentScore The enrichment score (ES) represents the degree to which a set S is over-represented at the top or bottom of the ranked list L.\nWe can look at the enrichment of some GO terms in GSEA plot.\n\ngseaplot2(gse, geneSetID = c(509, 526))\n\n\n\n\nWe have significant enriched term in the unregulated genes. Along the x axis is the ranked genes. Each of the vertical line is one of those genes that are found in this gene set. Along the running line, you can see a lot of genes running together and it falls out when the gene becomes more sparse in the list.\n4. Save\nSave the files into RData for documentation.\n\n# save.image(file = \"data/intermediate_data/chapter8.RData\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "How to use the materials?\nThis repository contains the teaching materials for the Single Cell Boot Camp - Analyzing scRNA-seq with R.\n\n\n\n\n\n\nImportant\n\n\n\nStudents who go through the teaching materials and run the code on their local desktops will have a much better learning outcome.\nWe are NOT going to cover the R programming and SOLELY focusing on the analysis workflow, this is particularly important for students who are not familiar with R. So, please do block some time and try to digest the materials before attending the Boot Camp.\nIf you are familiar with R, you can skip the Precourse Preparation.\n\n\n\n\nDescription\nThe Single Cell Boot Camp: Analysis of scRNA-seq with R is to provide an overview of the analysis of single-cell RNA-seq using R. It is designed for early-stage researchers who want to adopt single-cell analysis in their toolbox. The workshop consists of theory in presentation and application in hands-on practice.\nThe workshop starts with a fast-paced training session on the common workflow of single-cell RNA-seq analysis, then continues with sessions on the common workflow of scRNA-seq using bioinformatics packages like Seurat.\n\n\nPrerequisites\nEach participant are expected to have:\n1. An introductory background in statistics, specifically in the below concepts: Median, log2 fold change, p-value, adjusted p-value, variance, PCA.\n2. Basic familiarity with R and tidyr package, specifically in the below functions: %&gt;% (pipe), filter, mutate, pivot_longer, pivot_wider, map, pmap, select, left_join.\nIf you would like to learn on your own with publicly available resources:\nChapter 1 - 4 from MordernDive.\n\nIf you would like to participate in an instructor-led R course:\nR for Biologist from Edinburgh Genomics. For details, please contact Edinburgh Genomics.\n\n\nExpected outcome\nBy the end of the workshop, participants will be familiar with the following topics: Common workflow of single cell analysis (pre-processing, quality control, filtering, normalization, Clustering, Cell type annotation).\n\n\nReference\nThe building of materials for the course references and relies on many excellent and well written public avaialbe materials.\n\nSeurat https://satijalab.org/seurat/\nSingle Cell Best Practices: https://www.sc-best-practices.org/preamble.html\nOrchestrating Single-Cell Analysis with Bioconductor: https://bioconductor.org/books/release/OSCA/\nMary Piper, Meeta Mistry, Jihe Liu, William Gammerdinger, & Radhika Khetani. (2022, January 6). hbctraining/scRNA-seq_online: scRNA-seq Lessons from HCBC (first release). Zenodo. https://doi.org/10.5281/zenodo.5826256\n\n\n\nDisclaimer\nRecommendations given by representatives of BD in the context of the creation and setup of customer-specific applications and assays, the composition of antibody panels and suggestions for data analysis are provided in a diligent manner. However, the Customer acknowledges that (i) such recommendations should not be treated as a substitute for the Customer’s own examination, (ii) BD does not make any promises nor guarantees that recommendations are accurate and complete and will meet the Customer’s present or future needs or will produce positive or specific results and (iii) Customer remains solely responsible for validating and deciding on any such recommendations.\nBD therefore accepts no liability whatsoever in connection with any such recommendation and/or any results generated on the basis of such recommendations and, to the fullest extent permitted by law, expressly disclaims any and all warranties and any liability in this respect. In particular, the Customer assumes sole responsibility for the validation, use, selection, and suitability of the recommendations for its needs and objectives.\n\n\nLicense\nSee the LICENSE file for license rights and limitations (MIT)."
  },
  {
    "objectID": "precourse_preparation_R.html#what-is-a-data-frame",
    "href": "precourse_preparation_R.html#what-is-a-data-frame",
    "title": "Precourse Preparation - R",
    "section": "1.1 What is a data frame?",
    "text": "1.1 What is a data frame?\nData frame is a data structure in R that stores values of any type. You can think of it as a table with columns and rows storing the data as in the below example.\n\nCredit: https://www.geeksforgeeks.org/r-data-frames/\nOften in data science language, the columns are variables, the rows are observations and each entry in a table is a value.\nSome of the most common examples of input files that can be loaded into R as data frames are spreadsheets, TSVs, or CSVs files. TSV and CSV stands for tab-separated or coma-separated values.\nAnother way to view data frame is as a list of vectors of the same length. The vector can be defined as a type of data structure that contains elements of the same type. Below you can find example on how to create the table presented in the beyond figer from vectors.\n\n## Define vectors which will be used to create the data frame\n\n## Vector of names\nName &lt;- c(\"Avrey Bradley\",\"John Holland\",\"Jonas Jerebko\",\"Jordan Midkey\",\"Terry Rozier\",\"Jared Sullinger\",\"Evan Turner\")\n\n## Vector of team's names\nTeam &lt;- c(\"Boston Celtics\", \"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\")\n\n## Vector of values\nNumber &lt;- c(0.0,30.0,8.0,NaN,12.0,7.0,11.0)\n\n## Vector of positions\nPosition &lt;- c(\"PG\",\"SG\",\"PF\",\"PF\",\"PG\",\"C\",\"SG\")\n\n## Vector of age\nAge &lt;- c(25.0,27.0,29.0,21.0,22.0,NaN,27.0)\n\n## Create a data frame from vectors\ndata.frame(Name,Team,Number,Position,Age)\n\n             Name           Team Number Position Age\n1   Avrey Bradley Boston Celtics      0       PG  25\n2    John Holland Boston Celtics     30       SG  27\n3   Jonas Jerebko Boston Celtics      8       PF  29\n4   Jordan Midkey Boston Celtics    NaN       PF  21\n5    Terry Rozier Boston Celtics     12       PG  22\n6 Jared Sullinger Boston Celtics      7        C NaN\n7     Evan Turner Boston Celtics     11       SG  27"
  },
  {
    "objectID": "precourse_preparation_theory.html#bd-rhapsody-single-cell-system",
    "href": "precourse_preparation_theory.html#bd-rhapsody-single-cell-system",
    "title": "Precourse Preparation - Theory",
    "section": "2.1 BD Rhapsody™ Single Cell System",
    "text": "2.1 BD Rhapsody™ Single Cell System\n\nThe BD Rhapsody™ Single Cell System enables simultaneous measurement of multiple parameters in thousands of individual cells. By combining available assays, researchers can generate robust and intricate datasets to unlock powerful insights.\nGene Expression (scRNAseq): The primary purpose of scRNAseq is to measure the gene expression in individual cells. This allows to understand which genes are active or inactive and to identify different cell types based on their gene expression profiles.\nAntibody-Based Protein Analysis (AbSeq): You can use antibodies conjugated with unique barcodes to measure protein expression alongside with gene expression in individual cells.\nSample multiplexing with antibody-based techniques (SMK): Sample multiplexing kit (SMK) uses generic antibody conjugated with unique barcodes to label cells from different samples. This enables pooling of multiple samples on one cartridge.\nImmune Repertoire Profiling (Full length V(D)J TCR/BCR): Full length V(D)J assay profiles the diversity of T cell and/or B cell receptor repertoires. This is valuable for studying the immune response and identifying antigen-specific cells.\nAntigen-Specific T-cell Analysis (DCode): Immudex’s DCode technology enables the profiling of T cells that recognize specific antigens such as viral epitopes or tumor-related antigens. This expands the offering of immune profiling, aiding vaccine development and immunotherapy research.\nFrom gene expression profiling to antibody-based protein analysis, all assays can be combined or performed standalone to explore cellular functions and molecular dynamics in single cell resolution."
  },
  {
    "objectID": "precourse_preparation_theory.html#overview-of-single-cell-data-analysis",
    "href": "precourse_preparation_theory.html#overview-of-single-cell-data-analysis",
    "title": "Precourse Preparation - Theory",
    "section": "2.2 Overview of Single Cell Data Analysis",
    "text": "2.2 Overview of Single Cell Data Analysis\nIn general, the analysis of single cell data can be split into two parts.\nThe primary analysis transforms raw data (usually in fastq.gz format) into an expression matrix, where each row represents a gene, each column represents a cell, and each entry in the matrix contains the molecule counts of a particular feature (gene or protein) in a cell. Secondary analysis focuses on extracting meaningful biological insights from the expression matrix."
  },
  {
    "objectID": "precourse_preparation_theory.html#primary-analysis---from-sequencing-data-to-expression-matrix",
    "href": "precourse_preparation_theory.html#primary-analysis---from-sequencing-data-to-expression-matrix",
    "title": "Precourse Preparation - Theory",
    "section": "2.3 Primary analysis - From Sequencing Data to Expression Matrix",
    "text": "2.3 Primary analysis - From Sequencing Data to Expression Matrix\nAfter sequencing, one will receive raw sequecning data. The raw sequencing data is usually in fastq.gz format. You may also see fq.gz.\nThe raw sequencing data is usually handled by the software, BD Rhapsody™ Primary Analysis Pipeline, to enables fast and easy data processing. In this chapter, we will cover key features of the pipeline and explain key concepts necessary to understand prior working with single cell data.\n\n2.3.1 BD Rhapsody™ Sequencing Analysis Pipeline\nThe BD Rhapsody™ Sequencing Analysis Pipeline contains a series of computational steps to process and extract meaningful information from the raw sequencing data generated by the BD Rhapsody™ Sinlge Cell System.\nThe goal of the primary analysis is to transform text-based genomic data into numerical data, and we achieve this through a series of steps in the pipeline. The steps of the pipeline are listed in simplified graphics below.\n\nThe main steps include decoding the unique barcodes and feature molecules associated with individual cells. Oftentimes, scRNAseq relies on unique molecular identifiers (UMIs) to quantify feature expression.\n\n\n2.3.2 Quantify feature expression with UMIs\nUnique molecular identifiers (UMIs) are used to quantify featuer molecules in a cell. Here’s how it works:\n\nBead structure: UMIs are small, unique sequences of nucleotides that are added to the capture sequence of beads. Each bead contains tens of thousands of unique UMIs followed by the polyA capture sequence. Each UMI is specific to the molecule it attaches to and becomes its unique tag.\n\nThousands RNA molecule copies are created by PCR during library preparation.\nThe RNA molecule copies, including the attached UMIs, are then sequenced.\n\nUMIs can help to differentiate PCR copies and we can quantify correctly the feature expression. After sequencing, we count the number of unique UMIs rather than the number of reads of a transcript as the feature expression. UMIs help to:\n\nRemove PCR copies: Because UMIs are unique to each original RNA molecule, any duplicates (multiple copies of the same RNA molecule) with the same UMI are likely the result of PCR amplification rather than a true molecule.\nCount unique molecules: By looking at the UMIs, one can count how many unique RNA molecules are originally present in the cell.\nQuantify gene expression: By counting the unique UMIs associated with each gene, one can measure the expression level of that gene in a cell. Genes with more UMIs are more active, while genes with fewer UMIs are less active.\n\nIn summary, UMIs are used to distinguish real feature molecules from PCR copies by providing a unique identifier for each original molecule.\n\n\n2.3.3 Output Files from the Primary Pipeline\nThe primary pipeline produces many output files. Below you can find a summary of output files relating to different assays.\n\nThe output files from the primary analysis are the input of the secondary analysis. In the course, we will work with demo data that includes WTA, AbSeq and SMK. You will get to know how to load the expression matrix (in MEX format), how to perform quality control and other steps that are commonly included in single cell analysis in Chapter 1 - 9.\n\n\n\n\n\n\nImportant\n\n\n\nThe course will ONLY cover the secondary analysis."
  },
  {
    "objectID": "02_quality_control.html#combine-metrics-to-come-up-the-filtering-threshold",
    "href": "02_quality_control.html#combine-metrics-to-come-up-the-filtering-threshold",
    "title": "Chapter 2 Quality Control",
    "section": "3.4 Combine metrics to come up the filtering threshold",
    "text": "3.4 Combine metrics to come up the filtering threshold\nWe can combine the metrics to decide the filtering threshold.\n\nrna@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500, colour = \"red\") +\n  geom_hline(yintercept = 300, colour = \"red\") +\n  facet_wrap(~Sample_Name) +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n\n\n\nThe data is fitted with a linear regression line. We expect when UMI counts increase, gene counts also increase.\nUpper right quadrant: Cells with high gene counts and UMI counts. We generally consider these cells to be good-quality cells.\nBottom right quadrant: Cells with low gene counts and UMI counts. We generally consider these cells are low-quality cells.\nDarker cells: Cells with high mitochondrial percentage. Many of these cells have low gene counts at the same time. This may indicate damaged/dying cells whose cytoplasmic mRNA leaks out through a broken membrane, so only mRNA located in the mitochondria is still conserved."
  },
  {
    "objectID": "03_normalization_exercise.html",
    "href": "03_normalization_exercise.html",
    "title": "Chapter 3 Normalization and PCA",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\n\nLoad RData\nLoad the RData which contains all files from previous chapter.\n\nload(\"data/intermediate_data/chapter2.RData\")\n\n1. Normalization\nWe will perform normalization on UMI counts using LogNormalize.\n\nfiltered.rna &lt;- NormalizeData(filtered.rna, \n                              normalization.method = \"LogNormalize\")\n\n\n\n\n\n\n\n@QUESTION1\n\n\n\nWhere are the normalized counts stored? And how to extract the normalized counts?\n\n\n\n\n\n\nTIP\n\n\n\nClick on the Seurat object filtered.rna in the top right window. What’s the difference between counts and data?\n\n\n\n\n# extract normalized counts\nnorm_counts &lt;- Seurat::GetAssayData(filtered.rna, slot = \"data\")\n\n\n\n2. Scaling and find the most variable genes\n\n# Identify the most variable genes\nfiltered.rna &lt;- FindVariableFeatures(filtered.rna,\n                                     selection.method = \"vst\",\n                                     nfeatures = 2000, \n                                     verbose = F)\n\n# Identify the 10 most highly variable genes\ntop10 &lt;- head(Seurat::VariableFeatures(filtered.rna), 10)\n\n# plot them in a nicely labeled scatterplot\nvf_plot &lt;- Seurat::VariableFeaturePlot(filtered.rna)\nSeurat::LabelPoints(plot = vf_plot,\n            points = top10, repel = TRUE)\n\n\n\n\nNext, we apply scaling, a linear transformation that is a standard pre-processing step prior to dimensional reduction techniques like PCA.\n\n# Scale the data\nfiltered.rna &lt;- ScaleData(filtered.rna, \n                          features = rownames(filtered.rna))\n\n\n\n\n\n\n\n@QUESTION2\n\n\n\nWhere are the scaled data stored?\n\n\n\n\n\n\nTIP\n\n\n\nClick on the Seurat object filtered.rna in the top right window."
  },
  {
    "objectID": "01_data_import_exercise.html",
    "href": "01_data_import_exercise.html",
    "title": "Chapter 1 Data Import",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\n\n1. Loading single cell data\n\nexpMat &lt;- Read10X(\"data/raw_data/WTA-AB-SMK-v2-0_DBEC_MolsPerCell_MEX/\",\n                  gene.column = 2,\n                  cell.column = 1,\n                  unique.features = TRUE)\n\nClick on the expMat on the right.\n\nA window will pop up and you should be able to see the structure of expMat.\n\nWe will first focus on Gene Expression.\n\nexpMat$`Gene Expression`[1:5, 1:5]\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n         74 391 440 1222 2690\nA1BG      .   .   .    .    .\nA1BG-AS1  .   .   .    .    .\nA1CF      .   .   .    .    .\nA2M       .   .   .    .    .\nA2M-AS1   .   .   .    .    .\n\n\n\n\n\n\n\n\n@QUESTION1\n\n\n\nWhat are the dots “.” in the matrix?\n\n\n2. Create a Seurat object to store Gene Expression\n\nrna &lt;- Seurat::CreateSeuratObject(counts = expMat$`Gene Expression`, \n                                min.cells = 1, \n                                min.features = 100, \n                                assay = \"RNA\")\n\n\n\n\n\n\n\n@QUESTION2\n\n\n\nHow many genes and cells are stored in the Seurat object rna?\n\n\n\n\n\n\nTip\n\n\n\nClick on the Seurat object rna in the top right window. What is 28127 x 4948?\n\n\n\n\n\n3. Add sample tag information into meta.data\n\n\n# load sample tag info into R\nsmk &lt;- fread(file = \"data/raw_data/WTA-AB-SMK-v2-0_Sample_Tag_Calls.csv\", \n                     sep = \",\", \n                     header=TRUE) %&gt;% \n  data.frame(row.names = 1)\n\n\n# add sample tag info into seurat object\nrna &lt;- AddMetaData(object = rna, metadata = smk)\n\n\n\n\n\n\n\n@QUESTION3\n\n\n\nHow do we know the sample tag information is added into the Seurat object rna?\n\n\n\n\n\n\nTip\n\n\n\nClick on rna in the top right window, then click on meta.data. What do you see?"
  },
  {
    "objectID": "supplementary_targeted_analysis.html",
    "href": "supplementary_targeted_analysis.html",
    "title": "Supplementary: Targeted assays",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(clustree)\nlibrary(HGNChelper)\nlibrary(openxlsx)\nThe BD Rhapsody™ Targeted mRNA Kits profile a subset of genes, from dozens to hundreds. The below tutorial showcases an analysis workflow for targeted assays."
  },
  {
    "objectID": "supplementary_targeted_analysis.html#data-import",
    "href": "supplementary_targeted_analysis.html#data-import",
    "title": "Supplementary: Data import and quality control for targeted assays",
    "section": "2.1 Data import",
    "text": "2.1 Data import\n\n\n\n\n\n\nNote\n\n\n\nWhen creating the Seurat object, it is important to specify min.cells = 1 and min.features = 1.\n\n\n\nexpMat &lt;- Read10X(\"data/raw_data/16HIRP_DBEC_MolsPerCell_MEX//\",\n                  gene.column = 2,\n                  cell.column = 1,\n                  unique.features = TRUE)\n\nrna &lt;- Seurat::CreateSeuratObject(counts = expMat, \n                                min.cells = 1, \n                                min.features = 1, \n                                assay = \"RNA\")"
  },
  {
    "objectID": "supplementary_targeted_analysis.html#ncount_rna-umi-counts-per-cell",
    "href": "supplementary_targeted_analysis.html#ncount_rna-umi-counts-per-cell",
    "title": "Supplementary: Targeted assays",
    "section": "2.1 nCount_RNA UMI counts per cell",
    "text": "2.1 nCount_RNA UMI counts per cell\n\nseuratObj@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  ggtitle(\"nCount_RNA\")"
  },
  {
    "objectID": "supplementary_targeted_analysis.html#nfeature_rna-gene-counts-per-cell",
    "href": "supplementary_targeted_analysis.html#nfeature_rna-gene-counts-per-cell",
    "title": "Supplementary: Targeted assays",
    "section": "2.2 nFeature_RNA Gene counts per cell",
    "text": "2.2 nFeature_RNA Gene counts per cell\n\nseuratObj@meta.data %&gt;% \n  ggplot(aes(x=nFeature_RNA)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  ggtitle(\"nFeature_RNA\")"
  },
  {
    "objectID": "supplementary_targeted_analysis.html#combine-metrics-to-come-up-the-filtering-threshold",
    "href": "supplementary_targeted_analysis.html#combine-metrics-to-come-up-the-filtering-threshold",
    "title": "Supplementary: Targeted assays",
    "section": "2.3 Combine metrics to come up the filtering threshold",
    "text": "2.3 Combine metrics to come up the filtering threshold\nOne can combine the two metrics to jointly decide the filtering threshold.\n\nseuratObj@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 90, colour = \"red\") +\n  geom_vline(xintercept = 3000, colour = \"red\") +\n  geom_hline(yintercept = 30, colour = \"red\") +\n  geom_hline(yintercept = 200, colour = \"red\") +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n\n\n\nMajority of cells have between 30 - 200 genes. The cells on the right with high nCount_RNA are likely multiplets. We will filter the cells with the identified threshold."
  },
  {
    "objectID": "supplementary_targeted_analysis.html#filter-on-cells",
    "href": "supplementary_targeted_analysis.html#filter-on-cells",
    "title": "Supplementary: Targeted assays",
    "section": "3.1 Filter on cells",
    "text": "3.1 Filter on cells\nBased on the quality metrics, we use the following thresholds to filter out low quality cells:\nnCount_RNA &gt; 90\nnCount_RNA &lt; 3000\nnFeature_RNA &gt; 30\nnFeature_RNA &lt; 200\n\nfiltered &lt;- subset(x = seuratObj, \n                   subset = (nCount_RNA &gt; 90) & \n                         (nCount_RNA &lt; 3000) &\n                         (nFeature_RNA &gt; 30) &\n                         (nFeature_RNA &lt; 200))"
  },
  {
    "objectID": "supplementary_targeted_analysis.html#filter-on-genes",
    "href": "supplementary_targeted_analysis.html#filter-on-genes",
    "title": "Supplementary: Data import and quality control for targeted assays",
    "section": "3.2 Filter on genes",
    "text": "3.2 Filter on genes\nWe keep only genes that are expressed in at least one cells. GetAssayData is a convenient command to get information from the Seurat object. We use GetAssayData to extract the UMI counts.\n\n# Extract counts\ncounts &lt;- GetAssayData(object = filtered.rna, slot = \"counts\")\n\n# Output a logical matrix specifying for each gene whether or not \n# there are more than zero counts per cell\nnonzero &lt;- counts &gt; 0\n\n# Sum all TRUE values and return TRUE \n# if equal or more than 5 TRUE values per gene\nkeep_genes &lt;- Matrix::rowSums(nonzero) &gt;= 1\n\n# Only keep those genes\nfiltered_counts &lt;- counts[keep_genes, ]\n\n# Create Seurat object\nfiltered.rna &lt;- CreateSeuratObject(filtered_counts, meta.data = filtered.rna@meta.data)"
  },
  {
    "objectID": "supplementary_targeted_analysis.html#re-assess-metrics",
    "href": "supplementary_targeted_analysis.html#re-assess-metrics",
    "title": "Supplementary: Targeted assays",
    "section": "3.2 Re-assess metrics",
    "text": "3.2 Re-assess metrics\nAfter filtering, we look back to the metrics to ensure the filtered data matches expectations and is suitable for downstream analysis. We plot QC metrics using the filtered data.\n\nfiltered@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 90, colour = \"black\") +\n  geom_vline(xintercept = 3000, colour = \"black\") +\n  geom_hline(yintercept = 25, colour = \"red\") +\n  geom_hline(yintercept = 200, colour = \"red\") +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n\n\n\nThe feature number and cell number before filtering:\n\nseuratObj\n\nAn object of class Seurat \n383 features across 16771 samples within 1 assay \nActive assay: RNA (383 features, 0 variable features)\n 2 layers present: counts, data\n 1 dimensional reduction calculated: tsne\n\n\nThe feature number and cell number after filtering:\n\nfiltered\n\nAn object of class Seurat \n383 features across 16680 samples within 1 assay \nActive assay: RNA (383 features, 0 variable features)\n 2 layers present: counts, data\n 1 dimensional reduction calculated: tsne"
  },
  {
    "objectID": "07_differential_expression_analysis.html#de-analysis-across-conditions",
    "href": "07_differential_expression_analysis.html#de-analysis-across-conditions",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "1.1 DE analysis across conditions",
    "text": "1.1 DE analysis across conditions\nIn the last chapter, we used FindMarkers to find the marker genes between two clusters by specifying ident.1 and ident.2.\nChanging the ident.1 and ident.2 arguments, we can perform differential expression analysis between two groups.\nFor instance, we want to find genes deferentially expressed between naïve and treated PBMC.\n\n# assign the sample identity that we want to work on different sample groups\nIdents(integrate.filtered.rna) &lt;- \"Sample_Name\"\n\n# change default assay to \"RNA\"\nDefaultAssay(integrate.filtered.rna) &lt;- \"RNA\"\n\n# Find genes differentially expressed\ntreated_naive &lt;- \n  FindMarkers(integrate.filtered.rna, ident.1 = \"treated\", ident.2 = \"naive\") %&gt;% \n  rownames_to_column(\"gene\") %&gt;% \n  dplyr::filter(p_val_adj &lt; 0.05)\n\nWe can compare the gene expression between two groups by specifying ident.1 and ident.2.\n\nhead(treated_naive)\n\n   gene         p_val avg_log2FC pct.1 pct.2     p_val_adj\n1  GBP1  0.000000e+00   2.843551 0.688 0.072  0.000000e+00\n2 STAT1  0.000000e+00   2.745853 0.855 0.165  0.000000e+00\n3  TAP1 1.208876e-296   1.971221 0.758 0.178 2.338813e-292\n4  GBP4 7.757109e-268   2.250739 0.642 0.087 1.500768e-263\n5  XAF1 4.844772e-251   2.252528 0.639 0.114 9.373181e-247\n6  GBP5 3.297043e-247   2.334895 0.625 0.094 6.378789e-243\n\n\n\ngene Gene symbol.\np_val P-value without multiple testing.\navg_log2FC log2 fold-change of the average expression between the two groups."
  },
  {
    "objectID": "07_differential_expression_analysis.html#perform-de-analysis-within-the-same-cell-type-across-conditions",
    "href": "07_differential_expression_analysis.html#perform-de-analysis-within-the-same-cell-type-across-conditions",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "1.2 Perform DE analysis within the same cell type across conditions",
    "text": "1.2 Perform DE analysis within the same cell type across conditions\nWe can also perform DE analysis within the same cell type across conditions.\n\n# subset CD4 T cells\nintegrate.filtered.rna$celltype.stim &lt;- paste(integrate.filtered.rna$Sample_Name, integrate.filtered.rna$predicted.celltype.l1, sep = \"_\")\n\n# Find genes differentially expressed between activated vs. naive samples in CD4 T cells\nIdents(integrate.filtered.rna) &lt;- \"celltype.stim\"\n\ncd4t.sc &lt;- FindMarkers(integrate.filtered.rna, \n                       ident.1 = \"treated_CD4 T\", \n                       ident.2 = \"naive_CD4 T\", \n                       verbose = FALSE)\n\nhead(cd4t.sc, n = 10)\n\n                 p_val avg_log2FC pct.1 pct.2     p_val_adj\nSTAT1    1.287895e-250  2.7850893 0.888 0.150 2.491691e-246\nIL7R     1.520720e-198 -2.4675759 0.406 0.856 2.942137e-194\nENO1     2.757226e-191  2.7814107 0.774 0.206 5.334405e-187\nTAP1     2.897556e-174  2.0199856 0.764 0.142 5.605902e-170\nHSP90AB1 2.834735e-171  2.3884659 0.863 0.533 5.484362e-167\nHSP90AA1 8.922351e-160  2.5514135 0.841 0.484 1.726207e-155\nLDHA     2.572990e-155  2.3324541 0.714 0.192 4.977964e-151\nGBP1     3.395478e-155  2.1078868 0.672 0.080 6.569232e-151\nTUBA1B   1.790942e-152  3.0084674 0.669 0.161 3.464935e-148\nRPS27    1.123880e-148 -0.8740197 0.981 1.000 2.174370e-144"
  },
  {
    "objectID": "log.html",
    "href": "log.html",
    "title": "Log",
    "section": "",
    "text": "Updated to Seurat V5\nArchive precourse_preparation_theory.qmd for future development\nhttps://github.com/satijalab/seurat/issues/8202"
  },
  {
    "objectID": "log.html#setup",
    "href": "log.html#setup",
    "title": "Log",
    "section": "Setup",
    "text": "Setup\n\nAdd instruction to install Seurat V4.\nAdd instruction to update packages.\nDelete packages to be installed: SingleR, celldex, muscat.\nAdd packages to be installed: HGNChelper, ggpubr, RTools.\nUpdate Data download link."
  },
  {
    "objectID": "log.html#precourse-preperation---r",
    "href": "log.html#precourse-preperation---r",
    "title": "Log",
    "section": "Precourse preperation - R",
    "text": "Precourse preperation - R\n\nAdd data download link"
  },
  {
    "objectID": "log.html#chapter-5-clustering",
    "href": "log.html#chapter-5-clustering",
    "title": "Log",
    "section": "Chapter 5 Clustering",
    "text": "Chapter 5 Clustering\n\nAdd clustree"
  },
  {
    "objectID": "log.html#chapter-6-marker-identification",
    "href": "log.html#chapter-6-marker-identification",
    "title": "Log",
    "section": "Chapter 6 Marker Identification",
    "text": "Chapter 6 Marker Identification\n\nReplace singleR with ScType\n\nAdd VlnPlot stack plot"
  },
  {
    "objectID": "log.html#chapter-7-differential-expression-analysis",
    "href": "log.html#chapter-7-differential-expression-analysis",
    "title": "Log",
    "section": "Chapter 7 Differential Expression Analysis",
    "text": "Chapter 7 Differential Expression Analysis\n\nReplace muscat with functions in Seurat V4 to perform pseudobulk analysis"
  },
  {
    "objectID": "log.html#chapter-8",
    "href": "log.html#chapter-8",
    "title": "Log",
    "section": "Chapter 8",
    "text": "Chapter 8\n\nReplace ranking in GSEA gene list from stat to log2FC\nForce enrich bar plots to plot GO terms with the key word “T Cell”"
  },
  {
    "objectID": "log.html#error-log",
    "href": "log.html#error-log",
    "title": "Log",
    "section": "Error log",
    "text": "Error log\n\nWhen you run RunUMAP…\n\n\nSolution: Downgrading Matrix\nIf Mac is updated to Sonoma 14.x.x, you may see errors related to gfortran, like:\nld: warning: search path ‘/opt/R/arm64/gfortran/lib/gcc/aarch64-apple-darwin20.2.0/11.0.0’ not found\nld: warning: search path ‘/opt/R/arm64/gfortran/lib’ not found\nld: library ‘gfortran’ not found\nIf that’s the case, please download and install gfortran-12.2-universal.pkg https://cran.r-project.org/bin/macosx/tools/ before proceed.\n\ninstall.packages(\"remotes\")\nremotes::install_version(\"Matrix\", version = \"1.6-1\")\npackageVersion(\"Matrix\")\n\nSource: https://cran.r-project.org/bin/macosx/tools/\n\nWhen you run getBM…\n\n\nSolution: Downgrading dbplyr\n\ndevtools::install_version(\"dbplyr\", version = \"2.3.4\")\n\nSource: https://stackoverflow.com/questions/77370659/error-failed-to-collect-lazy-table-caused-by-error-in-db-collect-using\n\nWhen you run useMart…\n\n\nSolution: Go to http://status.ensembl.org to check the status of Ensembl. If it says service is down, wait a few hours and try again."
  },
  {
    "objectID": "06_differential_expression_analysis.html",
    "href": "06_differential_expression_analysis.html",
    "title": "Chapter 6 Differential Expression Analysis",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(ggpubr)"
  },
  {
    "objectID": "06_differential_expression_analysis.html#de-analysis-across-conditions",
    "href": "06_differential_expression_analysis.html#de-analysis-across-conditions",
    "title": "Chapter 6 Differential Expression Analysis",
    "section": "1.1 DE analysis across conditions",
    "text": "1.1 DE analysis across conditions\nIn the last chapter, we used FindMarkers to find the marker genes between two clusters by specifying ident.1 and ident.2.\nChanging the ident.1 and ident.2 arguments, we can perform differential expression analysis between two groups.\nFor instance, we want to find genes deferentially expressed between naïve and treated PBMC.\n\n# change default assay to \"RNA\"\nDefaultAssay(filtered) &lt;- \"RNA\"\n\n# change default identity to \"Sample_Name\"\nIdents(filtered) &lt;- \"Sample_Name\"\n\n# Find genes differentially expressed\n# SampleTag02_hs: treated, SampleTag01_hs: naive\ntreated_naive &lt;- \n  FindMarkers(filtered, ident.1 = \"SampleTag02_hs\", ident.2 = \"SampleTag01_hs\") %&gt;% \n  rownames_to_column(\"gene\") %&gt;% \n  dplyr::filter(p_val_adj &lt; 0.05)\n\nWe can compare the gene expression between two groups by specifying ident.1 and ident.2.\n\nhead(treated_naive)\n\n   gene         p_val avg_log2FC pct.1 pct.2     p_val_adj\n1 STAT1  0.000000e+00   3.536478 0.855 0.165  0.000000e+00\n2  GBP1  0.000000e+00   4.261958 0.688 0.072  0.000000e+00\n3  TAP1 6.548471e-297   2.605137 0.758 0.178 1.847127e-292\n4  GBP4 5.149525e-268   3.292704 0.642 0.087 1.452527e-263\n5  XAF1 3.277283e-251   3.115752 0.639 0.113 9.244233e-247\n6  GBP5 2.251508e-247   3.182798 0.625 0.094 6.350828e-243\n\n\n\ngene Gene symbol.\np_val P-value without multiple testing.\navg_log2FC log2 fold-change of the average expression between the two groups.\npct.1 Percentage of cells in ident.1 expressing the gene.\npct.2 Percentage of cells in ident.2 expressing the gene.\np_val_adj Adjusted p-value."
  },
  {
    "objectID": "06_differential_expression_analysis.html#perform-de-analysis-within-the-same-cell-type-across-conditions",
    "href": "06_differential_expression_analysis.html#perform-de-analysis-within-the-same-cell-type-across-conditions",
    "title": "Chapter 6 Differential Expression Analysis",
    "section": "1.2 Perform DE analysis within the same cell type across conditions",
    "text": "1.2 Perform DE analysis within the same cell type across conditions\nWe can also perform DE analysis within the same cell type across conditions.\n\nfiltered$predicted.celltype.l1.tag &lt;- paste(filtered$predicted.celltype.l1, filtered$Sample_Name, sep = \"_\")\n\n# Find genes differentially expressed between activated vs. naive samples in CD4 T cells\nIdents(filtered) &lt;- \"predicted.celltype.l1.tag\"\n\ncd4t.deg &lt;- FindMarkers(filtered, \n                       ident.1 = \"CD4 T_SampleTag02_hs\", \n                       ident.2 = \"CD4 T_SampleTag01_hs\", \n                       verbose = FALSE)\n\nhead(cd4t.deg, n = 10)\n\n                 p_val avg_log2FC pct.1 pct.2     p_val_adj\nSTAT1    5.243685e-251  3.5416430 0.887 0.150 1.479086e-246\nIL7R     1.388277e-199 -2.7488648 0.404 0.856 3.915912e-195\nENO1     1.086061e-190  3.3819451 0.772 0.208 3.063453e-186\nTAP1     2.524773e-174  2.7602697 0.765 0.144 7.121627e-170\nHSP90AB1 1.010564e-172  2.5879009 0.864 0.532 2.850497e-168\nHSP90AA1 2.939542e-160  2.7729586 0.841 0.483 8.291566e-156\nGBP1     3.035576e-156  3.2311894 0.673 0.081 8.562448e-152\nLDHA     2.262665e-154  2.9055736 0.712 0.194 6.382300e-150\nTUBA1B   1.419730e-152  3.7297385 0.669 0.160 4.004633e-148\nRPS27    7.055812e-149 -0.8902341 0.981 1.000 1.990233e-144"
  },
  {
    "objectID": "06_differential_expression_analysis.html#setup",
    "href": "06_differential_expression_analysis.html#setup",
    "title": "Chapter 6 Differential Expression Analysis",
    "section": "2.1 Setup",
    "text": "2.1 Setup\nLet’s assume we have three biological replicates in each condition (we make them up for the purpose of illustration).\n\n# make a fake group information\nfiltered$donor &lt;- sample(x = c('A', 'B', 'C'), size = ncol(filtered), replace = TRUE)\n\npseudo &lt;- AggregateExpression(filtered, assays = \"RNA\", return.seurat = T, \n                              group.by = c(\"Sample_Name\", \"donor\", \"predicted.celltype.l1\"))\n\n# perform pseudobulk\npseudo$predicted.celltype.l1.tag &lt;- paste(pseudo$predicted.celltype.l1, pseudo$Sample_Name, sep = \"_\")\n\nIdents(pseudo) &lt;- \"predicted.celltype.l1.tag\"\n\ncd4t.bulk &lt;- FindMarkers(object = pseudo, \n                         ident.1 = \"CD4 T_SampleTag02-hs\", \n                         ident.2 = \"CD4 T_SampleTag01-hs\",\n                         test.use = \"DESeq2\")\n\nhead(cd4t.bulk, n = 15)\n\n         p_val avg_log2FC pct.1 pct.2 p_val_adj\nACTB         0  4.6338590     1     1         0\nACTG1        0  5.3351152     1     1         0\nENO1         0  6.6251870     1     1         0\nFYB1         0  0.1773963     1     1         0\nHSP90AA1     0  6.1199756     1     1         0\nHSP90AB1     0  5.8691572     1     1         0\nHSPA8        0  5.3011800     1     1         0\nIL7R         0 -1.0822124     1     1         0\nMALAT1       0  0.3498426     1     1         0\nNPM1         0  4.5477165     1     1         0\nPFN1         0  4.4851717     1     1         0\nPPIA         0  4.8739051     1     1         0\nPTMA         0  3.9801570     1     1         0\nRAN          0  5.8907963     1     1         0\nRPS27        0  1.2461890     1     1         0"
  },
  {
    "objectID": "03_normalization.html#exercise-1",
    "href": "03_normalization.html#exercise-1",
    "title": "Chapter 3 Normalization",
    "section": "Exercise 1",
    "text": "Exercise 1\nChange the number of PCs and see how the UMAP changes.\nTips: You can change the PC numbers by dims argument in RunUMAP."
  },
  {
    "objectID": "03_normalization.html#exercise-2",
    "href": "03_normalization.html#exercise-2",
    "title": "Chapter 3 Normalization",
    "section": "Exercise 2",
    "text": "Exercise 2\nDimplot has many arguments to control the plots.\n\nSearch Dimplot in the “Help” tab and read the documentation.\nChange group.by to split.by. What is the difference?\n\n\np1 &lt;- DimPlot(filtered, group.by = \"Sample_Name\") + NoLegend()\np2 &lt;- DimPlot(filtered, split.by = \"Sample_Name\")  + NoLegend()\n\np1|p2"
  },
  {
    "objectID": "05_marker_identification.html",
    "href": "05_marker_identification.html",
    "title": "Chapter 5 Marker Identification",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(HGNChelper)"
  },
  {
    "objectID": "05_marker_identification.html#findallmarkers",
    "href": "05_marker_identification.html#findallmarkers",
    "title": "Chapter 5 Marker Identification",
    "section": "1.1 FindAllMarkers\n",
    "text": "1.1 FindAllMarkers\n\nThis type of analysis is typically for evaluating a single sample group/condition. With the FindAllMarkers function, we are comparing each cluster to all other clusters to identify potential marker genes. The cells in each cluster are treated as replicates, and essentially a differential expression analysis is performed with some statistical test. By default, the test is Wilcoxon Rank Sum test.\nThe FindAllMarkers function has three arguments to determine if a gene is a marker gene.\n\nlogfc.threshold Limit testing to genes that show, on average, at least an X-fold difference (log-scale) between the two groups of cells. The default is 0.25. Increasing logfc.threshold speeds up the function but can miss weaker signals.\nmin.pct Only test genes that are detected in a minimum fraction of cells in either of the two populations. It is meant to speed up the function by not testing infrequently expressed genes. The default is 0.1.\nonly.pos Only return positive markers (FALSE by default).\n\nOne may change the arguments depending on how stringent to be.\nWe look at the marker genes in the clusters in sample “treated”.\n\ntreated.markers &lt;- FindAllMarkers(subset(filtered, subset = Sample_Name == \"SampleTag02_hs\"), \n                                  assay = \"RNA\",\n                                  only.pos = TRUE, \n                                  min.pct = 0.25, \n                                  logfc.threshold = 0.25)\n\nLet’s look at the top 2 significant marker genes in each cluster.\n\ntreated.markers %&gt;%\n    group_by(cluster) %&gt;%\n    slice_max(n = 2, order_by = avg_log2FC)\n\n# A tibble: 22 × 7\n# Groups:   cluster [11]\n       p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene           \n       &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;          \n 1 2.21e- 39       2.43 0.394 0.096 6.23e- 35 0       LINC00861      \n 2 1.16e- 26       2.34 0.458 0.195 3.28e- 22 0       PDE3B          \n 3 8.15e- 37       2.79 0.306 0.107 2.30e- 32 1       RGS1           \n 4 5.57e- 87       2.10 0.605 0.22  1.57e- 82 1       MAL            \n 5 1.35e- 97       4.61 0.268 0.006 3.80e- 93 2       RAD54L         \n 6 1.24e-126       4.12 0.355 0.011 3.49e-122 2       UBE2C          \n 7 1.75e-104       6.29 0.267 0.006 4.94e-100 3       CX3CR1         \n 8 6.94e-200       6.29 0.507 0.014 1.96e-195 3       FCGR3A         \n 9 2.30e-  3       4.87 0.273 0.063 1   e+  0 4       TOX            \n10 8.67e-  6       4.77 0.273 0.034 2.45e-  1 4       ENSG00000225718\n# ℹ 12 more rows\n\n\nWe get a table with the information on marker genes.\np_val P-value before multiple testing.\navg_log2FC Log2 fold change on the average gene expression between one cluster and the rest of cluster combined.\npct.1 Percentage of cells expressing the gene in one group. Here is one cluster.\npct.2 Percentage of cells expressing the gene in another group. Here is the rest of cluster combined.\np_val_adj p-value with multiple testing correction.\ngene Gene name."
  },
  {
    "objectID": "05_marker_identification.html#findmarkers",
    "href": "05_marker_identification.html#findmarkers",
    "title": "Chapter 5 Marker Identification",
    "section": "1.2 FindMarkers\n",
    "text": "1.2 FindMarkers\n\nWe can use the FindMarkers to determine the differentially expressed genes between two clusters.\n\nexample_findmarkers &lt;- FindMarkers(filtered,\n                          assay = \"RNA\",\n                          ident.1 = 1,\n                          ident.2 = 2) %&gt;% \n  rownames_to_column(\"gene\")"
  },
  {
    "objectID": "05_marker_identification.html#reference-based",
    "href": "05_marker_identification.html#reference-based",
    "title": "Chapter 5 Marker Identification",
    "section": "2.1 Reference-based",
    "text": "2.1 Reference-based\nWe look at the publicly available dataset with annotation and build a reference set based on its information. Then we can “transfer” the annotation from the reference to the query. Seurat provides the interface to connect with Azimuth.\n\n\n\n\n\n\nNote\n\n\n\nBecause the annotation information is based on the reference set, the reference ideally is similar to the query. They may come from the same tissue, same organism, similar experimental procedure, etc.\n\n\n\nfiltered &lt;- Azimuth::RunAzimuth(filtered, reference = \"pbmcref\", verbose = F)\n\nWe can look at the automatic annotation on UMAP.\n\np1 &lt;- DimPlot(filtered, reduction = \"umap\", \n              group.by = \"predicted.celltype.l1\", \n              label = TRUE, label.size = 3 ,repel = TRUE) + \n  NoLegend()\n\np2 &lt;- DimPlot(filtered, reduction = \"umap\", \n              group.by = \"RNA_snn_res.0.4\", \n              label = TRUE, label.size = 3 ,repel = TRUE) + \n  NoLegend()\n\np1|p2"
  },
  {
    "objectID": "05_marker_identification.html#marker-based",
    "href": "05_marker_identification.html#marker-based",
    "title": "Chapter 5 Marker Identification",
    "section": "2.1 Marker-based",
    "text": "2.1 Marker-based\nWe use ScType (https://github.com/IanevskiAleksandr/sc-type/blob/master/README.md) to annotate cell population based on known immune markers.\nScType also has an open source portal: https://sctype.app/.\n\n# load ScType R functions\nsource(\"https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R\"); source(\"https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R\")\n\n# get cell-type-specific gene sets from our in-built database (DB)\n# list downloaded from https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_short.xlsx\n# e.g. Immune system, Liver, Pancreas, Kidney, Eye, Brain\ngs_list &lt;-  gene_sets_prepare(\"data/ScTypeDB_short.xlsx\", \"Immune system\") \n\n# assign cell types\n# NOTE: scRNAseqData parameter should correspond to your input scRNA-seq matrix. \n# In case Seurat is used, it is either GetAssayData(seuratObj[[\"RNA\"]], layer = \"scale.data\"), in case sctransform is used for normalization,\n# or GetAssayData(seuratObj[[\"integrated\"]], layer = \"scale.data\"), in case a joint analysis of multiple single-cell datasets is performed.\nes.max &lt;-  sctype_score(scRNAseqData = GetAssayData(filtered[[\"RNA\"]], layer = \"scale.data\"), \n                        scaled = TRUE, \n                        gs = gs_list$gs_positive, \n                        gs2 = gs_list$gs_negative)\n\n# merge by cluster\ncL_resutls = do.call(\"rbind\", lapply(unique(filtered@meta.data$RNA_snn_res.0.4), function(cl){\n    es.max.cl = sort(rowSums(es.max[ ,rownames(filtered@meta.data[filtered@meta.data$RNA_snn_res.0.4==cl, ])]), decreasing = !0)\n    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(filtered@meta.data$filtered==cl)), 10)\n}))\n\nsctype_scores = cL_resutls %&gt;% group_by(cluster) %&gt;% top_n(n = 1, wt = scores)  \n\n# set low-confident (low ScType score) clusters to \"unknown\"\nsctype_scores$type[as.numeric(as.character(sctype_scores$scores)) &lt; sctype_scores$ncells/4] = \"Unknown\"\n\n\nfiltered@meta.data$customclassif = \"\"\n\nfor(j in unique(sctype_scores$cluster)){\n  cl_type = sctype_scores[sctype_scores$cluster==j,]; \n  filtered@meta.data$customclassif[filtered@meta.data$RNA_snn_res.0.4 == j] = as.character(cl_type$type[1])\n}\n\nDimPlot(filtered, reduction = \"umap\", label = TRUE, repel = TRUE, group.by = 'customclassif')"
  },
  {
    "objectID": "07_enrichment_analysis.html",
    "href": "07_enrichment_analysis.html",
    "title": "Chapter 7 Enrichment Analysis",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(org.Hs.eg.db)\nlibrary(clusterProfiler)\nlibrary(AnnotationDbi)\nlibrary(enrichplot)\nlibrary(biomaRt)\n\nLoad RData\nLoad the RData which contains all files from the previous chapter.\n\nload(\"data/chapter6.RData\")\n\nOftentimes, enrichment analysis takes the differentially expressed genes and looks at which gene ontology (GO) terms are enriched.\nGO terms defines concepts/classes used to describe gene function and relationships between these concepts. clusterProfiler is an R package implementing many methods to analyze and visualize functional profiles from a group of features. It classifies functions in three aspects.\n\nMF: Molecular Function: molecular activities of gene products.\nCC: Cellular Component: where gene products are active.\nBP: Biological Process: pathways and larger processes made up of the activities of multiple gene products.\n\nThis chapter uses the differentially expressed genes in CD4+ T cells from last chapter as an example.\n1. Get Entrez ID\nclusterProfiler prefers the input of Entrez ID. We use biomaRt package to convert the gene symbol into Entrez ID.\n\n\n\n\n\n\nNote\n\n\n\nbiomaRt is handy to get information about features. You can use it to get gene symbols, genomic coordinates, transcript sequences, etc. You can explore what data is stored in biomaRt with listAttributes.\n\n\nThe differentially expressed genes in CD4+ T cells between naïve and treated PBMCs are stored in the matrix cd4t. The gene symbol in this list can be converted into Entrez ID by biomaRt.\nFirstly, connect to the Ensembl database and specify we want to retrieve information from the dataset of Homo Sapien.\n\nmart &lt;- useMart(biomart = \"ensembl\", dataset = \"hsapiens_gene_ensembl\")\n\n\nbiomart BioMart database connect to. Here, we want to connect to ensembl database.\ndataset Dataset to use. Here specify hsapiens_gene_ensembl.\n\nNext, we can give a list of gene symbols and retrieve the Entrez ID through getBM.\n\nresults &lt;- getBM(attributes = c(\"entrezgene_id\", \"external_gene_name\"),\n                 filters = \"external_gene_name\", \n                 values = rownames(cd4t.deg),\n                 mart = mart)\n\n\nattributes Attributes to retrieve. We want to have the gene symbols and Entrez ID in the results.\nfilters Which filter to use to filter the dataset.\nvalues A list of features as a query.\nmart Object of class Mart, created with the useMart function.\n\nA table of two columns is created and stored in the matrix of results.\n\nresults %&gt;% head\n\n  entrezgene_id external_gene_name\n1          4535             MT-ND1\n2          4536             MT-ND2\n3          4512             MT-CO1\n4          4514             MT-CO3\n5          4537             MT-ND3\n6          4540             MT-ND5\n\n\nNot every gene has the Entrez ID. We keep only genes that have a matched Entrez ID.\n\ncd4t.deg &lt;- cd4t.deg %&gt;% \n  rownames_to_column(\"gene\") %&gt;% \n  left_join(., results, by = c(\"gene\" = \"external_gene_name\")) %&gt;% \n  filter(!is.na(entrezgene_id)) %&gt;% \n  filter(!is.na(p_val_adj))\n\n2. GO over-representation analysis\nOver Representation Analysis (ORA) is a widely used approach to determine whether known biological functions or processes are over-represented (= enriched) in an experimentally-derived gene list, e.g. a list of differentially expressed genes (DEGs).\nWe use the enrichGO to get the enriched GO terms in the list of DEGs.\n\ncd4t.deg.sig &lt;- dplyr::filter(cd4t.deg, p_val_adj &lt; 0.05, \n                               abs(avg_log2FC) &gt; 1)\n\n# get the enriched GO terms\nego &lt;- enrichGO(gene = cd4t.deg.sig$entrezgene_id,\n                keyType = \"ENTREZID\",\n                OrgDb = org.Hs.eg.db,\n                ont = \"BP\",\n                pAdjustMethod = \"BH\",\n                pvalueCutoff = 0.01,\n                qvalueCutoff = 0.05,\n                readable = TRUE)\n\n\ngene A list of Entrez gene id.\nkeyType The keytype of input gene.\nOrgDb The database with detailed information about the species.\norg.Hs.eg.db Specify the database of Homo Sapien.\nont One of “BP” (biological process), “MF” (molecular function), and “CC” (cellular component) subontologies, or “ALL” for all three.\npAdjustMethod Multiple testing method for p-value.\npvalueCutoff Adjusted pvalue cutoff on enrichment tests to report.\nqvalueCutoff Tge qvalue cutoff on enrichment tests to report as significant.\nreadable Whether mapping gene ID to gene Name.\n\nLet’s convert the ego object into a data frame and visualize the results in a bar plot.\n\nego.table &lt;- as.data.frame(ego)\n\n\nGeneRatio The gene counts from the input list found in the gene set of a GO term / gene counts of input list.\nBgRatio The gene counts of a geneset / size of all of the unique genes in the collection of genesets.\n\n\nfilter(ego, Description %in% grep(\"T cell\", ego.table$Description, ignore.case = T, value = T)) %&gt;% \nbarplot(showCategory = 18)\n\n\n\n\n3. Gene set enrichment analysis - Optional\nAll genes can be used as input of gene set enrichment analysis (GSEA). We first rank the genes based on stat.\n\n# order genes\ncd4t.deg &lt;- cd4t.deg[order(-cd4t.deg$avg_log2FC), ]\n\ngene_list &lt;- cd4t.deg$avg_log2FC\nnames(gene_list) &lt;- cd4t.deg$entrezgene_id\n\nWe use gseGO to perform GSEA and convert the results into a dataframe.\n\n# perform GSEA\ngse &lt;- gseGO(gene_list,\n             keyType = \"ENTREZID\",\n             ont = \"BP\",\n             OrgDb = \"org.Hs.eg.db\")\n\n# convert the results into a dataframe\ngse.table &lt;- as.data.frame(gse) %&gt;% \n  mutate(geneSetID = 1:dim(.)[1])\n\nenrichmentScore The enrichment score (ES) represents the degree to which a set S is over-represented at the top or bottom of the ranked list L.\nWe can look at the enrichment of some GO terms in GSEA plot.\n\ngseaplot2(gse, geneSetID = c(161, 171))\n\n\n\n\nWe have significant enriched term in the unregulated genes. Along the x axis is the ranked genes. Each of the vertical line is one of those genes that are found in this gene set. Along the running line, you can see a lot of genes running together and it falls out when the gene becomes more sparse in the list.\n4. Save\nSave the files into RData for documentation.\n\nsave(filtered, cd4t.deg, cd4t.deg.sig, ego, ego.table, gse, gse.table, file = \"data/chapter7.RData\")"
  },
  {
    "objectID": "supplementary_targeted_analysis.html#data-imports",
    "href": "supplementary_targeted_analysis.html#data-imports",
    "title": "Supplementary: Targeted assays",
    "section": "2.1 Data imports",
    "text": "2.1 Data imports\n\n\n\n\n\n\nNote\n\n\n\nWhen creating the Seurat object, it is important to specify min.cells = 1 and min.features = 1.\n\n\n\nseuratObj &lt;- readRDS(\"16HIRP-targeted-EB-20kPBMC/16HIRP_Seurat.rds\")\n\n# update Seurat object\nseuratObj[[\"RNA\"]] &lt;- as(object = seuratObj[[\"RNA\"]], Class = \"Assay5\")"
  },
  {
    "objectID": "04_clustering.html",
    "href": "04_clustering.html",
    "title": "Chapter 4 Clustering",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(clustree)\nlibrary(HGNChelper)\n\nLoad RData\nLoad the RData which contains all files from the previous chapter.\n\nload(\"data/chapter3.RData\")\n\n1. Clustering\nNow that we have our high quality cells, we want to know the different cell types present within our population of cells.\nSeurat uses a graph-based clustering approach, which embeds cells in a graph structure, using a K-nearest neighbor (KNN) graph (by default), with edges drawn between cells with similar gene expression patterns. Then, it attempts to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.\nWe will use the FindClusters function to perform the graph-based clustering. The resolution is an important argument that sets the “granularity” of the downstream clustering and will need to be optimized for every individual experiment.\n\n\n\n\n\n\nImportant\n\n\n\nIncreasing resolution value leads to a greater number of clusters, which is often required for larger datasets.\n\n\nThe FindClusters function allows us to enter a series of resolutions and will calculate the “granularity” of the clustering. This is very helpful for testing which resolution works for moving forward without having to run the function for each resolution.\n\n# Determine the K-nearest neighbor graph\nfiltered &lt;- FindNeighbors(object = filtered, dims = 1:20)\n                                \n# Determine the clusters for various resolutions                                \nfiltered &lt;- FindClusters(object = filtered,\n                         resolution = c(0.2, 0.4, 0.6,  0.8, 1, 1.2, 1.4),\n                         verbose = F)\n\nThe meta.data has a separate column for each of the different resolution calculated. We can look at how many clusters in each resolution.\n\nfiltered@meta.data %&gt;% \n  dplyr::select(contains(\"RNA_snn\")) %&gt;% \n  map_int(~ unique(.x) %&gt;% length)\n\nRNA_snn_res.0.2 RNA_snn_res.0.4 RNA_snn_res.0.6 RNA_snn_res.0.8   RNA_snn_res.1 \n              9              12              15              16              17 \nRNA_snn_res.1.2 RNA_snn_res.1.4 \n             18              19 \n\n\n\nclustree(filtered, prefix = \"RNA_snn_res.\")\n\n\n\n\nWe can see that some clusters are very distinct and do not change with the value of resolution. On the right side of the tree, we see a single cluster that splits into the multiple clusters. The tree becomes messier as the resolution increases. There are nodes with multiple incoming edges. This is a good indication that we have over clustered the data.\nWe start with the resolution of 0.4. We assign the identity of the clusters using the Idents function to specify that we want to look at the clusters calculating with resolution = 0.4.\n\nIdents(object = filtered) &lt;- \"RNA_snn_res.0.4\"\n\n# UMAP visualization\nDimPlot(filtered,\n        reduction = \"umap\",\n        label = TRUE,\n        label.size = 6)\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nChange to other resolution values. How do the clusters change?\n\n\n2. Distribution of cells per cluster\nThe number of clusters are sensitive to the resolution. The demo dataset has PBMC and we expect each cluster contains cells from both samples.\n\nFetchData(filtered, \n          vars = c(\"ident\", \"Sample_Name\")) %&gt;%\n  dplyr::count(ident, Sample_Name) %&gt;%\n  tidyr::spread(ident, n)\n\n     Sample_Name    0   1   2   3   4   5   6  7   8  9 10 11\n1 SampleTag01_hs 1019   8  NA   8 327 286  68 62  NA 34 10 29\n2 SampleTag02_hs  216 653 608 345  11  11 178 71 111 59 47 NA\n\n\nWe can split the UMAP by sample.\n\n# UMAP of cells in each cluster by sample\nDimPlot(filtered, \n        label = TRUE, \n        split.by = \"Sample_Name\")  + NoLegend()\n\n\n\n\n3. Exploring known cell type markers\nWe can explore some known cell type markers to get an idea about the identity of clusters.\nSome typical cell type markers:\n\nCD14+ monocytes: CD14, LYZ\nConventional dendritic cells: FCER1A, CST3\nB cells: CD79A, MS4A1\nT cells: CD3D\nCD4+ T cells: CD3D, IL7R, CCR7\nCD8+ T cells: CD3D, CD8A\nNK cells: GNLY, NKG7\nMacrophages: MARCO, ITGAM, ADGRE1\n\nThe FeaturePlot makes it easy to visualize a handful of genes using the gene IDs stored in the Seurat object. We can easily explore the expression of known gene markers on top of our UMAPs. Let’s go through and determine the identities of the clusters. To access the normalized expression levels of all genes, we can use the normalized counts stored in the RNA assay slot.\n\nDefaultAssay(filtered) &lt;- \"RNA\"\n\n\nCD14+ monocytes: CD14, LYZ\n\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"CD14\", \"LYZ\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nB cells: CD79A, MS4A1\n\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"CD79A\", \"MS4A1\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nNK cells: GNLY, NKG7\n\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"GNLY\", \"NKG7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nT cells: CD3D\n\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"CD3D\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nCD4+ T cells: CD3D, IL7R, CCR7\n\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"IL7R\", \"CCR7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nCD8+ T cells: CD3D, CD8A\n\n\nFeaturePlot(filtered, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"CD8A\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n4. Save\nSave the files into RData for documentation.\n\nsave(filtered, file = \"data/chapter4.RData\")"
  },
  {
    "objectID": "precourse_preparations_R.html",
    "href": "precourse_preparations_R.html",
    "title": "Precourse Preparation",
    "section": "",
    "text": "This tutorial will help you to understand the basic concepts in R. It will cover the following topics:\n\nWorking with Dataframes\nTidyverse library\nUnderstanding the Seurat object"
  },
  {
    "objectID": "precourse_preparations_R.html#what-is-data-frame",
    "href": "precourse_preparations_R.html#what-is-data-frame",
    "title": "Precourse Preparation",
    "section": "1.1 What is data frame",
    "text": "1.1 What is data frame\nData frame is data structure in R that store values of any type. You can think of it as a table with columns and rows storing the data as in below example.\n\nCredit: https://www.geeksforgeeks.org/r-data-frames/\nOften in data science language the columns are named as variables, the rows are observations and each entry in a table is a value.\nSome of the most common examples of input files that can be loaded into R as data frames are spreadsheets, TSVs, CSVs files. TSV and CSV stands for tab-separated or coma-separated values.\nAnother way to view data frame is as list of vectors of the same length. The vector can be defined as type of data structure that contains elements of the same type. Below you can find example on how create the table presented in Figure 1 from vectors.\n\n#define vectors which will create columns with data in data frame\n\n## Vector of names\nName &lt;- c(\"Avrey Bradley\",\"John Holland\",\"Jonas Jerebko\",\"Jordan Midkey\",\"Terry Rozier\",\"Jared Sullinger\",\"Evan Turner\")\n\n## Vector of team's names\nTeam &lt;- c(\"Boston Celtics\", \"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\")\n\n## Vector of values\nNumber &lt;- c(0.0,30.0,8.0,NaN,12.0,7.0,11.0)\n\n## Vector of positions\nPosition &lt;- c(\"PG\",\"SG\",\"PF\",\"PF\",\"PG\",\"C\",\"SG\")\n\n## Vector of age\nAge &lt;- c(25.0,27.0,29.0,21.0,22.0,NaN,27.0)\n\n#create data frame from vectors\ndata.frame(Name,Team,Number,Position,Age)\n\n             Name           Team Number Position Age\n1   Avrey Bradley Boston Celtics      0       PG  25\n2    John Holland Boston Celtics     30       SG  27\n3   Jonas Jerebko Boston Celtics      8       PF  29\n4   Jordan Midkey Boston Celtics    NaN       PF  21\n5    Terry Rozier Boston Celtics     12       PG  22\n6 Jared Sullinger Boston Celtics      7        C NaN\n7     Evan Turner Boston Celtics     11       SG  27"
  },
  {
    "objectID": "precourse_preparations_R.html#convenient-version-of-data-frame-tibble",
    "href": "precourse_preparations_R.html#convenient-version-of-data-frame-tibble",
    "title": "Precourse Preparation",
    "section": "1.2 Convenient version of data frame: “Tibble”",
    "text": "1.2 Convenient version of data frame: “Tibble”\nThe tibble is package that manipulate data frames. The tibble type of table looks like data frame but have some advantages over using regular data frames.\nFor example, while loading data as classical data frame, the spaces in names are conversed to periods or “x” before numeric columns is added. While using tibbles, the input names and types remain unchanged. In this tutorial we will work mainly with tibble data frame type."
  },
  {
    "objectID": "precourse_preparations_R.html#working-with-data-frames-in-r",
    "href": "precourse_preparations_R.html#working-with-data-frames-in-r",
    "title": "Precourse Preparation",
    "section": "1.3 Working with data frames in R",
    "text": "1.3 Working with data frames in R\n1.3.1 Example data\nIn this part of tutorial we will work on table downloaded from supplementary data of Salcher, Stefan et al. publication (doi:10.1016/j.ccell.2022.10.008). The table contains the metadata of patients for which samples were processed on different single-cell platforms.\n1.3.2 Loading the data\nDepending on the input format there are different dedicated libraries to load data into R. Here we start from excel spreadsheet and use function from readxl library. The readxl library is part of tidyverse packages that will be covered in second chapter of this tutorial.\n\ndf_example &lt;- read_excel(\"data/precourse_preparation_data/mmc4.xlsx\",  skip = 2)\n\nNOTE:\n\nThe two first rows in the table are empty and therefore skipped while loading.\nOne of the columns in excel spreadsheet is empty (column N). The R assign automatically the default name to that column and keep it within data frame.\nAll the missing entries in rows will be filled with “NA” values automatically.\n1.3.3 Viewing the content\nThere are different ways to view the content of data frame. The “View” function will take you to separate window where you see the table displayed and interact with it directly.\n\nView(df_example)\n\nThe “str” function lists directly in the console: the type of data (tibble), dimensions (322x18), columns with first values displayed and type of values.\n\nstr(df_example)\n\nClasses 'tbl_df', 'tbl' and 'data.frame':   322 obs. of  18 variables:\n $ ...1                    : num  0 1 2 3 4 5 6 7 8 9 ...\n $ study                   : chr  \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" ...\n $ dataset                 : chr  \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" ...\n $ patient                 : chr  \"Adams_Kaminski_2020_001C\" \"Adams_Kaminski_2020_002C\" \"Adams_Kaminski_2020_003C\" \"Adams_Kaminski_2020_8CO\" ...\n $ uicc_stage              : chr  NA NA NA NA ...\n $ tumor_stage             : chr  NA NA NA NA ...\n $ sex                     : chr  \"male\" \"female\" \"female\" \"male\" ...\n $ ever_smoker             : chr  \"no\" \"no\" \"no\" \"yes\" ...\n $ driver_genes            : chr  NA NA NA NA ...\n $ condition               : chr  \"non-cancer\" \"non-cancer\" \"non-cancer\" \"COPD\" ...\n $ age                     : num  22 25 67 65 66 49 62 57 66 20 ...\n $ platform                : chr  \"10x\" \"10x\" \"10x\" \"10x\" ...\n $ platform_fine           : chr  \"10x_3p_v2\" \"10x_3p_v2\" \"10x_3p_v2\" \"10x_3p_v2\" ...\n $ ...14                   : logi  NA NA NA NA NA NA ...\n $ tissue: normal          : num  1 1 1 1 1 1 1 1 1 1 ...\n $ tissue: normal_adjacent : num  0 0 0 0 0 0 0 0 0 0 ...\n $ tissue: tumor_primary   : num  0 0 0 0 0 0 0 0 0 0 ...\n $ tissue: tumor_metastasis: num  0 0 0 0 0 0 0 0 0 0 ...\n\n\n1.3.4 Extracting information\nExtracting data from an R data frame means to access its rows or columns. First let’s list all columns available in the dataset.\n\ncolnames(df_example)\n\n [1] \"...1\"                     \"study\"                   \n [3] \"dataset\"                  \"patient\"                 \n [5] \"uicc_stage\"               \"tumor_stage\"             \n [7] \"sex\"                      \"ever_smoker\"             \n [9] \"driver_genes\"             \"condition\"               \n[11] \"age\"                      \"platform\"                \n[13] \"platform_fine\"            \"...14\"                   \n[15] \"tissue: normal\"           \"tissue: normal_adjacent\" \n[17] \"tissue: tumor_primary\"    \"tissue: tumor_metastasis\"\n\n\nTo extract values from single column of the data frame different options can be used:\n\nUsing $ operator and providing the column name\n\n\nhead(df_example$study) # head allows to display only 10 first elements \n\n[1] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n[4] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n\n\n\nUsing [ , ] and providing the column number (index)\n\n\ndf_example[10, 2]\n\n# A tibble: 1 × 1\n  study              \n  &lt;chr&gt;              \n1 Adams_Kaminski_2020\n\n\n\nUsing [[]] and providing column number (index)\n\n\nhead(df_example[[2]]) # head allows to display only 10 first elements \n\n[1] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n[4] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n\n\n\nUsing column name\n\n\ndf_example[10 ,c(\"study\")]\n\n# A tibble: 1 × 1\n  study              \n  &lt;chr&gt;              \n1 Adams_Kaminski_2020\n\n\nTo extract multiple columns or rows at the same time the following rules apply:\n\n\nExtract rows range, include all columns.\n\n\ndf_example[c(2:4),] #display rows from 2-4 and all columns\n\n  ...1               study             dataset                  patient\n2    1 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_002C\n3    2 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_003C\n4    3 Adams_Kaminski_2020 Adams_Kaminski_2020  Adams_Kaminski_2020_8CO\n  uicc_stage tumor_stage    sex ever_smoker driver_genes  condition age\n2       &lt;NA&gt;        &lt;NA&gt; female          no         &lt;NA&gt; non-cancer  25\n3       &lt;NA&gt;        &lt;NA&gt; female          no         &lt;NA&gt; non-cancer  67\n4       &lt;NA&gt;        &lt;NA&gt;   male         yes         &lt;NA&gt;       COPD  65\n  platform platform_fine ...14 tissue: normal tissue: normal_adjacent\n2      10x     10x_3p_v2    NA              1                       0\n3      10x     10x_3p_v2    NA              1                       0\n4      10x     10x_3p_v2    NA              1                       0\n  tissue: tumor_primary tissue: tumor_metastasis\n2                     0                        0\n3                     0                        0\n4                     0                        0\n\n\n\nExtract rows, include all columns.\n\n\ndf_example[c(2,4),] #display rows 2 and 4 and all columns\n\n  ...1               study             dataset                  patient\n2    1 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_002C\n4    3 Adams_Kaminski_2020 Adams_Kaminski_2020  Adams_Kaminski_2020_8CO\n  uicc_stage tumor_stage    sex ever_smoker driver_genes  condition age\n2       &lt;NA&gt;        &lt;NA&gt; female          no         &lt;NA&gt; non-cancer  25\n4       &lt;NA&gt;        &lt;NA&gt;   male         yes         &lt;NA&gt;       COPD  65\n  platform platform_fine ...14 tissue: normal tissue: normal_adjacent\n2      10x     10x_3p_v2    NA              1                       0\n4      10x     10x_3p_v2    NA              1                       0\n  tissue: tumor_primary tissue: tumor_metastasis\n2                     0                        0\n4                     0                        0\n\n\n\nExtract columns range, include all rows.\n\n\ndf_example[10, c(2:4)] #display columns from 2-4 and all rows\n\n# A tibble: 1 × 3\n  study               dataset             patient                 \n  &lt;chr&gt;               &lt;chr&gt;               &lt;chr&gt;                   \n1 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_081C\n\n\n\nExtract columns, include all rows.\n\n\ndf_example[10, c(2,4)] #display columns 2 and 4 and all rows\n\n# A tibble: 1 × 2\n  study               patient                 \n  &lt;chr&gt;               &lt;chr&gt;                   \n1 Adams_Kaminski_2020 Adams_Kaminski_2020_081C\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise\n\nExtract rows from 5-10 and columns from 3-8.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer\n\n\ndf_example[c(5:10),c(3,8)]\n\n               dataset ever_smoker\n5  Adams_Kaminski_2020         yes\n6  Adams_Kaminski_2020         yes\n7  Adams_Kaminski_2020         yes\n8  Adams_Kaminski_2020         yes\n9  Adams_Kaminski_2020          no\n10 Adams_Kaminski_2020          no\n\n\n\n\n\n1.3.4 Modifying information\nThe columns or rows can be removed or added to data frame as needed. It is possible to drop specific columns indicating the column indexes.\n\nmodified_df_example &lt;- df_example[, -c(1,2,5)]    # Drop columns 1,2,5 and include all columns\nmodified_df_example[10, ] # data frame with excluded columns \n\n# A tibble: 1 × 15\n  dataset     patient tumor_stage sex   ever_smoker driver_genes condition   age\n  &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;     &lt;dbl&gt;\n1 Adams_Kami… Adams_… &lt;NA&gt;        male  no          &lt;NA&gt;         non-canc…    20\n# ℹ 7 more variables: platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;,\n#   `tissue: normal` &lt;dbl&gt;, `tissue: normal_adjacent` &lt;dbl&gt;,\n#   `tissue: tumor_primary` &lt;dbl&gt;, `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\nThe same principle apply to excluding the rows\n\nmodified_df_example &lt;- df_example[-c(1,2,5),]     # Drop rows 1,2,5 and include all columns\nmodified_df_example[10, ]\n\n# A tibble: 1 × 18\n   ...1 study           dataset patient uicc_stage tumor_stage sex   ever_smoker\n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;      \n1    12 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n# ℹ 10 more variables: driver_genes &lt;chr&gt;, condition &lt;chr&gt;, age &lt;dbl&gt;,\n#   platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\nWe can remove column with specific name. To drop column, we chose all the columns (called by “colnames”) except (!=) “patient”.\n\nmodified_df_example &lt;- df_example[ , colnames(df_example) != \"patient\"]    # Drop column \"patient\"\nmodified_df_example[10, ]\n\n# A tibble: 1 × 17\n   ...1 study      dataset uicc_stage tumor_stage sex   ever_smoker driver_genes\n  &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;       \n1     9 Adams_Kam… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  no          &lt;NA&gt;        \n# ℹ 9 more variables: condition &lt;chr&gt;, age &lt;dbl&gt;, platform &lt;chr&gt;,\n#   platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\nThe new columns can be added to data frame. To add new column, use $ to indicate the column name for a new column as in the example below.\nHere we assign the values from already existing column to a new column. The new column is added at the end of the data table.\n\ndf_example$technology_type &lt;- df_example$platform # add new column named \"technology_type\" with values from \"platform\" existing column\ndf_example[10, ncol(df_example)] #show all rows and last column\n\n# A tibble: 1 × 1\n  technology_type\n  &lt;chr&gt;          \n1 10x            \n\n\nThe values from chosen column can be replaced with other values. In example below we search in df_example data frame in technology_type column for rows that contain “BD-Rhapsody” text. For those values we assign “microwell-based”.\n\ndf_example$technology_type[df_example$technology_type == \"BD-Rhapsody\"] &lt;- \"microwell-based\"\ndf_example$technology_type[df_example$technology_type == \"10x\"] &lt;- \"droplet-based\"\n\ndf_example[10, c(\"platform\",\"technology_type\")] #display columns\n\n# A tibble: 1 × 2\n  platform technology_type\n  &lt;chr&gt;    &lt;chr&gt;          \n1 10x      droplet-based  \n\n\nThe last useful function to cover in this chapter is summary(). The function gives the statistical summary of each of the columns when applied on data frame. It can be applied on slice of data as for example only on one column or chosen columns and rows.\n\nsummary(df_example)\n\n      ...1           study             dataset            patient         \n Min.   :  0.00   Length:322         Length:322         Length:322        \n 1st Qu.: 80.25   Class :character   Class :character   Class :character  \n Median :160.50   Mode  :character   Mode  :character   Mode  :character  \n Mean   :160.50                                                           \n 3rd Qu.:240.75                                                           \n Max.   :321.00                                                           \n                                                                          \n  uicc_stage        tumor_stage            sex            ever_smoker       \n Length:322         Length:322         Length:322         Length:322        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n                                                                            \n driver_genes        condition              age          platform        \n Length:322         Length:322         Min.   :20.00   Length:322        \n Class :character   Class :character   1st Qu.:56.00   Class :character  \n Mode  :character   Mode  :character   Median :63.00   Mode  :character  \n                                       Mean   :60.73                     \n                                       3rd Qu.:69.00                     \n                                       Max.   :90.00                     \n                                       NA's   :89                        \n platform_fine       ...14         tissue: normal   tissue: normal_adjacent\n Length:322         Mode:logical   Min.   :0.0000   Min.   :0.0000         \n Class :character   NA's:322       1st Qu.:0.0000   1st Qu.:0.0000         \n Mode  :character                  Median :0.0000   Median :0.0000         \n                                   Mean   :0.2267   Mean   :0.3261         \n                                   3rd Qu.:0.0000   3rd Qu.:1.0000         \n                                   Max.   :1.0000   Max.   :1.0000         \n                                                                           \n tissue: tumor_primary tissue: tumor_metastasis technology_type   \n Min.   :0.0000        Min.   :0.0000           Length:322        \n 1st Qu.:0.0000        1st Qu.:0.0000           Class :character  \n Median :1.0000        Median :0.0000           Mode  :character  \n Mean   :0.5497        Mean   :0.1398                             \n 3rd Qu.:1.0000        3rd Qu.:0.0000                             \n Max.   :1.0000        Max.   :1.0000                             \n                                                                  \n\n\n\nsummary(df_example$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  20.00   56.00   63.00   60.73   69.00   90.00      89"
  },
  {
    "objectID": "precourse_preparations_R.html#pipe",
    "href": "precourse_preparations_R.html#pipe",
    "title": "Precourse Preparation",
    "section": "2.1 Pipe",
    "text": "2.1 Pipe\nA pipe is a type of operator in R: %&gt;%. It takes the output of one function and passes it as the first argument of the next function, allowing us to chain together several steps in R.\n\nCredit: tidyverse.org\nThe pipe sends the data on left side of the pipe to be the first argument of the function on the right side of the pipe.\n\n16 %&gt;% sqrt() # is equivalent to sqrt(16)\n\n[1] 4\n\n\nWe can pipe multiple functions together. The operations are performed from the left to the right sequentially.\n\n16 %&gt;% sqrt() %&gt;% log2() # is equivalent to log2(sqrt(16))\n\n[1] 2\n\n\nBelow you can find exercises with more examples of piping mathematical functions in R together.\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise: What would be the equivalent mathematical expression to below piped sequence of operations?\n\n\n26 %&gt;% -22 %&gt;% sqrt() %&gt;% +4\n\n[1] 6\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer:\n\n\nsqrt(26-22) + 4\n\n[1] 6\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise: How below mathematical operation can be shown with pipe option?\n\n\nsqrt(log2(64)) - 8\n\n[1] -5.55051\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer\n\n\n64 %&gt;% log2() %&gt;% sqrt() %&gt;% -8\n\n[1] -5.55051"
  },
  {
    "objectID": "precourse_preparations_R.html#example-data-1",
    "href": "precourse_preparations_R.html#example-data-1",
    "title": "Precourse Preparation",
    "section": "2.2 Example data",
    "text": "2.2 Example data\nIn this chapter we will work on expression matrix table which is one of the output files from BD Rhapsody Sequencing Analysis Pipeline.\nThe table is provided in csv format. Below is example of how to load the table.\n\nexpMat &lt;- fread(file = \"data/precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE)\n\n# file: provide full directory to file\n# sep: indicate separator, in this case coma\n# header = True is indicating to take the first row as a column names\n\nDisplaying first rows and columns of the table gives us a glimpse on what the data contain.\n\nexpMat[c(1:5),c(1:5)]\n\n         V1  A1BG A1BG.AS1  A1CF   A2M\n      &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1:  3261781     0        0     0     0\n2:  9155806     0        0     0     0\n3:  4304661     0        0     0     0\n4:  2216902     0        0     0     0\n5: 13160139     0        0     0     0\n\n\nThe gene names are displayed in columns and rows contain information about the cells. The column named V1 hold information about the cell index that is given to each cell in primary analysis.\nWe will set the V1 column as row names. In that way all the columns will contain the gene or protein counts.\n\n#use first column as row names\nexpMat &lt;- data.frame(expMat, row.names = 1)\n\nThe same set of above operations can be performed with pipe in one line of code. We read the file and convert first column to row names and save as data frame. The result is assigned to expMat variable by using the arrow.\n\n#pipe operations\nexpMat &lt;- fread(file = \"data/precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE) %&gt;% data.frame(row.names = 1)"
  },
  {
    "objectID": "precourse_preparations_R.html#select",
    "href": "precourse_preparations_R.html#select",
    "title": "Precourse Preparation",
    "section": "2.3 select()",
    "text": "2.3 select()\nFunctionality: Select only the columns (variables) that you want to see. Gets rid of all other columns.\nImagine you are interested to extract the data only for one gene existing in your dataset. You can use the gene name, for example “CD4”, to indicate in select function which column should be selected.\n\n# choosing the column of CD4 gene\nexpMat %&gt;% dplyr::select(\"CD4\") -&gt; CD4_column\n\nIn the table we work on, the protein and gene expression information are provided. All the protein markers are labeled with “pAbO” abbreviation, in addition to marker name. We can select all the columns that contain pAbO in name and save to new table.\n\n#choosing all the columns with AbSeq counts and saving to abseq_data\nexpMat %&gt;% dplyr::select(contains(\"pAbO\")) -&gt; abseq_data\n\nAll the columns that does not contain the “pAbO” are representing genes. To create a gene data, we can use the contains() function with exclamation mark as in below example.\nThe “!” is used for negation in R language and is interpreted as “do not”. Below expression will be interpreted as “select from expMat columns that do not contain pAbO.”.\n\n# choosing all columns that does not contain AbSeq counts (mRNA only)\nexpMat %&gt;% dplyr::select(!contains(\"pAbO\")) -&gt; mrna_data"
  },
  {
    "objectID": "precourse_preparations_R.html#mutate",
    "href": "precourse_preparations_R.html#mutate",
    "title": "Precourse Preparation",
    "section": "2.4 mutate()",
    "text": "2.4 mutate()\nFunctionality: Adds new columns or modifies current variables in the dataset.\nThe mutate function allows in easy way to add new columns in existing tables. Let’s say we want to add column named “measurement_type” and fill with “protein expression” in abseq data table we created in previous step.\n\n#add new column with the same value\nabseq_data %&gt;% mutate(data_modality = \"protein_expression\") -&gt; abseq_data \n\nThe new column will be added at the end of table. We can show the column by selecting the column name.\n\n#display results\nabseq_data %&gt;% dplyr::select(\"data_modality\") %&gt;% head\n\n              data_modality\n3261781  protein_expression\n9155806  protein_expression\n4304661  protein_expression\n2216902  protein_expression\n13160139 protein_expression\n11951658 protein_expression\n\n\nMutate function can be used in combination with other functions.\nIn this example we will calculate sum of expression count for each cell and store information in table. We summarize the counts from all rows ad add as a new column. The rowSums function is useful for calculating the sum of counts in each row.\n\nrowSums(mrna_data) -&gt; mRNA_count_sum\n\n#display results\nhead(mRNA_count_sum)\n\n 3261781  9155806  4304661  2216902 13160139 11951658 \n   35231    34733    33238    31618    31664    30786 \n\n\nAfter running rowSums we got for each cell the number of counts. The values can be added in mrna data table as a new column.\n\nmrna_data %&gt;% mutate(counts = mRNA_count_sum) -&gt; mrna_data\nmrna_data %&gt;% dplyr::select(counts) %&gt;% head\n\n         counts\n3261781   35231\n9155806   34733\n4304661   33238\n2216902   31618\n13160139  31664\n11951658  30786\n\n\nThe same result can be generated with option below, where the rowSums function is nested inside the mutate function.\n\nmrna_data %&gt;% mutate(counts = rowSums(mrna_data)) -&gt; mrna_data\n\nNotice that mrna_data is given twice in that case as an argument. The mrna_data is taken by mutate function as first argument and then in rowSums function as second argument.\nIn above example we used pipe to direct the mrna_data to mutate() function as argument. However the mrna_data was not forwarded by pipe to rowSums. For that reason we had to type it in the rowSums function. By default pipe operator forwards data only as first argument to a function. If you want the pipe to forward data as well as second (and next) argument to function you can use a dot.\n\nmrna_data %&gt;% mutate(counts = rowSums(.)) -&gt; mrna_data"
  },
  {
    "objectID": "precourse_preparations_R.html#summarise",
    "href": "precourse_preparations_R.html#summarise",
    "title": "Precourse Preparation",
    "section": "2.5 summarise()",
    "text": "2.5 summarise()\nFunctionality: Collapses all rows and returns a one-row summary.\nIn the example below, summarize function allow us to calculate the max/min, median and mean values for counts.\n\nmrna_data %&gt;% summarise(mean = mean(counts),    #mean counts\n                             median = median(counts),    #median counts\n                             max = max(counts),    #maximum count\n                             min = min(counts))   #minimum count\n\n      mean median    max  min\n1 9142.064   4392 105693 1146\n\n\nIn above summary we have the overview of the expression range and how minimum and maximum values of molecules expressed differ. Some of cells will have very low transcriptome size in comparison to others."
  },
  {
    "objectID": "precourse_preparations_R.html#if_else",
    "href": "precourse_preparations_R.html#if_else",
    "title": "Precourse Preparation",
    "section": "2.6 if_else()",
    "text": "2.6 if_else()\nThe if_else() function in R is a conditional function. It allows to test the hypothesis and perform actions based on answer.\nLet’s assume we want to label the cells according to transcriptom size. Based on threshold of counts we give a label of “low_transcriptome” or “high_transcriptome” for a cell status. We can make assumption that all cells with sum of counts lower then thousand are low transcriptome cells and remaining cells are categorized as high transcriptome cells.\nThe if_else function with combination of mutate will help us to achieve the goal.\nFirst we need to know what is the structure of if_else statement. The first argument of if_else function is the hypotheses or the statement. In our case we want to test if count for cell is below or above the threshold. Second argument of a function is an action to perform if the statement is true. Third argument of if_else function is an action to perform when the statement is false.\n\nIn our case the hypothesis to test is if counts in a cell are below or above the threshold. We can set the condition to have a counts above 2000. If the counts are above the threshold the statement is true. When the statement is true the action is to set the label as “high_transcriptome”. When the statement is false we set the label as “low_transciptome”.\n\nif_else(mrna_data$counts &gt; 2000, \"high_transcriptome\", \"low_transcriptome\") -&gt; cell_status\n\nIn that way we created a cell status for cells based on counts. We should see in a cell_status that was generated two labels. To verify if that is the case we can display unique values of a created vector.\n\nunique(cell_status)\n\n[1] \"high_transcriptome\" \"low_transcriptome\" \n\n\nIf we would like to add that information as a new column to data table, we can use mutate function as in previous examples.\n\n#calcuate and add cell_status to mrna table\nmrna_data %&gt;% mutate(cell_status = if_else(mrna_data[\"counts\"] &gt; 2000, \"high_transcriptome\", \"low_transcriptome\")) -&gt; mrna_data\n\n#display cell status column \nmrna_data %&gt;% dplyr::select(cell_status) %&gt;% head\n\n                cell_status\n3261781  high_transcriptome\n9155806  high_transcriptome\n4304661  high_transcriptome\n2216902  high_transcriptome\n13160139 high_transcriptome\n11951658 high_transcriptome"
  },
  {
    "objectID": "precourse_preparations_R.html#count",
    "href": "precourse_preparations_R.html#count",
    "title": "Precourse Preparation",
    "section": "2.7 count()",
    "text": "2.7 count()\nFunctionality: Collapses the rows and counts the number of observations per group of values.\nThe count function is a quick way to have an overview on number of occurrences. For example to we can use count() to see how many cells were categorized as low or high transcriptome cells.\n\nmrna_data %&gt;% count(cell_status)\n\n         cell_status    n\n1 high_transcriptome 5204\n2  low_transcriptome  597\n\n\nThe function works on text as well as on numbers. In below example, the result summarizes the number of occurrences (rows) having a different counts for CD3.\n\nmrna_data %&gt;% count(CD4)\n\n   CD4    n\n1    0 4457\n2    1  664\n3    2  276\n4    3  152\n5    4   79\n6    5   59\n7    6   40\n8    7   32\n9    8   21\n10   9    9\n11  10    6\n12  11    2\n13  12    1\n14  14    1\n15  17    1\n16  18    1\n\n\nWe interpret the result in following way: there was 4457 rows with zero count for CD4. In other words, there was 4457 cells with zero count for CD4."
  },
  {
    "objectID": "precourse_preparations_R.html#group_by",
    "href": "precourse_preparations_R.html#group_by",
    "title": "Precourse Preparation",
    "section": "2.8 group_by()",
    "text": "2.8 group_by()\nFunctionality: Takes existing data and groups specific variables together for future operations.\nThe group() function takes an existing table and convert it into grouped table where operations are performed by group.\nLet’s have a look into following example and assume that we want to compare the mean and median counts for low and high transcriptome cells. In that case we can group data by cell status and calculate average values for those groups.\n\nmrna_data %&gt;% \n  group_by(cell_status) %&gt;% \n  summarize(mean = mean(counts),\n            median = median(counts),\n            n = n())  #calculates the total number of observations\n\n# A tibble: 2 × 4\n  cell_status          mean median     n\n  &lt;chr&gt;               &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;\n1 high_transcriptome 10006.  4684.  5204\n2 low_transcriptome   1611.  1638    597\n\n\nIn the above code, we have grouped by cell status, meaning that calculations performed on our data will account for high transcriptome and low transcriptome cells separately. Following code execution, the console displays the mean count, the median count and the total number of cells (n()) for low transcriptome and for high transcriptome cells (group_by(cell_status))."
  },
  {
    "objectID": "precourse_preparations_R.html#filter",
    "href": "precourse_preparations_R.html#filter",
    "title": "Precourse Preparation",
    "section": "2.8 filter()",
    "text": "2.8 filter()\nFunctionality: Only retain specific rows of data that meet the specified requirement(s).\nFilter function display from the data values that meet defined condition. For example, we can filter all cells with low transcriptome cell status and retain only high transcriptome cells.\n\nmrna_data %&gt;% filter(cell_status == \"high_transcriptome\") -&gt; signal_cells\n\n#display last column\nsignal_cells %&gt;% dplyr::select(last_col()) %&gt;% head\n\n         cell_status\n1 high_transcriptome\n2 high_transcriptome\n3 high_transcriptome\n4 high_transcriptome\n5 high_transcriptome\n6 high_transcriptome"
  },
  {
    "objectID": "precourse_preparations_R.html#rename",
    "href": "precourse_preparations_R.html#rename",
    "title": "Precourse Preparation",
    "section": "2.9 rename()",
    "text": "2.9 rename()\nFunctionality: Renames a column/variable by name and index.\nRenames the cell_status variable as SIGNAL_CELLS (notice that the new label goes first in the argument).\n\nmrna_data %&gt;% rename(SIGNAL_CELLS = cell_status) -&gt; mrna_data\n\n#display results\nmrna_data %&gt;% dplyr::select(last_col()) %&gt;% head #chose last column from mrna_data\n\n               SIGNAL_CELLS\n3261781  high_transcriptome\n9155806  high_transcriptome\n4304661  high_transcriptome\n2216902  high_transcriptome\n13160139 high_transcriptome\n11951658 high_transcriptome"
  },
  {
    "objectID": "precourse_preparations_R.html#seurat-object-structure",
    "href": "precourse_preparations_R.html#seurat-object-structure",
    "title": "Precourse Preparation",
    "section": "3.1 Seurat Object Structure",
    "text": "3.1 Seurat Object Structure\nSeurat object stores information about the single cell multiomics data and the analysis that was done during downstream workflow. As we move through the workflow and make calculations, the results are added to Seurat object and stored in different “boxes”. Those different “boxes” are called slots.\nLet’s load the Seurat object into R. We will use the Seurat object that is created during workshop in first step, prior to proceeding with next analysis steps, as normalization, clustering etc.\n\nseurat.obj_00 &lt;- readRDS(\"data/precourse_preparation_data/example_seuratObj.rds\")\n\nLoaded Seurat object was created including mRNA counts table obtained from primary analysis. While Seurat object is generated the following information are added to Seurat slots by default: assays, meta data, active assay, active identity, project name and version.\n\nThe remaining Seurat slots highlighted in grey are empty and filled in with information while it is calculated over analysis."
  },
  {
    "objectID": "precourse_preparations_R.html#assays",
    "href": "precourse_preparations_R.html#assays",
    "title": "Precourse Preparation",
    "section": "3.2 Assays",
    "text": "3.2 Assays\nThe assays slot contain different assays loaded into Seurat object. Those can be for example mRNA expression data or protein expression data. The assay slot contains layers that stores ‘transformations’ of the data, including raw counts (counts slot), normalized data (data slot), and scaled data for dimensional reduction (scale.data slot)\nThe assays layers can be listed by Layers(). The layer content can be accessed by function LayerData. In example below we access the data layer from assay slot and display it as data frame.\n\nLayerData(seurat.obj_00, assay = \"RNA\", layer = \"counts\") %&gt;% \n  .[1:10, 1:10]\n\n10 x 10 sparse Matrix of class \"dgCMatrix\"\n                             \nA1BG      . . . . . . . . . .\nA1BG-AS1  . . . . . . . . . .\nA1CF      . . . . . . . . . .\nA2M       . . . . . . . . . .\nA2M-AS1   . . . . . . . . . .\nA2ML1     . . . . . . . . . .\nA2ML1-AS1 . . . . . . . . . .\nA2ML1-AS2 . . . . . . . . . .\nA2MP1     . . . . . . . . . .\nA3GALT2   . . . . . . . . . .\n\n\nIn current Seurat object we have one layer for active RNA assay\n\nLayers(seurat.obj_00)\n\n[1] \"counts\"\n\n\nAdditional layers will be added while analysis is done. For example, when data are normalized or scaled the “data” and “scale.data” layers are added to the object.\n\nseurat.obj_00 &lt;- NormalizeData(seurat.obj_00)\nseurat.obj_00 &lt;- ScaleData(seurat.obj_00)"
  },
  {
    "objectID": "precourse_preparations_R.html#meta-data",
    "href": "precourse_preparations_R.html#meta-data",
    "title": "Precourse Preparation",
    "section": "3.3 Meta Data",
    "text": "3.3 Meta Data\nMeta.data slot stores information calculated for cells as for example number of features in each cell, number of counts or cell clusters calculated in downstream process.\nThe meta.data information is stored in a table that can be accessed in Seurat object as below.\n\nseurat.obj_00[[]] %&gt;% \n  .[1:10, ]\n\n        orig.ident nCount_RNA nFeature_RNA nCount_AbO nFeature_AbO\n3091 SeuratProject       2191         1133       9310           35\n3517 SeuratProject       3051         1324       8566           36\n3921 SeuratProject       1672          951       9324           36\n4283 SeuratProject       2091         1117      11314           38\n4318 SeuratProject       2330         1220      12217           36\n5027 SeuratProject       1942         1087       7923           34\n5088 SeuratProject       1784         1045       7025           33\n5418 SeuratProject       2813         1451       7061           36\n5763 SeuratProject       1812          966       2328           33\n5768 SeuratProject       3126         1429      12918           38\n\n\nTo view list of all available meta.data in Seurat object we can view the column names from the data table.\n\nseurat.obj_00[[]] %&gt;% colnames() %&gt;% head\n\n[1] \"orig.ident\"   \"nCount_RNA\"   \"nFeature_RNA\" \"nCount_AbO\"   \"nFeature_AbO\"\n\n\nWe can extract information of interest from data table by indicating to chosen column names.\n\nseurat.obj_00[[c(\"nCount_AbO\", \"nFeature_RNA\")]] %&gt;% \n  .[1:10, ]\n\n     nCount_AbO nFeature_RNA\n3091       9310         1133\n3517       8566         1324\n3921       9324          951\n4283      11314         1117\n4318      12217         1220\n5027       7923         1087\n5088       7025         1045\n5418       7061         1451\n5763       2328          966\n5768      12918         1429\n\n\nIt is possible to add new information to meta data. It can be any information about the cells as experimental batch or sub-population identity.\n\n#add meta data\nseurat.obj_00 &lt;- AddMetaData(seurat.obj_00, #indicate object\n            \"experiment_1\", #metadata to be added\n            \"batch\") #column name for metadata\n\n#display results\nseurat.obj_00[[c(\"batch\")]] %&gt;% \n  .[1:10, ]\n\n [1] \"experiment_1\" \"experiment_1\" \"experiment_1\" \"experiment_1\" \"experiment_1\"\n [6] \"experiment_1\" \"experiment_1\" \"experiment_1\" \"experiment_1\" \"experiment_1\""
  }
]