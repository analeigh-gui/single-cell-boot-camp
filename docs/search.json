[
  {
    "objectID": "01_data_import.html",
    "href": "01_data_import.html",
    "title": "Chapter 1 Data Import",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\n\nDemo data\nThe demo data is generated from freshly isolated human PBMCs. The PBMCs were grown for 24 hours in the presence of CD3/CD28 stimulation (“treated”) and compared to PBMCs grown for 24 hours in regular media (“naive”). Cells were then labeled with a 20plex AbSeq panel consisting of lineage markers and T-cell activation markers, as well as unique Sample Tags from the BD Rhapsody™ Human Single Cell Multiplexing Kit (resting PBMC: ST1; treated PBMC: ST2). The cells were mixed at a 1:1 ratio and processed using the BD Rhapsody™ Single-Cell Analysis System. Sequencing libraries for RNA and AbSeq antibodies were generated using the BD Rhapsody WTA Amplification kit.\n\n\n\n\n\n\nNote\n\n\n\nPlease review the setup chapter to ensure that R packages are installed and the demo data (in folder “raw_data”) is downloaded.\n\n\n1. Data import\nThe expression matrix stores the UMI counts of a feature (gene or protein). Depending on the single cell platform, common format of expression matrix include CSV, MEX (Market Exchange) or H5AD.\nRhapsody single cell platform outputs expression matrix in two formats: MEX and H5AD.\nWe import MEX using the function from Seurat, Read10x. We assign a name to the created object, expMat (expression Matrix).\n\nexpMat &lt;- Read10X(\"data/raw_data/WTA-AB-SMK-v2-0_DBEC_MolsPerCell_MEX/\",\n                  gene.column = 2,\n                  cell.column = 1,\n                  unique.features = TRUE)\n\nClick on the expMat on the right.\n\nA window will pop up and you should be able to see the structure of expMat.\n\nexpMat contains two matrices: Gene Expression and Antibody Capture. You may recall that the demo dataset has two assays: WTA, whole transcriptome analysis, to capture Gene Expression; and AbSeq for Antibody Capture.\nWe will first focus on Gene Expression.\nTake a look at the first 5 rows X first 5 columns of Gene Expression matrix. It is organized as feature X cell. The row names are gene names. The column names are cell labels.\n\nexpMat$`Gene Expression`[1:5, 1:5]\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n         74 391 440 1222 2690\nA1BG      .   .   .    .    .\nA1BG-AS1  .   .   .    .    .\nA1CF      .   .   .    .    .\nA2M       .   .   .    .    .\nA2M-AS1   .   .   .    .    .\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhat are the dots “.” in the matrix?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe “.” corresponds to 0.\nscRNA-seq usually contains many zeros. The zeros can come from:\n\nStochastic gene expression.\nLimitation of single cell technology: On average, 5 - 8% of mRNA transcripts can be captured by the technology.\n\n\n\n\n2. Create a Seurat object to store Gene Expression\nLet’s create a Seurat object to store Gene Expression and assign “rna” as the object name.\n\nrna &lt;- Seurat::CreateSeuratObject(counts = expMat$`Gene Expression`, \n                                min.cells = 1, \n                                min.features = 100, \n                                assay = \"RNA\")\n\nmin.cells Specify the minimum number of cells that needs to be detected per feature. Setting this argument will filter out zero or lowly expressed features.\nmin.features Specify the minimum number of features that need to be detected per cell. Setting this argument will filter out cell labels with low feature counts.\nassay Specify the name of the created assay. By default, it is “RNA”.\n\n\n\n\n\n\nNote\n\n\n\nCreateSeuratObject has many arguments in the function. These arguments allow users to control the behavior of the function. One can look at the Help tab to see the arguments and their default settings.\n\n\n\n\n\n\n\n\n\nFunction notation with ::\n\n\n\nHere, we define the function together with its associated package. We do that by the syntax package::function. Of course, you can also call library(package), and only type the function name. Since we use many different packages in this course, it can be confusing which function comes from which package. Therefore, we associate the package with the called function.\n\n\nWhen creating a Seurat object, Seurat automatically creates some metadata for each cell. This information is stored in the meta.data slot.\n\nrna@meta.data %&gt;% head\n\n        orig.ident nCount_RNA nFeature_RNA\n74   SeuratProject       2389         1135\n391  SeuratProject       5252         2088\n440  SeuratProject       1205          630\n1222 SeuratProject       2390         1152\n2690 SeuratProject       1533          810\n2782 SeuratProject       1106          105\n\n\nmeta.data stores information related to each cell. We will add more information into the meta.data later. For now, it contains three columns:\n\norig.ident Sample identity or sample name. By default, it is “SeuratProject”.\nnCount_RNA UMI counts per gene per cell.\nnFeature_RNA Genes counts per cell.\n3. Add sample multiplexing kit into meta.data\n\nThe demo dataset has Sample Multiplexing Kit (SMK) to pool two samples on one cartridge.\nTo demultiplex the samples, one can use the table “Demo-WTA-AbSeq-SMK_Sample_Tag_Calls.csv”.\n\nsmk &lt;- fread(file = \"data/raw_data/WTA-AB-SMK-v2-0_Sample_Tag_Calls.csv\", \n                     sep = \",\", \n                     header=TRUE) %&gt;% \n  data.frame(row.names = 1)\n\nLet’s look at the first 5 rows of the created object smk.\n\nsmk[1:5, ]\n\n         Sample_Tag Sample_Name\n74   SampleTag01_hs       naive\n391  SampleTag02_hs     treated\n440  SampleTag01_hs       naive\n1222 SampleTag01_hs       naive\n2690 SampleTag01_hs       naive\n\n\nsmk is a matrix with two columns. The row names are the cell labels.\n\nSample_Tag: Which tag the cell belongs to.\nSample_Name: Which sample the cell belongs to.\n\nWe can add the cell assignment into the meta.data of the Seurat object by AddMetaData.\n\nrna &lt;- AddMetaData(object = rna, metadata = smk)\n\n\nrna@meta.data %&gt;% head()\n\n        orig.ident nCount_RNA nFeature_RNA     Sample_Tag Sample_Name\n74   SeuratProject       2389         1135 SampleTag01_hs       naive\n391  SeuratProject       5252         2088 SampleTag02_hs     treated\n440  SeuratProject       1205          630 SampleTag01_hs       naive\n1222 SeuratProject       2390         1152 SampleTag01_hs       naive\n2690 SeuratProject       1533          810 SampleTag01_hs       naive\n2782 SeuratProject       1106          105      Multiplet   Multiplet\n\n\nNow we know which cell belongs to which sample.\n4. Remove Multiplet and Undetermined\nThe Multiplet are cell labels with more than one SMK tags. They could be Multiplets from one microwell containing two cells, or single cells with high ambient SMK noise.\nThe Undetermined are cell labels without sufficient SMK tag reads. They could be noisy cell labels, or single cells without SMK tag reads.\n\nrna@meta.data %&gt;% \n  group_by(Sample_Name) %&gt;% \n  tally() %&gt;% \n  mutate(pct = n/sum(n)) %&gt;% \n  ggplot(aes(x=Sample_Name, y=n, fill= Sample_Name)) + \n  geom_bar(stat = \"identity\") +\n  geom_text(aes(y = n,\n                label = paste0(n, \"\\n\", scales::percent(pct)),\n                vjust= -0.5, size = 2.5), show.legend = FALSE) + \n  theme_classic()\n\n\n\n\nMultiplet and Undetermined are removed from the downstream analysis by subset.\n\nrna &lt;- subset(rna, subset = Sample_Name %in% c(\"Multiplet\", \"Undetermined\"), invert = T)\n\n5. Save\nSave the files into RData for documentation.\n\n# save.image(\"data/intermediate_data/chapter1.RData\")"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Introduction",
    "section": "",
    "text": "How to use the materials?\nThis repository contains the teaching materials for the Single Cell Boot Camp - Analyzing scRNA-seq with R.\nIt has:\nTwo chapters of precourse preparation: Precourse Preparation - R / Theory\nNine chapters of the analysis workflow: Chapter 1 - 9.\n\n\n\n\n\n\nImportant\n\n\n\nStudents who go through the teaching materials and run the code on their local desktops will have a much better learning outcome.\nAs we are NOT going to cover the R programming and SOLELY focusing on the analysis workflow, this is particularly important for students who are not familiar with R. So, please do block some time and try to digest the materials before attending the Boot Camp.\nIf you are familiar with R, you can skip the Precourse Preparation and jump to Chapter 1 - 9.\n\n\nFor further information, suggestions and bug report, please contact: biox_support_emea@bd.com\n\n\nDescription\nThe Single Cell Boot Camp: Analysis of scRNA-seq with R is to provide an overview of the analysis of single-cell RNA-seq using R. It is designed for early-stage researchers who want to adopt single-cell analysis in their toolbox. The workshop consists of theory in presentation and application in hands-on practice.\nThe workshop starts with a fast-paced training session on the common workflow of single-cell RNA-seq analysis, then continues with sessions on the common workflow of scRNA-seq using bioinformatics packages like Seurat.\n\n\nPrerequisites\nEach participant are expected to have:\n1. An introductory background in statistics, specifically in the below concepts: Median, log2 fold change, p-value, adjusted p-value, variance, PCA.\n2. Basic familiarity with R and tidyr package, specifically in the below functions: %&gt;% (pipe), filter, mutate, pivot_longer, pivot_wider, map, pmap, select, left_join.\nIf you would like to learn on your own with publicly available resources:\nChapter 1 - 4 from MordernDive.\n\nIf you would like to participate in an instructor-led R course:\nR for Biologist from Edinburgh Genomics. For details, please contact Edinburgh Genomics.\n\n\nExpected outcome\nBy the end of the workshop, participants will be familiar with the following topics: Common workflow of single cell analysis (pre-processing, quality control, filtering, normalization, Clustering, Cell type annotation).\n\n\nReference\nThe building of materials for the course references and relies on many excellent and well written public avaialbe materials.\n\nSeurat https://satijalab.org/seurat/\nSingle Cell Best Practices: https://www.sc-best-practices.org/preamble.html\nOrchestrating Single-Cell Analysis with Bioconductor: https://bioconductor.org/books/release/OSCA/\nMary Piper, Meeta Mistry, Jihe Liu, William Gammerdinger, & Radhika Khetani. (2022, January 6). hbctraining/scRNA-seq_online: scRNA-seq Lessons from HCBC (first release). Zenodo. https://doi.org/10.5281/zenodo.5826256\n\n\n\nDisclaimer\nRecommendations given by representatives of BD in the context of the creation and setup of customer-specific applications and assays, the composition of antibody panels and suggestions for data analysis are provided in a diligent manner. However, the Customer acknowledges that (i) such recommendations should not be treated as a substitute for the Customer’s own examination, (ii) BD does not make any promises nor guarantees that recommendations are accurate and complete and will meet the Customer’s present or future needs or will produce positive or specific results and (iii) Customer remains solely responsible for validating and deciding on any such recommendations.\nBD therefore accepts no liability whatsoever in connection with any such recommendation and/or any results generated on the basis of such recommendations and, to the fullest extent permitted by law, expressly disclaims any and all warranties and any liability in this respect. In particular, the Customer assumes sole responsibility for the validation, use, selection, and suitability of the recommendations for its needs and objectives.\n\n\nLicense\nSee the LICENSE file for license rights and limitations (MIT)."
  },
  {
    "objectID": "precourse_preparation_R.html",
    "href": "precourse_preparation_R.html",
    "title": "Precourse Preparation - R",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(readxl)\nlibrary(data.table)\nlibrary(tidyverse)\nlibrary(Seurat)"
  },
  {
    "objectID": "precourse_preparation_R.html#what-is-data-frame",
    "href": "precourse_preparation_R.html#what-is-data-frame",
    "title": "Precourse Preparation - R",
    "section": "1.1 What is data frame",
    "text": "1.1 What is data frame\nData frame is data structure in R that store values of any type. You can think of it as a table with columns and rows storing the data as in below example.\n\nCredit: https://www.geeksforgeeks.org/r-data-frames/\nOften in data science language the columns are named as variables, the rows are observations and each entry in a table is a value.\nSome of the most common examples of input files that can be loaded into R as data frames are spreadsheets, TSVs, CSVs files. TSV and CSV stands for tab-separated or coma-separated values.\nAnother way to view data frame is as list of vectors of the same length. The vector can be defined as type of data structure that contains elements of the same type. Below you can find example on how create the table presented in Figure 1 from vectors.\n\n#define vectors which will create columns with data in data frame\n\n## Vector of names\nName &lt;- c(\"Avrey Bradley\",\"John Holland\",\"Jonas Jerebko\",\"Jordan Midkey\",\"Terry Rozier\",\"Jared Sullinger\",\"Evan Turner\")\n\n## Vector of team's names\nTeam &lt;- c(\"Boston Celtics\", \"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\")\n\n## Vector of values\nNumber &lt;- c(0.0,30.0,8.0,NaN,12.0,7.0,11.0)\n\n## Vector of positions\nPosition &lt;- c(\"PG\",\"SG\",\"PF\",\"PF\",\"PG\",\"C\",\"SG\")\n\n## Vector of age\nAge &lt;- c(25.0,27.0,29.0,21.0,22.0,NaN,27.0)\n\n#create data frame from vectors\ndata.frame(Name,Team,Number,Position,Age)\n\n             Name           Team Number Position Age\n1   Avrey Bradley Boston Celtics      0       PG  25\n2    John Holland Boston Celtics     30       SG  27\n3   Jonas Jerebko Boston Celtics      8       PF  29\n4   Jordan Midkey Boston Celtics    NaN       PF  21\n5    Terry Rozier Boston Celtics     12       PG  22\n6 Jared Sullinger Boston Celtics      7        C NaN\n7     Evan Turner Boston Celtics     11       SG  27"
  },
  {
    "objectID": "precourse_preparation_R.html#convenient-version-of-data-frame-tibble",
    "href": "precourse_preparation_R.html#convenient-version-of-data-frame-tibble",
    "title": "Precourse Preparation - R",
    "section": "1.2 Convenient version of data frame: “Tibble”",
    "text": "1.2 Convenient version of data frame: “Tibble”\nThe tibble is a package that manipulates data frames. The tibble type of table looks like a data frame but has some advantages over using regular data frames.\nFor example, while loading data as a classical data frame, the spaces in names are converted to periods or “x” before numeric columns is added. While using tibbles, the input names and data types remain unchanged. In this tutorial, we will work mainly with tibble data frame type."
  },
  {
    "objectID": "precourse_preparation_R.html#working-with-data-frames-in-r",
    "href": "precourse_preparation_R.html#working-with-data-frames-in-r",
    "title": "Precourse Preparation - R",
    "section": "1.3 Working with data frames in R",
    "text": "1.3 Working with data frames in R\n1.3.1 Example data\nIn this part of tutorial, we will work on table downloaded from supplementary data of Salcher, Stefan et al. (doi:10.1016/j.ccell.2022.10.008). The table contains the metadata of patients for which samples were processed on different single-cell platforms.\nThe example data required by this chapter is available at the precourse_preparation_data in Data.\n1.3.2 Loading data\nDepending on the input format, there are different dedicated libraries to load data into R. Here we start from excel spreadsheet and use function from readxl library. The readxl library is part of tidyverse package that will be covered in second chapter of this tutorial.\n\ndf_example &lt;- read_excel(\"data/precourse_preparation_data/mmc4.xlsx\", skip = 2)\n\nNOTE:\n\nThe two first rows in the original table are empty, so we skip them when loading.\nOne of the columns in excel spreadsheet is empty (column N). The R assign automatically the default name ..1 to that column and keep it within the data frame.\nAll the missing entries in rows will be filled with “NA” values automatically.\n1.3.3 Viewing the content\nThere are different ways to view the content of data frame. You can directly click on df_example to display the content.\nThe str function lists directly in the console: the type of data (tibble), dimensions (322x18), columns with first values displayed and type of values.\n\nstr(df_example)\n\ntibble [322 × 18] (S3: tbl_df/tbl/data.frame)\n $ ...1                    : num [1:322] 0 1 2 3 4 5 6 7 8 9 ...\n $ study                   : chr [1:322] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" ...\n $ dataset                 : chr [1:322] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" ...\n $ patient                 : chr [1:322] \"Adams_Kaminski_2020_001C\" \"Adams_Kaminski_2020_002C\" \"Adams_Kaminski_2020_003C\" \"Adams_Kaminski_2020_8CO\" ...\n $ uicc_stage              : chr [1:322] NA NA NA NA ...\n $ tumor_stage             : chr [1:322] NA NA NA NA ...\n $ sex                     : chr [1:322] \"male\" \"female\" \"female\" \"male\" ...\n $ ever_smoker             : chr [1:322] \"no\" \"no\" \"no\" \"yes\" ...\n $ driver_genes            : chr [1:322] NA NA NA NA ...\n $ condition               : chr [1:322] \"non-cancer\" \"non-cancer\" \"non-cancer\" \"COPD\" ...\n $ age                     : num [1:322] 22 25 67 65 66 49 62 57 66 20 ...\n $ platform                : chr [1:322] \"10x\" \"10x\" \"10x\" \"10x\" ...\n $ platform_fine           : chr [1:322] \"10x_3p_v2\" \"10x_3p_v2\" \"10x_3p_v2\" \"10x_3p_v2\" ...\n $ ...14                   : logi [1:322] NA NA NA NA NA NA ...\n $ tissue: normal          : num [1:322] 1 1 1 1 1 1 1 1 1 1 ...\n $ tissue: normal_adjacent : num [1:322] 0 0 0 0 0 0 0 0 0 0 ...\n $ tissue: tumor_primary   : num [1:322] 0 0 0 0 0 0 0 0 0 0 ...\n $ tissue: tumor_metastasis: num [1:322] 0 0 0 0 0 0 0 0 0 0 ...\n\n\n1.3.4 Extracting information\nExtracting data from a data frame means to access its rows or columns. First let’s list all columns available in the data frame.\n\ncolnames(df_example)\n\n [1] \"...1\"                     \"study\"                   \n [3] \"dataset\"                  \"patient\"                 \n [5] \"uicc_stage\"               \"tumor_stage\"             \n [7] \"sex\"                      \"ever_smoker\"             \n [9] \"driver_genes\"             \"condition\"               \n[11] \"age\"                      \"platform\"                \n[13] \"platform_fine\"            \"...14\"                   \n[15] \"tissue: normal\"           \"tissue: normal_adjacent\" \n[17] \"tissue: tumor_primary\"    \"tissue: tumor_metastasis\"\n\n\nTo extract values from single column of the data frame, different options can be used.\n\nUsing $ operator and providing the column name\n\n\ndf_example$study %&gt;% head # head allows to display first few elements \n\n[1] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n[4] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n\n\n\nUsing [[]] and providing column number (index)\n\n\ndf_example[[2]] %&gt;% head() # disply the first 6 elements in column 2\n\n[1] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n[4] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n\n\n\nUsing column name\n\n\ndf_example[, \"study\"] %&gt;% head\n\n# A tibble: 6 × 1\n  study              \n  &lt;chr&gt;              \n1 Adams_Kaminski_2020\n2 Adams_Kaminski_2020\n3 Adams_Kaminski_2020\n4 Adams_Kaminski_2020\n5 Adams_Kaminski_2020\n6 Adams_Kaminski_2020\n\n\nTo extract multiple columns or rows at the same time, the following rules apply:\n\n\nExtract rows range, include all columns.\n\n\ndf_example[c(2:4), ] #display rows from 2-4 and all columns\n\n# A tibble: 3 × 18\n   ...1 study           dataset patient uicc_stage tumor_stage sex   ever_smoker\n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;      \n1     1 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n2     2 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n3     3 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  yes        \n# ℹ 10 more variables: driver_genes &lt;chr&gt;, condition &lt;chr&gt;, age &lt;dbl&gt;,\n#   platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\n\nExtract rows, include all columns.\n\n\ndf_example[c(2,4),] #display rows 2 AND 4 and all columns\n\n# A tibble: 2 × 18\n   ...1 study           dataset patient uicc_stage tumor_stage sex   ever_smoker\n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;      \n1     1 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n2     3 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  yes        \n# ℹ 10 more variables: driver_genes &lt;chr&gt;, condition &lt;chr&gt;, age &lt;dbl&gt;,\n#   platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\n\nExtract columns range, include all rows.\n\n\ndf_example[, c(2:4)] %&gt;% head #display columns from 2-4\n\n# A tibble: 6 × 3\n  study               dataset             patient                 \n  &lt;chr&gt;               &lt;chr&gt;               &lt;chr&gt;                   \n1 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_001C\n2 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_002C\n3 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_003C\n4 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_8CO \n5 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_23CO\n6 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_034C\n\n\n\nExtract columns, include all rows.\n\n\ndf_example[, c(2,4)] %&gt;% head #display columns 2 AND 4\n\n# A tibble: 6 × 2\n  study               patient                 \n  &lt;chr&gt;               &lt;chr&gt;                   \n1 Adams_Kaminski_2020 Adams_Kaminski_2020_001C\n2 Adams_Kaminski_2020 Adams_Kaminski_2020_002C\n3 Adams_Kaminski_2020 Adams_Kaminski_2020_003C\n4 Adams_Kaminski_2020 Adams_Kaminski_2020_8CO \n5 Adams_Kaminski_2020 Adams_Kaminski_2020_23CO\n6 Adams_Kaminski_2020 Adams_Kaminski_2020_034C\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise\n\nExtract rows from 5-10 and columns from 3-8.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer\n\n\ndf_example[c(5:10), c(3,8)]\n\n\n\n\n1.3.4 Modifying information\nThe columns or rows can be removed or added to data frame as needed. It is possible to drop specific columns indicating the column indexes.\n\nmodified_df_example &lt;- df_example[, -c(1,2,5)]    # Drop columns 1,2,5\n\nThe same principle apply to excluding the rows\n\nmodified_df_example &lt;- df_example[-c(1,2,5),]     # Drop rows 1,2,5\n\nWe can remove column with specific names. To drop column, we chose all the columns (called by “colnames”) except (!=) “patient”.\n\nmodified_df_example &lt;- df_example[ , colnames(df_example) != \"patient\"]    # Drop column \"patient\"\n\nWe can also add columns into data frame. To add new column, use $ to indicate the column name for a new column as in the example below.\nHere we assign the values from already existing column to a new column. The new column is added at the end of the data table.\n\ndf_example$technology_type &lt;- df_example$platform # add new column named \"technology_type\" with values from \"platform\" existing column\n\nThe values from chosen column can be replaced with other values. In example below we search in df_example data frame in technology_type column for rows that contain “BD-Rhapsody” text. For those values we assign “microwell-based”.\n\ndf_example$technology_type[df_example$technology_type == \"BD-Rhapsody\"] &lt;- \"microwell-based\"\ndf_example$technology_type[df_example$technology_type == \"10x\"] &lt;- \"droplet-based\"\n\ndf_example[,c(\"platform\",\"technology_type\")] %&gt;% head #display columns\n\n# A tibble: 6 × 2\n  platform technology_type\n  &lt;chr&gt;    &lt;chr&gt;          \n1 10x      droplet-based  \n2 10x      droplet-based  \n3 10x      droplet-based  \n4 10x      droplet-based  \n5 10x      droplet-based  \n6 10x      droplet-based  \n\n\nThe last useful function to cover in this chapter is summary(). The function gives the statistical summary of each of the columns when applied on data frame. It can be applied on slice of data as for example only on one column or chosen columns and rows.\n\nsummary(df_example)\n\n      ...1           study             dataset            patient         \n Min.   :  0.00   Length:322         Length:322         Length:322        \n 1st Qu.: 80.25   Class :character   Class :character   Class :character  \n Median :160.50   Mode  :character   Mode  :character   Mode  :character  \n Mean   :160.50                                                           \n 3rd Qu.:240.75                                                           \n Max.   :321.00                                                           \n                                                                          \n  uicc_stage        tumor_stage            sex            ever_smoker       \n Length:322         Length:322         Length:322         Length:322        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n                                                                            \n driver_genes        condition              age          platform        \n Length:322         Length:322         Min.   :20.00   Length:322        \n Class :character   Class :character   1st Qu.:56.00   Class :character  \n Mode  :character   Mode  :character   Median :63.00   Mode  :character  \n                                       Mean   :60.73                     \n                                       3rd Qu.:69.00                     \n                                       Max.   :90.00                     \n                                       NA's   :89                        \n platform_fine       ...14         tissue: normal   tissue: normal_adjacent\n Length:322         Mode:logical   Min.   :0.0000   Min.   :0.0000         \n Class :character   NA's:322       1st Qu.:0.0000   1st Qu.:0.0000         \n Mode  :character                  Median :0.0000   Median :0.0000         \n                                   Mean   :0.2267   Mean   :0.3261         \n                                   3rd Qu.:0.0000   3rd Qu.:1.0000         \n                                   Max.   :1.0000   Max.   :1.0000         \n                                                                           \n tissue: tumor_primary tissue: tumor_metastasis technology_type   \n Min.   :0.0000        Min.   :0.0000           Length:322        \n 1st Qu.:0.0000        1st Qu.:0.0000           Class :character  \n Median :1.0000        Median :0.0000           Mode  :character  \n Mean   :0.5497        Mean   :0.1398                             \n 3rd Qu.:1.0000        3rd Qu.:0.0000                             \n Max.   :1.0000        Max.   :1.0000                             \n                                                                  \n\n\n\nsummary(df_example$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  20.00   56.00   63.00   60.73   69.00   90.00      89"
  },
  {
    "objectID": "precourse_preparation_R.html#pipe",
    "href": "precourse_preparation_R.html#pipe",
    "title": "Precourse Preparation - R",
    "section": "2.1 Pipe",
    "text": "2.1 Pipe\nA pipe %&gt;% is a type of operator in tidyverse. It takes the output of one function and passes it as the first argument of the next function, allowing us to chain together several steps in R.\n\nCredit: tidyverse.org\nThe pipe sends the data on left side of the pipe to be the first argument of the function on the right side of the pipe.\n\n16 %&gt;% sqrt() # is equivalent to sqrt(16)\n\n[1] 4\n\n\nWe can pipe multiple functions together. The operations are performed from the left to the right sequentially.\n\n16 %&gt;% sqrt() %&gt;% log2() # is equivalent to log2(sqrt(16))\n\n[1] 2\n\n\nBelow you can find exercises with more examples of piping mathematical functions in R together.\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise: What would be the equivalent mathematical expression to below piped sequence of operations?\n\n\n26 %&gt;% -22 %&gt;% sqrt() %&gt;% +4\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer:\n\n\nsqrt(26-22) + 4\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise: How below mathematical operation can be shown with pipe option?\n\n\nsqrt(log2(64)) - 8\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer\n\n\n64 %&gt;% log2() %&gt;% sqrt() %&gt;% -8"
  },
  {
    "objectID": "precourse_preparation_R.html#example-data-1",
    "href": "precourse_preparation_R.html#example-data-1",
    "title": "Precourse Preparation - R",
    "section": "2.2 Example data",
    "text": "2.2 Example data\nIn this chapter we will work on an expression matrix table (gene expression) which is in CSV format. Below is example of how to load the table.\n\nexpMat &lt;- fread(file = \"data/precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE)\n\n# file: provide full directory to file\n# sep: indicate separator, in this case coma\n# header = True is indicating to take the first row as a column names\n\nDisplaying first rows and columns of the table gives us a glimpse on what the data contain.\n\nexpMat[c(1:5),c(1:5)]\n\n         V1 A1BG A1BG.AS1 A1CF A2M\n1:  3261781    0        0    0   0\n2:  9155806    0        0    0   0\n3:  4304661    0        0    0   0\n4:  2216902    0        0    0   0\n5: 13160139    0        0    0   0\n\n\nThe gene names are displayed in columns and rows contain information about the cells. The column named V1 hold information about the cell index that is given to each cell in primary analysis.\nWe will set the V1 column as row names. In that way all the columns will contain the gene or protein counts.\n\n#use first column as row names\nexpMat &lt;- data.frame(expMat, row.names = 1)\n\nThe same set of above operations can be performed with pipe in one line of code. We read the file and convert first column to row names and save as data frame. The result is assigned to expMat variable by using the arrow.\n\n#pipe operations\nexpMat &lt;- fread(file = \"data/precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE) %&gt;% \n  data.frame(row.names = 1)"
  },
  {
    "objectID": "precourse_preparation_R.html#select",
    "href": "precourse_preparation_R.html#select",
    "title": "Precourse Preparation - R",
    "section": "2.3 select()\n",
    "text": "2.3 select()\n\nFunctionality: Select only the columns (variables) that you want to see.\nImagine you are interested to extract the data only for one gene existing in your dataset. You can use the gene name, for example “CD4”, to indicate in select function which column should be selected.\n\n# choosing the column of CD4 gene\nexpMat %&gt;% dplyr::select(\"CD4\") -&gt; CD4_column\n\nIn the table we work on, the protein and gene expression information are provided. All the protein markers are labeled with “pAbO” abbreviation in addition to marker name. We can select all the columns that contain pAbO in name and save to new table.\n\n#choosing all the columns with AbSeq counts and saving to abseq_data\nexpMat %&gt;% dplyr::select(contains(\"pAbO\")) -&gt; abseq_data\n\nAll the columns that does not contain the “pAbO” are representing genes. To create a gene data, we can use the contains() function with exclamation mark as in below example.\nThe “!” is used for negation in R language and is interpreted as “do not”. Below expression will be interpreted as “select from expMat columns that do not contain pAbO.”.\n\n# choosing all columns that does not contain AbSeq counts (mRNA only)\nexpMat %&gt;% dplyr::select(!contains(\"pAbO\")) -&gt; mrna_data"
  },
  {
    "objectID": "precourse_preparation_R.html#mutate",
    "href": "precourse_preparation_R.html#mutate",
    "title": "Precourse Preparation - R",
    "section": "2.4 mutate()\n",
    "text": "2.4 mutate()\n\nFunctionality: Adds new columns or modifies current variables in the dataset.\nThe mutate function allows in easy way to add new columns in existing tables. Let’s say we want to add column “measurement_type” and fill with “protein expression” in abseq data table we created in previous step.\n\n#add new column with the same value\nabseq_data %&gt;% mutate(data_modality = \"protein_expression\") -&gt; abseq_data \n\nThe new column will be added at the end of table. We can show the column by selecting the column name.\n\n#display results\nabseq_data %&gt;% dplyr::select(\"data_modality\") %&gt;% head\n\n              data_modality\n3261781  protein_expression\n9155806  protein_expression\n4304661  protein_expression\n2216902  protein_expression\n13160139 protein_expression\n11951658 protein_expression\n\n\nmutate() function can be used in combination with other functions.\nIn this example, we will calculate sum of expression count for each cell and store the information in a table. We summarize the counts from all rows and add as a new column. The rowSums function is useful for calculating the sum of counts in each row.\n\nrowSums(mrna_data) -&gt; mRNA_count_sum\n\n#display results\nmRNA_count_sum %&gt;% head\n\n 3261781  9155806  4304661  2216902 13160139 11951658 \n   35231    34733    33238    31618    31664    30786 \n\n\nAfter running rowSums, we got for each cell the number of counts. The values can be added in mrna_data data table as a new column.\n\nmrna_data %&gt;% mutate(counts = mRNA_count_sum) -&gt; mrna_data\nmrna_data %&gt;% dplyr::select(counts) %&gt;% head\n\n         counts\n3261781   35231\n9155806   34733\n4304661   33238\n2216902   31618\n13160139  31664\n11951658  30786\n\n\nThe same result can be generated with option below, where the rowSums function is nested inside the mutate function.\n\nmrna_data %&gt;% mutate(counts = rowSums(mrna_data)) -&gt; mrna_data\n\nNotice that mrna_data is given twice in that case as an argument. The mrna_data is taken by mutate function as first argument and then in rowSums function as second argument.\nIn the above example we used pipe to direct the mrna_data to mutate() function as an argument. However the mrna_data was not forwarded by pipe to rowSums. For that reason we have to type it in the rowSums function. By default, the pipe operator forwards data only as first argument to a function. If you want the pipe to forward data as well as second (and next) argument to function you can use a dot.\n\nmrna_data %&gt;% mutate(counts = rowSums(.)) -&gt; mrna_data"
  },
  {
    "objectID": "precourse_preparation_R.html#summarise",
    "href": "precourse_preparation_R.html#summarise",
    "title": "Precourse Preparation - R",
    "section": "2.5 summarise()\n",
    "text": "2.5 summarise()\n\nFunctionality: Collapse all rows and returns a one-row summary.\nIn the example below, summarise function allow us to calculate the max/min, median and mean values for counts.\n\nmrna_data %&gt;% dplyr::summarise(mean = mean(counts),    #mean counts\n                             median = median(counts),    #median counts\n                             max = max(counts),    #maximum count\n                             min = min(counts))   #minimum count\n\n      mean median    max  min\n1 9142.064   4392 105693 1146\n\n\nIn above summary we have the overview of the expression range and how minimum and maximum values of molecules expressed differ. Some of cells will have very low transcriptome size in comparison to others."
  },
  {
    "objectID": "precourse_preparation_R.html#if_else",
    "href": "precourse_preparation_R.html#if_else",
    "title": "Precourse Preparation - R",
    "section": "2.6 if_else()\n",
    "text": "2.6 if_else()\n\nThe if_else() function in R is a conditional function. It allows to test the hypothesis and perform actions based on answer.\nLet’s assume we want to label the cells according to transcriptom size. Based on threshold of counts we give a label of “low_transcriptome” or “high_transcriptome” for a cell status. We can make assumption that all cells with sum of counts lower then a threthold are low transcriptome cells and remaining cells are categorized as high transcriptome cells.\nThe if_else function with combination of mutate will help us to achieve the goal.\nFirst we need to know what is the structure of if_else statement. The first argument of if_else function is the hypotheses or the statement. We want to test if the counts for cell is below or above the threshold. Second argument is an action to perform if the statement is true. Third argument is an action to perform when the statement is false.\n\nIn our case, the hypothesis to test is if counts in a cell is below or above a threshold. We can set the condition to have a counts above 2000. If the counts are above the threshold the statement is true. When the statement is true the action is to set the label as “high_transcriptome”. When the statement is false we set the label as “low_transciptome”.\n\nif_else(mrna_data$counts &gt; 2000, \"high_transcriptome\", \"low_transcriptome\") -&gt; cell_status\n\nIn that way we created a cell_status string based on counts. We should see cell_status that was generated has two labels. To verify if that is the case we can display the unique values of cell_status.\n\nunique(cell_status)\n\n[1] \"high_transcriptome\" \"low_transcriptome\" \n\n\nIf we would like to add that information as a new column to data table, we can use mutate function as in previous examples.\n\n#calcuate and add cell_status to mrna table\nmrna_data %&gt;% mutate(cell_status = if_else(mrna_data[\"counts\"] &gt; 2000, \"high_transcriptome\", \"low_transcriptome\")) -&gt; mrna_data\n\n#display cell status column \nmrna_data %&gt;% dplyr::select(cell_status) %&gt;% head\n\n                cell_status\n3261781  high_transcriptome\n9155806  high_transcriptome\n4304661  high_transcriptome\n2216902  high_transcriptome\n13160139 high_transcriptome\n11951658 high_transcriptome"
  },
  {
    "objectID": "precourse_preparation_R.html#count",
    "href": "precourse_preparation_R.html#count",
    "title": "Precourse Preparation - R",
    "section": "2.7 count()\n",
    "text": "2.7 count()\n\nFunctionality: Collapse the rows and counts the number of observations per group of values.\nThe count function is a quick way to have an overview on number of occurrences. For example, we can use count() to see how many cells were categorized as low or high transcriptome cells.\n\nmrna_data %&gt;% dplyr::count(cell_status)\n\n         cell_status    n\n1 high_transcriptome 5204\n2  low_transcriptome  597"
  },
  {
    "objectID": "precourse_preparation_R.html#group_by",
    "href": "precourse_preparation_R.html#group_by",
    "title": "Precourse Preparation - R",
    "section": "2.8 group_by()\n",
    "text": "2.8 group_by()\n\nFunctionality: Take the existing data and group specific variables together for future operations.\nThe function takes an existing table and convert it into a grouped table where operations are performed by group.\nLet’s have a look in the following example and assume that we want to compare the mean and median counts for low and high transcriptome cells. In that case we can group data by cell status and calculate average values for those groups.\n\nmrna_data %&gt;% \n  group_by(cell_status) %&gt;% \n  dplyr::summarize(mean = mean(counts),\n            median = median(counts),\n            n = n())  #calculates the total number of observations\n\n# A tibble: 2 × 4\n  cell_status          mean median     n\n  &lt;chr&gt;               &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;\n1 high_transcriptome 10006.  4684.  5204\n2 low_transcriptome   1611.  1638    597\n\n\nIn the above code, we first group cells by cell status, meaning that calculations performed on our data will account for high transcriptome and low transcriptome cells separately. Following code execution, the console displays the mean count, the median count and the total number of cells (n()) for low transcriptome and for high transcriptome cells (group_by(cell_status))."
  },
  {
    "objectID": "precourse_preparation_R.html#filter",
    "href": "precourse_preparation_R.html#filter",
    "title": "Precourse Preparation - R",
    "section": "2.8 filter()\n",
    "text": "2.8 filter()\n\nFunctionality: Only retain specific rows of data that meet the specified requirement(s).\nfilter function displays the data values that meet defined condition. For example, we can filter all cells with low transcriptome cell status and retain only high transcriptome cells.\n\nmrna_data %&gt;% filter(cell_status == \"high_transcriptome\") -&gt; signal_cells\n\n#display last column\nsignal_cells %&gt;% dplyr::select(last_col()) %&gt;% head()\n\n         cell_status\n1 high_transcriptome\n2 high_transcriptome\n3 high_transcriptome\n4 high_transcriptome\n5 high_transcriptome\n6 high_transcriptome"
  },
  {
    "objectID": "precourse_preparation_R.html#rename",
    "href": "precourse_preparation_R.html#rename",
    "title": "Precourse Preparation - R",
    "section": "2.9 rename()\n",
    "text": "2.9 rename()\n\nFunctionality: Rename a column/variable by name and index.\nRename the cell_status variable as SIGNAL_CELLS (notice that the new label goes first in the argument).\n\nmrna_data %&gt;% rename(SIGNAL_CELLS = cell_status) -&gt; mrna_data\n\n#display results\nmrna_data %&gt;% dplyr::select(last_col()) %&gt;% head #chose last column from mrna_data\n\n               SIGNAL_CELLS\n3261781  high_transcriptome\n9155806  high_transcriptome\n4304661  high_transcriptome\n2216902  high_transcriptome\n13160139 high_transcriptome\n11951658 high_transcriptome"
  },
  {
    "objectID": "precourse_preparation_R.html#seurat-object-structure",
    "href": "precourse_preparation_R.html#seurat-object-structure",
    "title": "Precourse Preparation - R",
    "section": "3.1 Seurat Object Structure",
    "text": "3.1 Seurat Object Structure\nSeurat object stores information about the single cell multiomics data and the analysis that is performed. As we move through the workflow and make calculations, the results are added to Seurat object and stored in different “boxes”. Those different “boxes” are called slots.\nLet’s load an example Seurat object into R.\n\nseuratObj &lt;- readRDS(\"data/precourse_preparation_data/seuratObj.rds\")\n\nThe example Seurat object has a mRNA counts table. While Seurat object is generated, the following information are added to Seurat slots by default: assays, meta data, active assay, active identity, project name and version.\n\nThe remaining Seurat slots highlighted in grey are empty and will be filled with information during the analysis.\nYou can open the Seurat object in a separate tab and review its content."
  },
  {
    "objectID": "precourse_preparation_R.html#assays",
    "href": "precourse_preparation_R.html#assays",
    "title": "Precourse Preparation - R",
    "section": "3.2 Assays",
    "text": "3.2 Assays\nThe assays slot contain different assays loaded into Seurat object. Those can be mRNA expression data or protein expression data. The assay slot has additional subslots that store the ‘transformation’ of the data, including raw counts (counts slot), normalized data (data slot), and scaled data for dimensional reduction (scale.data slot).\nThe assays slots can be accessed by function GetAssayData. In the example below, we access the counts slot.\n\n#Seurat object saved before normalization\nGetAssayData(object = seuratObj, slot = \"counts\") %&gt;% \n  .[1:5 , c(\"6660551\",\"2066735\",\"9164959\",\"3709837\")]\n\n5 x 4 sparse Matrix of class \"dgCMatrix\"\n         6660551 2066735 9164959 3709837\nA1BG           .       1       .       .\nA1BG.AS1       1       .       1       .\nA1CF           .       .       .       .\nA2M            .       .       .       2\nA2M.AS1        .       .       .       .\n\n\nWe can perform normalization and store the normalized counts in data slot.\n\n#Seurat object saved after normalization\nseuratObj &lt;- NormalizeData(seuratObj)\n\nGetAssayData(object = seuratObj, slot = \"data\") %&gt;% \n  .[1:5 , c(\"6660551\",\"2066735\",\"9164959\",\"3709837\")]\n\n5 x 4 sparse Matrix of class \"dgCMatrix\"\n          6660551   2066735   9164959   3709837\nA1BG     .        0.3399948 .         .        \nA1BG.AS1 0.330402 .         0.3532289 .        \nA1CF     .        .         .         .        \nA2M      .        .         .         0.6642082\nA2M.AS1  .        .         .         .        \n\n\nBy running above example, you can see the raw values in data slot are changed due to LogTransform normalization.\nBelow you can find a useful graphics indicating how data are altered in assays slots in Seurat object after applying different functions.\n\nCredit: Lior Pachter https://twitter.com/lpachter/status/1524413513233575936"
  },
  {
    "objectID": "precourse_preparation_R.html#meta-data",
    "href": "precourse_preparation_R.html#meta-data",
    "title": "Precourse Preparation - R",
    "section": "3.3 Meta Data",
    "text": "3.3 Meta Data\nmeta.data slot stores information calculated for cells such as number of features and number of counts in each cell.\nThe meta.data information is stored in a table that can be accessed in Seurat object as below.\n\nseuratObj@meta.data %&gt;% head\n\n            orig.ident nCount_RNA nFeature_RNA\n3261781  SeuratProject      35231         5823\n9155806  SeuratProject      34733         5943\n4304661  SeuratProject      33238         5480\n2216902  SeuratProject      31618         5573\n13160139 SeuratProject      31664         5592\n11951658 SeuratProject      30786         5457\n\n\nTo view list of all available meta.data in Seurat object we can view the column names from the data table.\n\nseuratObj@meta.data %&gt;% colnames()\n\n[1] \"orig.ident\"   \"nCount_RNA\"   \"nFeature_RNA\"\n\n\nIt is possible to add new information to meta.data. It can be any information about the cells such as experimental batch or sub-population identity.\n\n#add meta data\nseuratObj &lt;- AddMetaData(seuratObj, #indicate object\n            \"experiment_1\", #metadata to be added\n            \"batch\") #column name for metadata\n\n#display results\nseuratObj@meta.data %&gt;% head\n\n            orig.ident nCount_RNA nFeature_RNA        batch\n3261781  SeuratProject      35231         5823 experiment_1\n9155806  SeuratProject      34733         5943 experiment_1\n4304661  SeuratProject      33238         5480 experiment_1\n2216902  SeuratProject      31618         5573 experiment_1\n13160139 SeuratProject      31664         5592 experiment_1\n11951658 SeuratProject      30786         5457 experiment_1"
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "",
    "section": "",
    "text": "MIT License\nCopyright (c) 2023 material-share\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "03_normalization.html",
    "href": "03_normalization.html",
    "title": "Chapter 3 Normalization and PCA",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\n\nLoad RData\nLoad the RData which contains all files from previous chapter.\n\nload(\"data/intermediate_data/chapter2.RData\")\n\n1. Normalization\nWe will perform normalization on UMI counts using LogNormalize.\nLogNormalize divides the UMI counts of a gene in a cell into the total UMI counts in that cell. After division, we take the natural log.\n\nfiltered.rna &lt;- NormalizeData(filtered.rna, \n                              normalization.method = \"LogNormalize\")\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhere are the normalized counts stored?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe normalized counts are stored in the slot RNA.\n\nfiltered.rna@assays[[\"RNA\"]]@data[1:5, 1:5]\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n          74 391 440 1222 2690\nA1BG-AS1   .   .   .    .    .\nA1CF       .   .   .    .    .\nA2M        .   .   .    .    .\nA2M-AS1    .   .   .    .    .\nA2ML1-AS1  .   .   .    .    .\n\n\n\n\n\n2. Evaluating effects of mitochondrial percentage (optional)\nThe unwanted variation, such as the difference in mitochondrial percentage, could bias the downstream analysis.\nFor example, we don’t want the cells clustered based on the difference in mitochondrial percentage.\nLet’s first has a look if the mitochondrial percentage introduces unwanted variation in the dataset or not. We take the normalized counts and follow the below steps to check.\n\nThe mitochondrial percentage is a series of numbers. We can turn the mitochondrial percentage variable into a categorical variable based on quartiles.\n\n\nsummary(filtered.rna$percent.mt)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.2155 10.1004 12.4155 12.6649 15.1489 24.9487 \n\n\nThe cells can be grouped into 4 categories.\nMT% &lt; 1st quartile: Low.\nMT% between 1st quartile and Median: Median.\nMT% between Median and 3rd quartile: Median high.\nMT% &gt; 3rd quartile (15.4158%): High.\nNext, we create a new variable based on the thretholds.\n\nfiltered.rna$quartile.mt &lt;- cut(filtered.rna$percent.mt, \n                                breaks=c(-Inf, 10.1004, 12.4155, 15.1489, Inf),\n                                labels=c(\"Low\",\"Medium\",\"Medium high\", \"High\"))\n\nWe use PCA to check whether the mitochondrial percentage is a source of variation. We plot the first two principal components and visualize the data.\n\n# Identify the most variable genes\nfiltered.rna &lt;- FindVariableFeatures(filtered.rna,\n                                     selection.method = \"vst\",\n                                     nfeatures = 2000, \n                                     verbose = FALSE)\n             \n# Scale the data\nfiltered.rna &lt;- ScaleData(filtered.rna, \n                          features = rownames(filtered.rna))\n\n# perform PCA\nfiltered.rna &lt;- RunPCA(filtered.rna)\n\n# Plot pc1 and pc2\nDimPlot(filtered.rna,\n        reduction = \"pca\",\n        group.by= \"quartile.mt\",\n        split.by = \"quartile.mt\")\n\n\n\n\nBased on the above plot, we can see a different scatter pattern in cells with “Low” mitochondrial percentage.\nWe observe that the lobe of cells on the right middle side of the plot is only in the category “Low”. For all other levels of mitochondrial percentage, we see a more even distribution of cells across the PCA plot.\n\n\n\n\n\n\nTip\n\n\n\nOftentimes, it is helpful to regress out variation due to mitochondrial percentage. However, if the differences in mitochondrial percentation has the biological meaning that might help to distinguish cell clusters, then we do not regress it out.\n\n\n\n\n\n\n\n\nTip\n\n\n\nCell cycle is another common source of bias. For instructions on how to remove cell cycle bias, please refer to https://satijalab.org/seurat/articles/cell_cycle_vignette.html\n\n\nTo regress out the effect of mitochondrial percentage, add the argument vars.to.regress = \"percent.mt\" to the ScaleData.\n\n# Scale the data\nfiltered.rna &lt;- ScaleData(filtered.rna, \n                          features = rownames(filtered.rna), \n                          vars.to.regress = \"percent.mt\")\n\n# Recalculate PCA\nfiltered.rna &lt;- RunPCA(filtered.rna)\n\n3. Save\nSave the files into RData for documentation.\n\n# save(filtered.rna, expMat, file = \"data/intermediate_data/chapter3.RData\")"
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup",
    "section": "",
    "text": "Important\n\n\n\nThe course will run on virtual machine. We have materials and RStudio setting up on the virtual machine, so you DO NOT need to set up anything on your desktop for the instructor-led course.\nHowever, if you are going to run through the code on your local desktop, please follow this chapter to set up R and RStudio on the desktop.\n\n\n1. R and RStudio\nPlease follow the instruction to set up the most up to date R and RStudio on desktop: https://posit.co/download/rstudio-desktop/\n2. Install R packages\n\n\n\n\n\n\nNote\n\n\n\nInstall the packages in the order listed below.\nThe package names are case sensitive.\nAt any point (especially if you have used R/Bioconductor in the past), in the console R may ask you if you want to update any old packages by asking Update all/some/none? [a/s/n]:. If you see this, please type “n” at the prompt and hit Enter to NOT update all old packages.\nIf you want to update packages, please go to: Tools -&gt; Check for Package Updates. Select the packages to upload.\n\nPlease do NOT update dplyr, Seurat, SeuratObject.\n\n\n\nOnly for windows machines: Please download and install RTools from https://cran.r-project.org/bin/windows/Rtools/.\nInstall the packages listed below one by one from CRAN using the install.packages() function.\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"Matrix\")\ninstall.packages(\"RCurl\")\ninstall.packages(\"scales\")\ninstall.packages(\"data.table\")\ninstall.packages(\"readxl\")\ninstall.packages(\"BiocManager\")\ninstall.packages(\"ggpubr\")\n\nInstall the packages listed below one by one from bioconductor using the BiocManager::install() function.\n\nBiocManager::install(\"ensembldb\")\nBiocManager::install(\"org.Hs.eg.db\")\nBiocManager::install(\"clusterProfiler\")\nBiocManager::install(\"AnnotationDbi\")\nBiocManager::install(\"biomaRt\")\nBiocManager::install(\"enrichplot\")\nBiocManager::install(\"HGNChelper\")\n\nInstall Seurat V4\n\nThe teaching materials run on Seurat V4. If you already install Seurat, please check the version of SeuratObject and Seurat.\n\npackageVersion(\"SeuratObject\")\npackageVersion(\"Seurat\")\n\nIf the version of Seurat is 4.x.x, you are good to go. If the version is 5.0.x, please follow the below instructions to remove the existing Seurat package and install Seurat V4.\n\nremove.packages(\"SeuratObject\")\nremove.packages(\"Seurat\")\n\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/SeuratObject/SeuratObject_4.1.4.tar.gz\" \ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/Seurat/Seurat_4.4.0.tar.gz\" \ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\nValidate the installation is successful by running packageVersion.\n\npackageVersion(\"SeuratObject\")\npackageVersion(\"Seurat\")\n\n\nCheck that all the packages were installed successfully by loading them one by one at a time using the library() function.\n\n\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(BiocManager)\nlibrary(Matrix)\nlibrary(RCurl)\nlibrary(readxl)\nlibrary(scales)\nlibrary(ggpubr)\nlibrary(data.table)\nlibrary(AnnotationHub)\nlibrary(ensembldb)\nlibrary(HGNChelper)\nlibrary(clusterProfiler)\nlibrary(AnnotationDbi)\nlibrary(biomaRt)\nlibrary(enrichplot)\n\n3. Download dataset and code\nDataset: Please download the data from Data. It is required to run the prerequisites and course chapters.\nCode: You will also need to download the entire repository as a .zip from https://github.com/material-share/material-share-single-cell-boot-camp/tree/master.\n\nAfter download, unzip the repository and put the Data folder in the repository.\nTo run the analysis, double click on single-cell-boot-camp.Rproj. One should be able to bring out the RStudio console on desktop.\n4. Where to find the most up-to-date course materials?\nThis website! This website is constantly updated. The Log outlines the change through time.\nIf you would like to contribute, report bugs, or suggest any tools or workflow, please open on issue: https://github.com/material-share/material-share-single-cell-boot-camp/issues."
  },
  {
    "objectID": "precourse_preparation_theory.html",
    "href": "precourse_preparation_theory.html",
    "title": "Precourse Preparation - Theory",
    "section": "",
    "text": "Our body has many cell types with different functions and they interact with each other in a daily basis. We can imagine it like a bustling city with different workers specializing in different tasks.\nSingle-cell RNA sequencing (scRNAseq) can help to understand the cell types and their functionality. It’s like taking a close-up picture of each cell and see which genes are active.\nThis technique can be applied to:\n\nInvestigating different types of cells in a specific tissue. Example: Understanding the various cell types in the brain.\nDiscovering noval cell types or states. Example: Identifying unique cell types in the immune system.\nFiguring out how genes change their activity as cells differentiate over time. Example: Tracking gene expression dynamics such as stem cells differentiation.\nFinding genes that are active in certain cell types under certain conditions. Example: Finding genes that switch on and off in lung cells in asthma.\nExamining how gene activity changes within a cell type under certain conditions. Example: Studying how nerve cells in the spinal cord change their gene activity in response to injury."
  },
  {
    "objectID": "precourse_preparation_theory.html#bd-rhapsody-single-cell-assays",
    "href": "precourse_preparation_theory.html#bd-rhapsody-single-cell-assays",
    "title": "Precourse Preparation - Theory",
    "section": "2.1 BD Rhapsody Single-Cell Assays",
    "text": "2.1 BD Rhapsody Single-Cell Assays\n\nThe BD Rhapsody™ System, along with diverse range of assays, enables simultaneous measurement of multiple cell parameters across tens of thousands of individual cells in parallel. By combining available assays, researchers can generate robust and intricate datasets, unlocking powerful insights:\nGene Expression: The primary purpose of scRNA-seq is to measure the expression of genes within individual cells. This allows to understand which genes are active or inactive in each cell and to identify different cell types based on their gene expression profiles.\nAntibody-Based Protein Analysis: You can use antibodies conjugated with unique barcodes to simultaneously measure the expression of specific proteins in individual cells. This enables protein-level analysis alongside gene expression.\nSample multiplexing with antibody-based techniques: involves using generic antibody conjugated with unique barcodes to label the cells for different samples. Each sample is labeled and idenfied with unique antibody barcode.\nImmune Repertoire Profiling: Rhapsody can be used for immune profiling, allowing researchers to analyze the diversity and clonality of T-cell and B-cell receptor repertoires. This is valuable for studying the immune response and identifying antigen-specific cells.\nAntigen-Specific T-cell Analysis: Immudex’s technology combined with the Rhapsody system, enables the precise profiling of T cells that recognize specific antigens, like viral epitopes or tumor-related antigens. This expands immune profiling possibilities, aiding vaccine development, immunotherapy research, and the study of immune-related diseases.\nFrom scRNA-seq for gene expression profiling to antibody-based protein analysis, these assays empower researchers to explore and dissect the multifaceted world of cellular functions and molecular dynamics with precision"
  },
  {
    "objectID": "precourse_preparation_theory.html#analysis-of-single-cell-data",
    "href": "precourse_preparation_theory.html#analysis-of-single-cell-data",
    "title": "Precourse Preparation - Theory",
    "section": "2.2 Analysis of Single Cell Data",
    "text": "2.2 Analysis of Single Cell Data\nThe analysis of single cell data can be split into two parts. The primary analysis transforms raw data into an expression matrix, where each row represents a gene, each column represents a cell, and each entry in the matrix contains the count of molecules for a particular gene or protein in a specific cell. Secondary analysis focus on extracting meaningful biological insights from this expression matrix, such as identifying cell types, studying differential gene expression, and understanding cellular processes and functions.\n\nThe workshop will focus on providing insights into secondary analysis. At the same time the primary analysis lays the foundation for secondary and downstream analyses. The next chapter covers information about primary analysis useful to know while working with single-cell data."
  },
  {
    "objectID": "precourse_preparation_theory.html#from-sequencing-data-to-expression-matrix",
    "href": "precourse_preparation_theory.html#from-sequencing-data-to-expression-matrix",
    "title": "Precourse Preparation - Theory",
    "section": "2.3 From Sequencing Data to Expression Matrix",
    "text": "2.3 From Sequencing Data to Expression Matrix\nThe analysis of sequencing data is handled by the software provided by BD to Rhapsody users that enables fast and easy data processing. In this chapter we will cover a key features of the pipeline and explain key concepts necessary to understand while working with single cell data.\n\n2.3.1 BD Rhapsody Sequencing Analysis Pipeline\nThe BD Rhapsody sequencing analysis pipeline is a series of computational and analytical steps used to process and extract meaningful information from the raw sequencing data generated by the BD Rhapsody system.\nThe goal of sequencing analysis is to transform text-based genomic data into numerical data, and we achieve this through a series of steps in our pipeline. The steps of the pipeline are listed in simplified graphics below.\n\nThe main steps of the pipeline include quality control of raw sequencing data, molecule counting, identifying the putative cells and sample of origin if multiple samples were processed in one experiment.\nCrucial Steps in the process are decoding the unique barcodes associated with individual cells and the information about gene expression. Additionally, we use a technique called Unique Molecular Identifiers (UMIs) to count gene expression accurately. These steps enable us to precisely identify and quantify the activity of genes in each cell, forming the basis for further analysis.\n\n\n2.3.2 Expression Counts by UMIs\nUnique Molecular Identifiers (UMIs) are used to distinguish between molecules expressed in a cell by providing a way to count individual molecules accurately. Here’s how they work to differentiate and quantify molecules in a cell:\n\nAdding UMIs during RNA sequencing preparation: UMIs are small, unique sequences of DNA that are added to the capture sequences of the bead during the production. Each bead contains tens of thousands of unique UMI barcodes which are followed by the polyA capture sequence. During the cell processing, the polyadenylated molecules in a cell, as mRNAs are captured on the bead. Each UMI is specific to the molecule it’s attached to and become it’s unique tag (see Figure below).\n\n\n\n\nCreating copies of RNA molecules: After adding UMIs, scientists make many copies of all the RNA molecules in the cell by running PCR. This step ensures that there are enough copies to work with.\nSequencing the molecules: The copies of RNA molecules, including the attached UMIs, are then sequenced. Sequencing means reading the genetic code of these molecules to determine their identity.\n\nAnalyzing the data: When the sequencing is done, scientists look at the data. Here’s where UMIs become important:\n\nRemoving duplicates: Because UMIs are unique to each original RNA molecule, any duplicates (multiple copies of the same RNA molecule) with the same UMI are likely the result of PCR (Polymerase Chain Reaction) amplification during the sequencing process. Scientists can identify and remove these duplicates to get an accurate count of different RNA molecules.\nCounting unique molecules: By looking at the UMIs, scientists can count how many unique RNA molecules were originally present in the cell. This helps them understand which genes were active in the cell and to what extent.\nQuantifying gene expression: By counting the unique UMIs associated with each gene, scientists can measure the expression level of genes in the cell. Genes with more UMIs were more active in the cell, while genes with fewer UMIs were less active.\n\nIn summary, UMIs are used to distinguish between molecules expressed in a cell by providing a unique identifier for each original molecule. This helps in accurately counting and quantifying gene expression, which is crucial for understanding how genes function in single cells and studying cellular processes in detail.\n\n\n2.3.3 Output Files\nWe handle various types of data all at once during primary analysis. This includes data related to gene expression at first but can include as well protein expression or information about T-cell receptors (TCR), B-cell receptors (BCR), and sample tags depending on experimental part. The assays run during experiments determine what type of data will be generated and what output files are available for the users for downstream analysis.\nThe information about cells is stored in multiple output files. In below you can find summary of what output files relates to which information about the cell.\n\nThe primary analysis output files are taken as an input to secondary analysis. During the workshop we will work with data that include mRNA, protein and sample tag information. You will get to know how to load the expression matrice in MEX format for downstream analysis."
  },
  {
    "objectID": "02_quality_control.html",
    "href": "02_quality_control.html",
    "title": "Chapter 2 Quality Control",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)"
  },
  {
    "objectID": "02_quality_control.html#ncount_rna-umi-counts-per-cell",
    "href": "02_quality_control.html#ncount_rna-umi-counts-per-cell",
    "title": "Chapter 2 Quality Control",
    "section": "3.1 nCount_RNA UMI counts per cell",
    "text": "3.1 nCount_RNA UMI counts per cell\nWe look at nCount_RNA for the sum of UMI counts per cell.\n\nrna@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=nCount_RNA, fill= Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  ggtitle(\"nCount_RNA\")"
  },
  {
    "objectID": "02_quality_control.html#nfeature_rna-gene-counts-per-cell",
    "href": "02_quality_control.html#nfeature_rna-gene-counts-per-cell",
    "title": "Chapter 2 Quality Control",
    "section": "3.2 nFeature_RNA Gene counts per cell",
    "text": "3.2 nFeature_RNA Gene counts per cell\nWe look at nFeature_RNA for sum of gene counts per cell. The majority of cells have gene counts more than 300.\n\nrna@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=nFeature_RNA, fill= Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  ggtitle(\"nFeature_RNA\")"
  },
  {
    "objectID": "02_quality_control.html#percent.mt-mitochondrial-percentage-per-cell",
    "href": "02_quality_control.html#percent.mt-mitochondrial-percentage-per-cell",
    "title": "Chapter 2 Quality Control",
    "section": "3.3 percent.mt Mitochondrial percentage per cell",
    "text": "3.3 percent.mt Mitochondrial percentage per cell\nWe look at percent.mt for mitochondrial percentage per cell. The majority of cells have mitochondrial percentage below 25%.\n\nrna@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=percent.mt, fill=Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  ggtitle(\"percent.mt\")"
  },
  {
    "objectID": "02_quality_control.html#combine-metrics-to-come-up-filtering-threshold",
    "href": "02_quality_control.html#combine-metrics-to-come-up-filtering-threshold",
    "title": "Chapter 2 Quality Control",
    "section": "3.4 Combine metrics to come up filtering threshold",
    "text": "3.4 Combine metrics to come up filtering threshold\nWe can combine the metrics to decide the filtering threshold.\n\nrna@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500, colour = \"red\") +\n  geom_hline(yintercept = 300, colour = \"red\") +\n  facet_wrap(~Sample_Name) +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n\n\n\nThe data is fitted with a linear regression line. We expect when UMI counts increase, gene counts also increase.\nUpper right quadrant: Cells with high number of genes and UMI counts. We generally consider these cells to be good-quality cells.\nBottom right quadrant: Cells with low number of genes and UMI counts. We generally consider these cells are low-quality cells.\nDarker cells: Cells with high mitochondrial percentage. Many of these cells have low gene counts. This could indicate damaged/dying cells whose cytoplasmic mRNA leaked out through a broken membrane, so only mRNA located in the mitochondria is still conserved."
  },
  {
    "objectID": "02_quality_control.html#filter-on-cells",
    "href": "02_quality_control.html#filter-on-cells",
    "title": "Chapter 2 Quality Control",
    "section": "4.1 Filter on cells",
    "text": "4.1 Filter on cells\nBased on the quality metrics, we use the following thresholds to filter out low quality cells:\nnCount_RNA &gt; 500\nnFeature_RNA &gt; 300\nnFeature_RNA &lt; 5000\npercent.mt &lt; 25%\n\nfiltered.rna &lt;- subset(x = rna, \n                       subset = (nCount_RNA &gt;= 500) & \n                         (nFeature_RNA &gt;= 300) &\n                         (nFeature_RNA &lt;= 5000) &\n                         (percent.mt &lt; 25))\n\n\n\n\n\n\n\nImportant\n\n\n\nThe filtering thresholds should be decided based on assessing the quality metrics. They may change depending on the sample types, sequencing depth and other factors."
  },
  {
    "objectID": "02_quality_control.html#filter-on-genes",
    "href": "02_quality_control.html#filter-on-genes",
    "title": "Chapter 2 Quality Control",
    "section": "4.2 Filter on genes",
    "text": "4.2 Filter on genes\nAfter filtering on cells, some genes may have zero counts or are only expressed in few cells. These genes do not bring much information, and they reduce the average expression of a cell.\nWe keep only genes that are expressed in five or more cells. GetAssayData is a convenient command to get information from the Seurat object. We use GetAssayData to extract the UMI counts.\n\n# Extract counts\ncounts &lt;- GetAssayData(object = filtered.rna, slot = \"counts\")\n\n# Output a logical matrix specifying for each gene whether or not \n# there are more than zero counts per cell\nnonzero &lt;- counts &gt; 0\n\n# Sum all TRUE values and return TRUE \n# if equal or more than 5 TRUE values per gene\nkeep_genes &lt;- Matrix::rowSums(nonzero) &gt;= 5\n\n# Only keep those genes\nfiltered_counts &lt;- counts[keep_genes, ]\n\n# Create Seurat object\nfiltered.rna &lt;- CreateSeuratObject(filtered_counts, meta.data = filtered.rna@meta.data)\n\n\n\n\n\n\n\nImportant\n\n\n\nIn this example, we keep only genes that are expressed in five or more cells."
  },
  {
    "objectID": "sessioninfo.html",
    "href": "sessioninfo.html",
    "title": "SessionInfo",
    "section": "",
    "text": "library(sessioninfo)\nsession_info()\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.0 (2023-04-21)\n os       macOS 14.1\n system   x86_64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Amsterdam\n date     2023-11-23\n pandoc   3.1.3 @ /opt/anaconda3/bin/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.1   2023-03-23 [1] CRAN (R 4.3.0)\n digest        0.6.33  2023-07-07 [1] CRAN (R 4.3.0)\n evaluate      0.23    2023-11-01 [1] CRAN (R 4.3.0)\n fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.3.0)\n htmltools     0.5.7   2023-11-03 [1] CRAN (R 4.3.0)\n htmlwidgets   1.6.2   2023-03-17 [1] CRAN (R 4.3.0)\n jsonlite      1.8.7   2023-06-29 [1] CRAN (R 4.3.0)\n knitr         1.45    2023-10-30 [1] CRAN (R 4.3.0)\n rlang         1.1.2   2023-11-04 [1] CRAN (R 4.3.0)\n rmarkdown     2.25    2023-09-18 [1] CRAN (R 4.3.0)\n rstudioapi    0.15.0  2023-07-07 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n xfun          0.41    2023-11-01 [1] CRAN (R 4.3.0)\n yaml          2.3.7   2023-01-23 [1] CRAN (R 4.3.0)\n\n [1] /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "04_integration.html",
    "href": "04_integration.html",
    "title": "Chapter 4 Integration",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\n\nLoad RData\nLoad the RData which contains all files from previous chapter.\n\nload(\"data/intermediate_data/chapter3.RData\")\n\n1. To integrate or not to integrate?\nThe goal of integration is to find corresponding cell states across conditions (or experiments). We want to identify cell types which are present in all samples/conditions/modalities within our dataset. We expect to observe a representation of cells from samples/conditions/modalities in every cluster.\nWe first look at how cells cluster without integration to determine whether integration is necessary. Integration is considered if cells cluster separately on samples/conditions/modalities, etc.\n\n# Run the standard workflow for visualization\nfiltered.rna &lt;- RunUMAP(filtered.rna, dims = 1:15)\n\nDimPlot(filtered.rna, group.by = \"Sample_Name\")\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nJudging by the UMAP, do the two samples need to be integrated?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe same cell types from the two samples are not aligned. One may consider to perform integration.\n\n\n\n2. Perform integration\nFirst, we select the variable features. The features should be selected in each dataset.\n\n# split the dataset into a list of two seurat objects (treated and naive)\nsplit.filtered.rna &lt;- SplitObject(filtered.rna, split.by = \"Sample_Name\")\n\n# normalize and identify variable features for each dataset independently\nsplit.filtered.rna &lt;- lapply(X = split.filtered.rna, FUN = function(x) {\n    x &lt;- NormalizeData(x)\n    x &lt;- FindVariableFeatures(x, selection.method = \"vst\", nfeatures = 2000)\n})\n\n# Select the most variable features to use for integration\ninteg.features &lt;- SelectIntegrationFeatures(object.list = split.filtered.rna, \n                                            nfeatures = 2000) \n\nNext, we perform the integration across samples. This step can take a while to run.\n\nanchors &lt;- FindIntegrationAnchors(object.list = split.filtered.rna,\n                                  anchor.features = integ.features)\n\nFinally, we can integrate across samples. By default, normalization.method is set to LogNormalize.\n\nintegrate.filtered.rna &lt;- IntegrateData(anchorset = anchors)\n\n3. UMAP visualization\nAfter integration, we look at the integrated data on UMAP. To calculate UMAP, we need to first calculate PCA and select top PCs.\nMethods to select top PCs were used a lot more often when the data was normalized with LogNormalize.\n\nintegrate.filtered.rna &lt;- ScaleData(integrate.filtered.rna, verbose = FALSE)\nintegrate.filtered.rna &lt;- RunPCA(integrate.filtered.rna, npcs = 50, verbose = FALSE)\n\nElbow plot can help to select top PCs. The PC number, where the elbow is, is used to calculate UMAP.\n\nElbowPlot(integrate.filtered.rna, ndims = 50)\n\n\n\n\nFor this dataset, we use the first top 20 PCs. For other datasets, one may need to adjust the PCs according to the elbow plot.\n\nintegrate.filtered.rna &lt;- RunUMAP(integrate.filtered.rna, \n                                  reduction = \"pca\", \n                                  dims = 1:10)\n\nintegrate.filtered.rna &lt;- FindNeighbors(integrate.filtered.rna, \n                                        reduction = \"pca\", \n                                        dims = 1:10)\n\n\n# Plot UMAP                             \nDimPlot(integrate.filtered.rna, group.by = \"Sample_Name\")   \n\n\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nChange the number of PCs and see how the UMAP changes.\nTips: You can change the PC numbers by dims argument in RunUMAP.\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nDimplot has many arguments to control the plots.\n\nSearch Dimplot in the “Help” tab and read the documentation.\nChange group.by to split.by. What is the difference?\n\n\n\nWhen we compare the similarity between the naive and treated clusters in the plots with or without integration, it is clear that this dataset benefits from the integration.\n\np1 &lt;- DimPlot(filtered.rna, group.by = \"Sample_Name\") + NoLegend()\np2 &lt;- DimPlot(integrate.filtered.rna, group.by = \"Sample_Name\")  + NoLegend()\n\np1|p2\n\n\n\n\n4. Save\nSave the files into RData for documentation.\n\n# save(integrate.filtered.rna, expMat, file = \"data/intermediate_data/chapter4.RData\")"
  },
  {
    "objectID": "09_combining.html",
    "href": "09_combining.html",
    "title": "Chapter 9 Combine scRNAseq and AbSeq",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\n\nLoad RData\nLoad the RData which contains all files from the previous chapter.\n\nload(\"data/intermediate_data/chapter7.RData\")\n\nWhen the experiment has RNA profiling (scRNA) and protein profiling (AbSeq) in single cell resolution, each measurement is one modality. The combined analysis of scRNA and AbSeq is so called “multimodal analysis”.\nSeurat package also provides the framework to analyze multimodal data. The framework is the the weighted nearest neighbors (WNN) approach, which enables simultaneous clustering of cells based on weighted combination of both modalities.\n\n\n\n\n\n\nNote\n\n\n\nRNA profiling and protein profiling should be analyzed separately before combing for downstream analysis.\n\n\n1. Processing AbSeq\nWhen we analyzed the scRNAseq in the previous chapters, the dataset was filtered and only high quality cells are kept. AbSeq dataset is filtered to have the same cells.\n\n# get AbSeq from expMat\nab &lt;- expMat$`Antibody Capture`\n\n# filter abseq data based on cell id from rna seurat object\nab &lt;- ab[, colnames(integrate.filtered.rna)]\n\nCreating a new Seurat object with AbSeq.\n\n# create a new assay to store AbSeq information\nab &lt;- CreateAssayObject(counts = ab)\n\n# create a new Seurat object to store the combined analysis\ncombined &lt;- integrate.filtered.rna\ncombined[[\"AB\"]] &lt;- ab\n\n# Validate that the object now contains multiple assays\ncombined\n\nAn object of class Seurat \n40809 features across 4160 samples within 7 assays \nActive assay: RNA (19347 features, 0 variable features)\n 6 other assays present: integrated, refAssay, prediction.score.celltype.l1, prediction.score.celltype.l2, prediction.score.celltype.l3, AB\n 4 dimensional reductions calculated: pca, umap, integrated_dr, ref.umap\n\n\nNext, we normalize the AbSeq counts.\nThe recommended normalization method for AbSeq is CLR, Centered Log Ratio. Due to the unspecific binding background signal of antibody, log-normalization doesn’t work well in AbSeq data.\nThere are 20 AbSeq in the experiment. We are going to use all of them as variable features.\n\n# switch the default assay to AbSeq\nDefaultAssay(combined) &lt;- 'AB'\n\n# set variable features\nVariableFeatures(combined) &lt;- rownames(combined[[\"AB\"]])\n\n# set a name for the dimentionality reduction to avoid overwriting\ncombined &lt;- NormalizeData(combined, normalization.method = 'CLR', margin = 2) %&gt;% \n  ScaleData() %&gt;% \n  RunPCA(reduction.name = 'apca', approx = F)\n\n2. Weighted nearest neighbour (WNN)\nThe weighted nearest neighbor (WNN) is a statistical framework implemented in Seurat for the multimodal analysis. WNN requires pre-processing and dimentionality reduction on both assays independently upfront.\n\ncombined &lt;- FindMultiModalNeighbors(combined, \n                                    reduction.list = list(\"pca\", \"apca\"), \n                                    dims.list = list(1:15, 1:18), \n                                    modality.weight.name = \"RNA.weight\")\n\n\nreduction.list Dimentionality reduction to use from each element\ndims.list Number of PCs to include from each element\nmodality.weight.name Give a name to the weight of each element\n\nNow, we run UMAP using the calculated WNN.\nFor each cell, we calculate its closest neighbors in the dataset based on a weighted combination of RNA and protein similarities. We specify the dimensionality of each modality (similar to specifying the number of PCs to include in scRNA-seq clustering). We use the same number of PCs as we did in previous steps.\n\n# run UMAP\ncombined &lt;- RunUMAP(combined, \n                    nn.name = \"weighted.nn\", \n                    reduction.name = \"wnn.umap\", \n                    reduction.key = \"wnnUMAP_\")\n\n# find clusters\ncombined &lt;- FindClusters(combined, \n                         graph.name = \"wsnn\", \n                         resolution = 0.4, \n                         verbose = FALSE)\n\nLook at the results in UMAP.\n\n# visualize the result in UMAP\np1 &lt;- DimPlot(combined, reduction = 'wnn.umap', \n              label = TRUE, repel = TRUE, label.size = 2.5, \n              group.by = \"predicted.celltype.l1\")\n\np2 &lt;- DimPlot(combined, reduction = 'wnn.umap', \n              label = TRUE, repel = TRUE, label.size = 2.5)\n\np1|p2\n\n\n\n\nLet’s compare the UMAPs from RNA only and from WNN. The T cells cluster better in WNN UMAP. Because AbSeq is often handpicked and cell type specific, bringing AbSeq in can have a better resolution.\n\n# compare the UMAPs based on RNA and on WNN\np1 &lt;- DimPlot(combined, reduction = 'umap', group.by = 'predicted.celltype.l1', \n              label = TRUE, repel = TRUE, label.size = 2.5) + \n  NoLegend() + ggtitle(\"RNA\")\n\np2 &lt;- DimPlot(combined, reduction = 'wnn.umap', group.by = 'predicted.celltype.l1', \n              label = TRUE, repel = TRUE, label.size = 2.5) + \n  NoLegend() + ggtitle(\"WNN\")\n\np1|p2\n\n\n\n\n3. AbSeq visualization\nWe have several assays stored in the Seurat object. We can easily switch between them and work on different assays.\n\n\n\n\n\n\nImportant\n\n\n\nIt is important to know which assay you are working on. We may get unexpected results if working on the wrong assay.\n\n\nLet’s look at the protein and gene expression side by side. By setting the default assay, we can visualize one or the other.\nCD19 is a B cell marker. We can plot the UMAP with annotation side by side with the CD19 AbSeq.\n\n# switch default assay to AbSeq to plot protein expression\nDefaultAssay(combined) &lt;- \"AB\"\np1 &lt;- FeaturePlot(combined, \"CD19-CD19-AHS0030-pAbO\", \n                  cols = c(\"lightgrey\", \"darkgreen\"), \n                  reduction = 'wnn.umap')\n\n# switch default to RNA to plot gene expression\nDefaultAssay(combined) &lt;- \"RNA\"\np2 &lt;- FeaturePlot(combined, \"CD19\", reduction = 'wnn.umap')\n\n# place plots side-by-side\np1 | p2\n\n\n\n\n4. Save\nSave the files into RData for documentation.\n\n# save(combined, expMat, ab, integrate.filtered.rna, file = \"data/intermediate_data/chapter9.RData\")"
  },
  {
    "objectID": "05_clustering.html",
    "href": "05_clustering.html",
    "title": "Chapter 5 Clustering",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(clustree)\nlibrary(HGNChelper)\n\nLoad RData\nLoad the RData which contains all files from the previous chapter.\n\nload(\"data/intermediate_data/chapter4.RData\")\n\n1. Clustering\nNow that we have our high quality cells integrated, we want to know the different cell types present within our population of cells.\nSeurat uses a graph-based clustering approach, which embeds cells in a graph structure, using a K-nearest neighbor (KNN) graph (by default), with edges drawn between cells with similar gene expression patterns. Then, it attempts to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.\nWe will use the FindClusters function to perform the graph-based clustering. The resolution is an important argument that sets the “granularity” of the downstream clustering and will need to be optimized for every individual experiment.\n\n\n\n\n\n\nImportant\n\n\n\nIncreasing resolution value leads to a greater number of clusters, which is often required for larger datasets.\n\n\nThe FindClusters function allows us to enter a series of resolutions and will calculate the “granularity” of the clustering. This is very helpful for testing which resolution works for moving forward without having to run the function for each resolution.\n\n# Determine the K-nearest neighbor graph\nintegrate.filtered.rna &lt;- FindNeighbors(object = integrate.filtered.rna, dims = 1:10)\n                                \n# Determine the clusters for various resolutions                                \nintegrate.filtered.rna &lt;- FindClusters(object = integrate.filtered.rna,\n                                       resolution = c(0.2, 0.4, 0.6,  0.8, 1, 1.2, 1.4),\n                                       verbose = F)\n\nThe meta.data has a separate column for each of the different resolution calculated. We can look at how many clusters in each resolution.\n\nintegrate.filtered.rna@meta.data %&gt;% \n  dplyr::select(contains(\"integrat\")) %&gt;% \n  map_int(~ unique(.x) %&gt;% length)\n\nintegrated_snn_res.0.2 integrated_snn_res.0.4 integrated_snn_res.0.6 \n                     9                     11                     13 \nintegrated_snn_res.0.8   integrated_snn_res.1 integrated_snn_res.1.2 \n                    15                     16                     17 \nintegrated_snn_res.1.4 \n                    19 \n\n\n\nclustree(integrate.filtered.rna, prefix = \"integrated_snn_res.\")\n\n\n\n\nWe start with the resolution of 0.6. We assign the identity of the clusters using the Idents function to specify that we want to look at the clusters calculating with resolution = 0.6.\n\nIdents(object = integrate.filtered.rna) &lt;- \"integrated_snn_res.0.6\"\n\n# UMAP visualization\nDimPlot(integrate.filtered.rna,\n        reduction = \"umap\",\n        label = TRUE,\n        label.size = 6)\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nChange to other resolution values. How do the clusters change?\n\n\n2. Distribution of cells per cluster\nThe number of clusters are sensitive to the resolution. The demo dataset has PBMC and we expect each cluster contains cells from both samples.\n\nFetchData(integrate.filtered.rna, \n          vars = c(\"ident\", \"Sample_Name\")) %&gt;%\n  dplyr::count(ident, Sample_Name) %&gt;%\n  tidyr::spread(ident, n)\n\n  Sample_Name   0   1   2   3   4   5   6   7  8  9 10 11 12\n1       naive 355 243 428 226   8   5 281  70 96 62 13 35 28\n2     treated 508 332 140 217 322 304  14 177 53 71 82 59 31\n\n\nWe can split the UMAP by sample.\n\n# UMAP of cells in each cluster by sample\nDimPlot(integrate.filtered.rna, \n        label = TRUE, \n        split.by = \"Sample_Name\")  + NoLegend()\n\n\n\n\n3. Exploring known cell type markers\nWe can explore some known cell type markers to get an idea about the identity of clusters.\nSome typical cell type markers:\n\nCD14+ monocytes: CD14, LYZ\nConventional dendritic cells: FCER1A, CST3\nB cells: CD79A, MS4A1\nT cells: CD3D\nCD4+ T cells: CD3D, IL7R, CCR7\nCD8+ T cells: CD3D, CD8A\nNK cells: GNLY, NKG7\nMacrophages: MARCO, ITGAM, ADGRE1\n\nThe FeaturePlot makes it easy to visualize a handful of genes using the gene IDs stored in the Seurat object. We can easily explore the expression of known gene markers on top of our UMAPs. Let’s go through and determine the identities of the clusters. To access the normalized expression levels of all genes, we can use the normalized counts stored in the RNA assay slot.\n\nDefaultAssay(integrate.filtered.rna) &lt;- \"RNA\"\n\n\nCD14+ monocytes: CD14, LYZ\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD14\", \"LYZ\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nB cells: CD79A, MS4A1\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD79A\", \"MS4A1\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nNK cells: GNLY, NKG7\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"GNLY\", \"NKG7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nT cells: CD3D\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nCD4+ T cells: CD3D, IL7R, CCR7\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"IL7R\", \"CCR7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nCD8+ T cells: CD3D, CD8A\n\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"CD8A\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n4. Save\nSave the files into RData for documentation.\n\n# save(integrate.filtered.rna, expMat, file = \"data/intermediate_data/chapter5.RData\")"
  },
  {
    "objectID": "06_marker_identification.html",
    "href": "06_marker_identification.html",
    "title": "Chapter 6 Marker Identification",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(HGNChelper)"
  },
  {
    "objectID": "06_marker_identification.html#findallmarkers",
    "href": "06_marker_identification.html#findallmarkers",
    "title": "Chapter 6 Marker Identification",
    "section": "1.1 FindAllMarkers\n",
    "text": "1.1 FindAllMarkers\n\nThis type of analysis is typically for evaluating a single sample group/condition. With the FindAllMarkers function, we are comparing each cluster to all other clusters to identify potential marker genes. The cells in each cluster are treated as replicates, and essentially a differential expression analysis is performed with some statistical test. By default, the test is Wilcoxon Rank Sum test.\nThe FindAllMarkers function has three arguments to determine if a gene is a marker gene.\n\nlogfc.threshold Limit testing to genes that show, on average, at least an X-fold difference (log-scale) between the two groups of cells. The default is 0.25. Increasing logfc.threshold speeds up the function but can miss weaker signals.\nmin.pct Only test genes that are detected in a minimum fraction of cells in either of the two populations. It is meant to speed up the function by not testing infrequently expressed genes. The default is 0.1.\nonly.pos Only return positive markers (FALSE by default).\n\nOne may change the arguments depending on how stringent to be.\nWe look at the marker genes in the clusters in sample “treated”.\n\ntreated.markers &lt;- FindAllMarkers(subset(integrate.filtered.rna, subset = Sample_Name == \"treated\"), \n                                  assay = \"RNA\",\n                                  only.pos = TRUE, \n                                  min.pct = 0.25, \n                                  logfc.threshold = 0.25)\n\nLet’s look at the top 2 significant marker genes in each cluster.\n\ntreated.markers %&gt;%\n    group_by(cluster) %&gt;%\n    slice_max(n = 2, order_by = avg_log2FC)\n\n# A tibble: 26 × 7\n# Groups:   cluster [13]\n       p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene      \n       &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;     \n 1 9.89e-158       2.63 0.744 0.212 1.91e-153 0       MAL       \n 2 3.62e-104       2.10 0.734 0.379 7.01e-100 0       PCED1B-AS1\n 3 0               5.06 0.961 0.055 0         1       GNLY      \n 4 3.65e-259       4.13 0.892 0.108 7.07e-255 1       CCL5      \n 5 5.52e- 12       1.07 0.75  0.515 1.07e-  7 2       HSPD1     \n 6 6.86e- 17       1.00 0.957 0.787 1.33e- 12 2       NPM1      \n 7 5.53e- 82       2.41 0.594 0.119 1.07e- 77 3       RGS1      \n 8 5.81e- 25       1.82 0.304 0.09  1.12e- 20 3       FOXP3     \n 9 1.24e-122       2.25 0.916 0.276 2.39e-118 4       LTA       \n10 1.65e-159       1.97 0.941 0.225 3.20e-155 4       MIR155HG  \n# ℹ 16 more rows\n\n\nWe get a table with the information on marker genes.\np_val P-value before multiple testing.\navg_log2FC Log2 fold change on the average gene expression between one cluster and the rest of cluster combined.\npct.1 Percentage of cells expressing the gene in one group. Here is one cluster.\npct.2 Percentage of cells expressing the gene in another group. Here is the rest of cluster combined.\np_val_adj p-value with multiple testing correction."
  },
  {
    "objectID": "06_marker_identification.html#findconservedmarkers",
    "href": "06_marker_identification.html#findconservedmarkers",
    "title": "Chapter 6 Marker Identification",
    "section": "1.2 FindConservedMarkers\n",
    "text": "1.2 FindConservedMarkers\n\nWe have two samples, naïve and treated. We can find conserved markers between the conditions with the function, FindConservedMarkers.\nThis function internally separates out cells by sample group/condition, then performs differential gene expression testing for a single specified cluster against all other clusters.\nGene-level p-values are computed for each condition and then combined across groups using meta-analysis methods from the MetaDE R package.\nMany of the arguments in FindConservedMarkers are shared with FindAllMarkers. Here, we list some additional arguments when using FindConservedMarkers.\n\nident.1 This function only evaluates one cluster at a time; here, you would specify the cluster of interest.\ngrouping.var The variable (column name) in your metadata specifies the separation of cells into groups.\n\n\nfcm &lt;- FindConservedMarkers(integrate.filtered.rna,\n                     assay = \"RNA\",\n                     ident.1 = \"1\",\n                     grouping.var = \"Sample_Name\",\n                     only.pos = TRUE,\n                     min.diff.pct = 0.25,\n                     min.pct = 0.25,\n                     logfc.threshold = 0.25)\n\nhead(fcm)\n\n       naive_p_val naive_avg_log2FC naive_pct.1 naive_pct.2 naive_p_val_adj\nGNLY  0.000000e+00         4.823298       0.947       0.024    0.000000e+00\nGZMA 8.973490e-245         3.778985       0.835       0.041   1.736101e-240\nPRF1 1.103550e-125         2.671046       0.453       0.021   2.135038e-121\nNKG7 1.504853e-212         3.572770       0.823       0.060   2.911439e-208\nCCL5 9.363098e-161         3.319940       0.852       0.120   1.811479e-156\nCST7 5.390018e-149         3.014122       0.634       0.053   1.042807e-144\n     treated_p_val treated_avg_log2FC treated_pct.1 treated_pct.2\nGNLY  0.000000e+00           5.060457         0.961         0.055\nGZMA  0.000000e+00           3.813904         0.976         0.082\nPRF1  0.000000e+00           3.855625         0.907         0.068\nNKG7 8.396253e-261           3.398566         0.982         0.150\nCCL5 3.653151e-259           4.133251         0.892         0.108\nCST7 6.882951e-236           3.135928         0.759         0.068\n     treated_p_val_adj      max_pval minimump_p_val\nGNLY      0.000000e+00  0.000000e+00   0.000000e+00\nGZMA      0.000000e+00 8.973490e-245   0.000000e+00\nPRF1      0.000000e+00 1.103550e-125   0.000000e+00\nNKG7     1.624423e-256 1.504853e-212  1.679251e-260\nCCL5     7.067750e-255 9.363098e-161  7.306301e-259\nCST7     1.331645e-231 5.390018e-149  1.376590e-235\n\n\nWe also get a table with information on marker genes. The statistics are computed for each group (naïve vs. treated), and the last two columns are the combined p-value across the two groups.\n\ncondition_p_val P-value before multiple testing.\ncondition_avg_log2FC Log2 fold change on the average of gene expression between one cluster and the rest of the clusters combined.\ncondition_pct.1 Percentage of cells expressing the gene in one group.\ncondition_pct.2 Percentage of cells expressing the gene in another group.\ncondition_p_val_adj P-value with multiple testing correction.\n\n\n\n\n\n\n\nNote\n\n\n\nThe more significant the difference between pct.1 and pct.2, the higher the confidence for the marker gene. If pct.1 is 0.9 and pct.2 is 0.8, it is not as interesting as if pct.2 is 0.1.\nMarker genes express in a specific cell type. If pct.1 is low, such as 0.3, it is not as interesting as if it is 0.9.\n\n\nWe can visualize the marker gene expression by FeaturePlot and VlnPlot.\n\nFeaturePlot(object = integrate.filtered.rna, \n            features = c(\"GNLY\", \"GZMA\"),\n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE,\n            repel = TRUE)\n\n\n\n\n\nVlnPlot(object = integrate.filtered.rna, \n        features = c(\"GNLY\", \"GZMA\"),\n        stack = T, flip = T)"
  },
  {
    "objectID": "06_marker_identification.html#findmarkers",
    "href": "06_marker_identification.html#findmarkers",
    "title": "Chapter 6 Marker Identification",
    "section": "1.3 FindMarkers\n",
    "text": "1.3 FindMarkers\n\nWe can use the FindMarkers to determine the differentially expressed genes between two clusters.\n\nexample_findmarkers &lt;- FindMarkers(integrate.filtered.rna,\n                          assay = \"RNA\",\n                          ident.1 = 1,\n                          ident.2 = 2) %&gt;% \n  rownames_to_column(\"gene\")"
  },
  {
    "objectID": "06_marker_identification.html#reference-based",
    "href": "06_marker_identification.html#reference-based",
    "title": "Chapter 6 Marker Identification",
    "section": "2.1 Reference-based",
    "text": "2.1 Reference-based\nWe look at the publicly available dataset with annotation and build a reference set based on its information. Then we can “transfer” the annotation from the reference to the query. Seurat provides the interface to connect with Azimuth.\n\n\n\n\n\n\nNote\n\n\n\nBecause the annotation information is based on the reference set, the reference ideally is similar to the query. They may come from the same tissue, same organism, similar experimental procedure, etc.\n\n\n\nintegrate.filtered.rna &lt;- Azimuth::RunAzimuth(integrate.filtered.rna,\n                                              reference = \"pbmcref\",\n                                              verbose = F)\n\nAn AzimuthData object - reference version: 1.0.0 \nContains 3 meta.data field(s) to transfer.\n\n\nWe can look at the automatic annotation on UMAP.\n\np1 &lt;- DimPlot(integrate.filtered.rna, reduction = \"umap\", \n              group.by = \"predicted.celltype.l1\", \n              label = TRUE, label.size = 3 ,repel = TRUE) + \n  NoLegend()\n\np2 &lt;- DimPlot(integrate.filtered.rna, reduction = \"umap\", \n              group.by = \"integrated_snn_res.0.6\", \n              label = TRUE, label.size = 3 ,repel = TRUE) + \n  NoLegend()\n\np1|p2"
  },
  {
    "objectID": "06_marker_identification.html#marker-based",
    "href": "06_marker_identification.html#marker-based",
    "title": "Chapter 6 Marker Identification",
    "section": "2.1 Marker-based",
    "text": "2.1 Marker-based\nWe use ScType (https://github.com/IanevskiAleksandr/sc-type/blob/master/README.md) to annotate cell population based on known immune markers.\nScType also has an open source portal: https://sctype.app/.\n\n# load ScType R functions\nsource(\"https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R\"); source(\"https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R\")\n\n# get cell-type-specific gene sets from our in-built database (DB)\n# list downloaded from https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_short.xlsx\n# e.g. Immune system, Liver, Pancreas, Kidney, Eye, Brain\ngs_list &lt;-  gene_sets_prepare(\"data/ScTypeDB_short.xlsx\", \"Immune system\") \n\n# assign cell types\n# NOTE: scRNAseqData parameter should correspond to your input scRNA-seq matrix. \n# In case Seurat is used, it is either pbmc[[\"RNA\"]]@scale.data (default), pbmc[[\"SCT\"]]@scale.data, in case sctransform is used for normalization,\n# or pbmc[[\"integrated\"]]@scale.data, in case a joint analysis of multiple single-cell datasets is performed.\nes.max &lt;-  sctype_score(scRNAseqData = integrate.filtered.rna@assays[[\"integrated\"]]@scale.data, \n                        scaled = TRUE, \n                        gs = gs_list$gs_positive, \n                        gs2 = gs_list$gs_negative)\n\n# merge by cluster\ncL_resutls = do.call(\"rbind\", lapply(unique(integrate.filtered.rna@meta.data$integrated_snn_res.0.6), function(cl){\n    es.max.cl = sort(rowSums(es.max[ ,rownames(integrate.filtered.rna@meta.data[integrate.filtered.rna@meta.data$integrated_snn_res.0.6==cl, ])]), decreasing = !0)\n    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(integrate.filtered.rna@meta.data$integrate.filtered.rna==cl)), 10)\n}))\n\nsctype_scores = cL_resutls %&gt;% group_by(cluster) %&gt;% top_n(n = 1, wt = scores)  \n\n# set low-confident (low ScType score) clusters to \"unknown\"\nsctype_scores$type[as.numeric(as.character(sctype_scores$scores)) &lt; sctype_scores$ncells/4] = \"Unknown\"\n\n\nintegrate.filtered.rna@meta.data$customclassif = \"\"\n\nfor(j in unique(sctype_scores$cluster)){\n  cl_type = sctype_scores[sctype_scores$cluster==j,]; \n  integrate.filtered.rna@meta.data$customclassif[integrate.filtered.rna@meta.data$integrated_snn_res.0.6 == j] = as.character(cl_type$type[1])\n}\n\nDimPlot(integrate.filtered.rna, reduction = \"umap\", label = TRUE, repel = TRUE, group.by = 'customclassif')"
  },
  {
    "objectID": "07_differential_expression_analysis.html",
    "href": "07_differential_expression_analysis.html",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(ggpubr)"
  },
  {
    "objectID": "07_differential_expression_analysis.html#setup",
    "href": "07_differential_expression_analysis.html#setup",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.1 Setup",
    "text": "2.1 Setup\nLet’s assume we have three biological replicates in each condition (we make them up for the purpose of illustration).\n\n# make a fake group information\nintegrate.filtered.rna$group &lt;- sample(x = c('A', 'B', 'C'), size = ncol(integrate.filtered.rna), replace = TRUE)\n\n# pseudo-bulk by per condition per cell type\ncd4t.bulk &lt;- Seurat:::PseudobulkExpression(integrate.filtered.rna, \n                                        assays = \"RNA\",\n                                     pb.method = 'aggregate',\n                                     group.by = c('Sample_Name', 'predicted.celltype.l1', 'group'),\n                                     slot = \"counts\",\n                                     return.seurat = T)\n  \n# tidy up names\ncd4t.bulk$Sample_Name &lt;- cd4t.bulk %&gt;% colnames() %&gt;% \n  str_split(., pattern = \"_\") %&gt;% \n  lapply(., \"[\", 1) %&gt;% \n  unlist()\n\ncd4t.bulk$cellType &lt;- cd4t.bulk %&gt;% colnames() %&gt;% \n  str_split(., pattern = \"_\") %&gt;% \n  lapply(., \"[\", 2) %&gt;% \n  unlist\n\ncd4t.bulk$celltype.stim &lt;- paste(cd4t.bulk$Sample_Name, cd4t.bulk$cellType, sep = \"_\")\n\n# perform pseudobulk\nIdents(cd4t.bulk) &lt;- \"celltype.stim\"\n\ncd4t.bulk &lt;- FindMarkers(cd4t.bulk, \n                         ident.1 = \"treated_CD4 T\", \n                         ident.2 = \"naive_CD4 T\", \n                         test.use = \"DESeq2\")\n\n\n# compare the DE P-values between the single-cell level and the pseudobulk level results\ncd4t.bulk &lt;- cd4t.bulk %&gt;% \n  `colnames&lt;-`(paste0(names(cd4t.bulk), \".bulk\")) %&gt;% \n  mutate(gene = rownames(cd4t.bulk))\n\ncd4t.sc &lt;- cd4t.sc %&gt;% \n  `colnames&lt;-`(paste0(names(cd4t.sc), \".sc\")) %&gt;% \n  mutate(gene = rownames(cd4t.sc))\n\nmerge_dat &lt;- merge(cd4t.bulk, cd4t.sc, by = \"gene\") %&gt;% \n  arrange(p_val.bulk)\n\n# Number of genes that are marginally significant in both; marginally significant only in bulk; and marginally significant only in single-cell\ncommon &lt;- merge_dat$gene[which(merge_dat$p_val.bulk &lt; 0.05 & \n                                merge_dat$p_val.sc &lt; 0.05)]\nonly_sc &lt;- merge_dat$gene[which(merge_dat$p_val.bulk &gt; 0.05 & \n                                  merge_dat$p_val.sc &lt; 0.05)]\nonly_bulk &lt;- merge_dat$gene[which(merge_dat$p_val.bulk &lt; 0.05 & \n                                    merge_dat$p_val.sc &gt; 0.05)]\n\nThe majority of DEGs are shared in both pseudobulk and single-cell analysis. The log2FC is also correlated.\n\nggscatter(merge_dat, x = \"avg_log2FC.bulk\", y = \"avg_log2FC.sc\", \n          add = \"reg.line\", conf.int = TRUE, \n          cor.coef = TRUE, cor.method = \"pearson\")"
  },
  {
    "objectID": "07_differential_expression_analysis.html#select-cell-groups",
    "href": "07_differential_expression_analysis.html#select-cell-groups",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.2 Select cell groups",
    "text": "2.2 Select cell groups\nLet’s take a look at the cell type annotation in UMAP.\n\n# # visualize cell types in UMAP\n# DimPlot(integrate.filtered.rna, \n#         reduction = \"umap\", \n#         group.by = \"predicted.celltype.l1\", \n#         label = TRUE, \n#         label.size = 3,\n#         repel = TRUE, \n#         split.by = \"Sample_Name\") + NoLegend()\n\nWe see some of the cell types have only a few cells.\nLet’s look at how many cells are in each cell type per dummy group.\n\n# Cell counts in per cell type per group\nFetchData(integrate.filtered.rna, \n                     vars = c(\"predicted.celltype.l1\", \"dummy_group\", \"Sample_Name\")) %&gt;%\n  dplyr::count(predicted.celltype.l1, Sample_Name, dummy_group) %&gt;%\n  tidyr::spread(predicted.celltype.l1, n)\n\n  Sample_Name dummy_group  B CD4 T CD8 T DC Mono  NK other other T\n1       naive     naive_1 22   309    65  3  127  68    19      14\n2       naive     naive_2 22   302    54  5  118  75    17       3\n3       naive     naive_3 24   311    58  4  113  93    12      12\n4     treated   treated_1 61   501    34 NA   36 137    15       1\n5     treated   treated_2 61   478    21 NA   35 123    21       2\n6     treated   treated_3 57   502    27 NA   36 137    22       3\n\n\nDendritic cells, other T cells, and the group of other don’t have sufficient cells per dummy group. For demonstration, we will not include these cell types for pseudo-bulk analysis. We will focus on “CD4 T”, “Mono”, and “NK”.\n\nsubset.rna &lt;- subset(integrate.filtered.rna, \n                     subset = predicted.celltype.l1 %in% \n                       c(\"CD4 T\", \"Mono\", \"NK\"))"
  },
  {
    "objectID": "07_differential_expression_analysis.html#setup-singlecellexperiment",
    "href": "07_differential_expression_analysis.html#setup-singlecellexperiment",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.3 Setup SingleCellExperiment\n",
    "text": "2.3 Setup SingleCellExperiment\n\nThe muscat package requires the input object as the SingleCellExperiment object. We first transform the Seurat object into SCE object.\nmuscat requires three pieces of meta data information: sample_id sample IDs, corresponds to dummy_group in the meta.data cluster_id cell types, corresponds to predicted.celltype.l1 in the meta.data group_id sample groups, corresponds to sample in the meta.data\nLet’s first tidy up the meta data.\n\nsubset.rna@meta.data &lt;- subset.rna@meta.data %&gt;% \n  dplyr::select(Sample_Name, predicted.celltype.l1, dummy_group) %&gt;% \n  `colnames&lt;-`(c(\"group_id\", \"cluster_id\", \"sample_id\"))\n\nSeurat has a convenient function to convert Seurat object into SingleCellExperiment object, as.SingleCellExperiment.\n\n# construct experiment_info\nexperiment_info &lt;- subset.rna@meta.data %&gt;% \n  group_by(sample_id, group_id) %&gt;% \n  dplyr::summarise(n_cells = length(group_id))\n\n# convert seurat object into SingleCellExperiment object\nsubset.rna &lt;- as.SingleCellExperiment(subset.rna, assay = \"RNA\")\n\nThe SCE object doesn’t contain the experiment_info. We add the information into the SCE object.\n\n# assign experiment info into the created SingleCellExperiment\nsubset.rna@metadata[[\"experiment_info\"]] &lt;- experiment_info"
  },
  {
    "objectID": "07_differential_expression_analysis.html#aggregation",
    "href": "07_differential_expression_analysis.html#aggregation",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.4 Aggregation",
    "text": "2.4 Aggregation\nWe first aggregate measurements for each sample (in each cell type) to obtain pseudobulk data.\n\n# aggregate counts per cell type per dummy group\nsubset.pb &lt;- aggregateData(subset.rna,\n                           assay = \"counts\", \n                           fun = \"sum\",\n                           by = c(\"cluster_id\", \"sample_id\"))\n\nWe can look at how the pseudobulk samples cluster on the MDS plot.\n\nmuscat::pbMDS(subset.pb)\n\n\n\n\nNext, we can run DS analysis by specifying method as DESeq2.\n\n# change group_id into a factor\nsubset.pb$group_id &lt;- subset.pb$group_id %&gt;% factor(levels = c(\"treated\", \"naive\"))\n\n# run DS analysis with DESeq2\nres &lt;- pbDS(subset.pb, method = \"DESeq2\", verbose = F)\n\nThe result is stored in the table slot of res.\nWe will focus on the deferentially expressed genes in CD4 T cells.\n\ncd4t &lt;- res$table$naive$`CD4 T`\n\n# Filter the results with p_adj.loc &lt; 0.05, abs(logFC) &gt; 1\ncd4t.sig &lt;- dplyr::filter(cd4t, p_adj.loc &lt; 0.05, abs(logFC) &gt; 1) %&gt;% \n  arrange(p_adj.loc)\n\nhead(cd4t.sig)\n\n      gene cluster_id baseMean     logFC      lfcSE      stat p_val p_adj.loc\n1    ACTG1      CD4 T 2668.781 -2.659041 0.06523691 -40.75976     0         0\n2     ENO1      CD4 T 1551.952 -3.948824 0.10421979 -37.88939     0         0\n3 HSP90AA1      CD4 T 3313.136 -3.417375 0.07281262 -46.93383     0         0\n4 HSP90AB1      CD4 T 3142.790 -3.156739 0.06430620 -49.08919     0         0\n5     IL7R      CD4 T 1673.366  3.774151 0.05618277  67.17631     0         0\n6   MALAT1      CD4 T 2329.629  2.337009 0.05494380  42.53454     0         0\n  p_adj.glb contrast\n1         0    naive\n2         0    naive\n3         0    naive\n4         0    naive\n5         0    naive\n6         0    naive\n\n\n\np_adj.loc is produced by correcting for multiple testing across all genes tested within a cluster.\np_adj.glb is produced by correcting for multiple testing across all genes tested in all clusters.\n\nWe can plot the DEGs from CD4+ T cells in a heatmap.\n\n# scale the RNA data\nintegrate.filtered.rna &lt;- ScaleData(integrate.filtered.rna, features = rownames(integrate.filtered.rna), assay = \"RNA\")\n\n# plot heatmap\nintegrate.filtered.rna %&gt;%\n  subset(., subset = predicted.celltype.l1 == \"CD4 T\") %&gt;% \n  DoHeatmap(features = cd4t.sig$gene[1:40])"
  },
  {
    "objectID": "08_enrichment_analysis.html",
    "href": "08_enrichment_analysis.html",
    "title": "Chapter 8 Enrichment Analysis",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(org.Hs.eg.db)\nlibrary(clusterProfiler)\nlibrary(AnnotationDbi)\nlibrary(enrichplot)\nlibrary(biomaRt)\n\nLoad RData\nLoad the RData which contains all files from the previous chapter.\n\nload(\"data/intermediate_data/chapter7.RData\")\n\nOftentimes, enrichment analysis takes the differentially expressed genes and looks at which gene ontology (GO) terms are enriched.\nGO terms defines concepts/classes used to describe gene function and relationships between these concepts. clusterProfiler is an R package implementing many methods to analyze and visualize functional profiles from a group of features. It classifies functions in three aspects.\n\nMF: Molecular Function: molecular activities of gene products.\nCC: Cellular Component: where gene products are active.\nBP: Biological Process: pathways and larger processes made up of the activities of multiple gene products.\n\nThis chapter uses the differentially expressed genes in CD4+ T cells from last chapter as an example.\n1. Get Entrez ID\nclusterProfiler prefers the input of Entrez ID. We use biomaRt package to convert the gene symbol into Entrez ID.\n\n\n\n\n\n\nNote\n\n\n\nbiomaRt is handy to get information about features. You can use it to get gene symbols, genomic coordinates, transcript sequences, etc. You can explore what data is stored in biomaRt with listAttributes.\n\n\nThe differentially expressed genes in CD4+ T cells between naïve and treated PBMCs are stored in the matrix cd4t. The gene symbol in this list can be converted into Entrez ID by biomaRt.\nFirstly, connect to the Ensembl database and specify we want to retrieve information from the dataset of Homo Sapien.\n\nmart &lt;- useMart(biomart = \"ensembl\", dataset = \"hsapiens_gene_ensembl\")\n\n\nbiomart BioMart database connect to. Here, we want to connect to ensembl database.\ndataset Dataset to use. Here specify hsapiens_gene_ensembl.\n\nNext, we can give a list of gene symbols and retrieve the Entrez ID through getBM.\n\nresults &lt;- getBM(attributes = c(\"entrezgene_id\", \"external_gene_name\"),\n                 filters = \"external_gene_name\", \n                 values = cd4t.bulk$gene,\n                 mart = mart)\n\n\nattributes Attributes to retrieve. We want to have the gene symbols and Entrez ID in the results.\nfilters Which filter to use to filter the dataset.\nvalues A list of features as a query.\nmart Object of class Mart, created with the useMart function.\n\nA table of two columns is created and stored in the matrix of results.\n\nresults %&gt;% head\n\n  entrezgene_id external_gene_name\n1         81532               MOB2\n2         79602            ADIPOR2\n3        196513              DCP1B\n4         55449          DHRS4-AS1\n5         80344             DCAF11\n6         51016               EMC9\n\n\nNot every gene has the Entrez ID. We keep only genes that have a matched Entrez ID.\n\ncd4t.bulk &lt;- left_join(cd4t.bulk, results, by = c(\"gene\" = \"external_gene_name\")) %&gt;% \n  filter(!is.na(entrezgene_id)) %&gt;% \n  filter(!is.na(p_val_adj.bulk))\n\n2. GO over-representation analysis\nOver Representation Analysis (ORA) is a widely used approach to determine whether known biological functions or processes are over-represented (= enriched) in an experimentally-derived gene list, e.g. a list of differentially expressed genes (DEGs).\nWe use the enrichGO to get the enriched GO terms in the list of DEGs.\n\ncd4t.bulk.sig &lt;- dplyr::filter(cd4t.bulk, p_val_adj.bulk &lt; 0.01, abs(avg_log2FC.bulk) &gt; 1)\n\n# get the enriched GO terms\nego &lt;- enrichGO(gene = cd4t.bulk.sig$entrezgene_id,\n                keyType = \"ENTREZID\",\n                OrgDb = org.Hs.eg.db,\n                ont = \"BP\",\n                pAdjustMethod = \"BH\",\n                pvalueCutoff = 0.01,\n                qvalueCutoff = 0.05,\n                readable = TRUE)\n\n\ngene A list of Entrez gene id.\nkeyType The keytype of input gene.\nOrgDb The database with detailed information about the species.\norg.Hs.eg.db Specify the database of Homo Sapien.\nont One of “BP” (biological process), “MF” (molecular function), and “CC” (cellular component) subontologies, or “ALL” for all three.\npAdjustMethod Multiple testing method for p-value.\npvalueCutoff Adjusted pvalue cutoff on enrichment tests to report.\nqvalueCutoff Tge qvalue cutoff on enrichment tests to report as significant.\nreadable Whether mapping gene ID to gene Name.\n\nLet’s convert the ego object into a data frame and visualize the results in a bar plot.\n\nego.table &lt;- as.data.frame(ego)\n\n\nGeneRatio The gene counts from the input list found in the gene set of a GO term / gene counts of input list.\nBgRatio The gene counts of a geneset / size of all of the unique genes in the collection of genesets.\n\n\nfilter(ego, Description %in% grep(\"T cell\", ego.table$Description, ignore.case = T, value = T)) %&gt;% \nbarplot(showCategory = 18)\n\n\n\n\n3. Gene set enrichment analysis - Optional\nAll genes can be used as input of gene set enrichment analysis (GSEA). We first rank the genes based on stat.\n\n# order genes\ncd4t.bulk &lt;- cd4t.bulk[order(-cd4t.bulk$avg_log2FC.bulk), ]\n\ngene_list &lt;- cd4t.bulk$avg_log2FC.bulk\nnames(gene_list) &lt;- cd4t.bulk$entrezgene_id\n\nWe use gseGO to perform GSEA and convert the results into a dataframe.\n\n# perform GSEA\ngse &lt;- gseGO(gene_list,\n             keyType = \"ENTREZID\",\n             ont = \"BP\",\n             OrgDb = \"org.Hs.eg.db\")\n\n# convert the results into a dataframe\ngse.table &lt;- as.data.frame(gse) %&gt;% \n  mutate(geneSetID = 1:dim(.)[1])\n\nenrichmentScore The enrichment score (ES) represents the degree to which a set S is over-represented at the top or bottom of the ranked list L.\nWe can look at the enrichment of some GO terms in GSEA plot.\n\ngseaplot2(gse, geneSetID = c(509, 526))\n\n\n\n\nWe have significant enriched term in the unregulated genes. Along the x axis is the ranked genes. Each of the vertical line is one of those genes that are found in this gene set. Along the running line, you can see a lot of genes running together and it falls out when the gene becomes more sparse in the list.\n4. Save\nSave the files into RData for documentation.\n\n# save.image(file = \"data/intermediate_data/chapter8.RData\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "How to use the materials?\nThis repository contains the teaching materials for the Single Cell Boot Camp - Analyzing scRNA-seq with R.\nIt has:\nTwo chapters of precourse preparation: Precourse Preparation - R / Theory\nNine chapters of the analysis workflow: Chapter 1 - 9.\n\n\n\n\n\n\nImportant\n\n\n\nStudents who go through the teaching materials and run the code on their local desktops will have a much better learning outcome.\nAs we are NOT going to cover the R programming and SOLELY focusing on the analysis workflow, this is particularly important for students who are not familiar with R. So, please do block some time and try to digest the materials before attending the Boot Camp.\nIf you are familiar with R, you can skip the Precourse Preparation and jump to Chapter 1 - 9.\n\n\nFor further information, suggestions and bug report, please contact: biox_support_emea@bd.com\n\n\nDescription\nThe Single Cell Boot Camp: Analysis of scRNA-seq with R is to provide an overview of the analysis of single-cell RNA-seq using R. It is designed for early-stage researchers who want to adopt single-cell analysis in their toolbox. The workshop consists of theory in presentation and application in hands-on practice.\nThe workshop starts with a fast-paced training session on the common workflow of single-cell RNA-seq analysis, then continues with sessions on the common workflow of scRNA-seq using bioinformatics packages like Seurat.\n\n\nPrerequisites\nEach participant are expected to have:\n1. An introductory background in statistics, specifically in the below concepts: Median, log2 fold change, p-value, adjusted p-value, variance, PCA.\n2. Basic familiarity with R and tidyr package, specifically in the below functions: %&gt;% (pipe), filter, mutate, pivot_longer, pivot_wider, map, pmap, select, left_join.\nIf you would like to learn on your own with publicly available resources:\nChapter 1 - 4 from MordernDive.\n\nIf you would like to participate in an instructor-led R course:\nR for Biologist from Edinburgh Genomics. For details, please contact Edinburgh Genomics.\n\n\nExpected outcome\nBy the end of the workshop, participants will be familiar with the following topics: Common workflow of single cell analysis (pre-processing, quality control, filtering, normalization, Clustering, Cell type annotation).\n\n\nReference\nThe building of materials for the course references and relies on many excellent and well written public avaialbe materials.\n\nSeurat https://satijalab.org/seurat/\nSingle Cell Best Practices: https://www.sc-best-practices.org/preamble.html\nOrchestrating Single-Cell Analysis with Bioconductor: https://bioconductor.org/books/release/OSCA/\nMary Piper, Meeta Mistry, Jihe Liu, William Gammerdinger, & Radhika Khetani. (2022, January 6). hbctraining/scRNA-seq_online: scRNA-seq Lessons from HCBC (first release). Zenodo. https://doi.org/10.5281/zenodo.5826256\n\n\n\nDisclaimer\nRecommendations given by representatives of BD in the context of the creation and setup of customer-specific applications and assays, the composition of antibody panels and suggestions for data analysis are provided in a diligent manner. However, the Customer acknowledges that (i) such recommendations should not be treated as a substitute for the Customer’s own examination, (ii) BD does not make any promises nor guarantees that recommendations are accurate and complete and will meet the Customer’s present or future needs or will produce positive or specific results and (iii) Customer remains solely responsible for validating and deciding on any such recommendations.\nBD therefore accepts no liability whatsoever in connection with any such recommendation and/or any results generated on the basis of such recommendations and, to the fullest extent permitted by law, expressly disclaims any and all warranties and any liability in this respect. In particular, the Customer assumes sole responsibility for the validation, use, selection, and suitability of the recommendations for its needs and objectives.\n\n\nLicense\nSee the LICENSE file for license rights and limitations (MIT)."
  },
  {
    "objectID": "precourse_preparation_R.html#what-is-a-data-frame",
    "href": "precourse_preparation_R.html#what-is-a-data-frame",
    "title": "Precourse Preparation - R",
    "section": "1.1 What is a data frame?",
    "text": "1.1 What is a data frame?\nData frame is a data structure in R that stores values of any type. You can think of it as a table with columns and rows storing the data as in the below example.\n\nCredit: https://www.geeksforgeeks.org/r-data-frames/\nOften in data science language, the columns are variables, the rows are observations and each entry in a table is a value.\nSome of the most common examples of input files that can be loaded into R as data frames are spreadsheets, TSVs, or CSVs files. TSV and CSV stands for tab-separated or coma-separated values.\nAnother way to view data frame is as a list of vectors of the same length. The vector can be defined as a type of data structure that contains elements of the same type. Below you can find example on how to create the table presented in the beyond figer from vectors.\n\n## Define vectors which will be used to create the data frame\n\n## Vector of names\nName &lt;- c(\"Avrey Bradley\",\"John Holland\",\"Jonas Jerebko\",\"Jordan Midkey\",\"Terry Rozier\",\"Jared Sullinger\",\"Evan Turner\")\n\n## Vector of team's names\nTeam &lt;- c(\"Boston Celtics\", \"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\")\n\n## Vector of values\nNumber &lt;- c(0.0,30.0,8.0,NaN,12.0,7.0,11.0)\n\n## Vector of positions\nPosition &lt;- c(\"PG\",\"SG\",\"PF\",\"PF\",\"PG\",\"C\",\"SG\")\n\n## Vector of age\nAge &lt;- c(25.0,27.0,29.0,21.0,22.0,NaN,27.0)\n\n## Create a data frame from vectors\ndata.frame(Name,Team,Number,Position,Age)\n\n             Name           Team Number Position Age\n1   Avrey Bradley Boston Celtics      0       PG  25\n2    John Holland Boston Celtics     30       SG  27\n3   Jonas Jerebko Boston Celtics      8       PF  29\n4   Jordan Midkey Boston Celtics    NaN       PF  21\n5    Terry Rozier Boston Celtics     12       PG  22\n6 Jared Sullinger Boston Celtics      7        C NaN\n7     Evan Turner Boston Celtics     11       SG  27"
  },
  {
    "objectID": "precourse_preparation_theory.html#bd-rhapsody-single-cell-system",
    "href": "precourse_preparation_theory.html#bd-rhapsody-single-cell-system",
    "title": "Precourse Preparation - Theory",
    "section": "2.1 BD Rhapsody™ Single Cell System",
    "text": "2.1 BD Rhapsody™ Single Cell System\n\nThe BD Rhapsody™ Single Cell System enables simultaneous measurement of multiple parameters in thousands of individual cells. By combining available assays, researchers can generate robust and intricate datasets to unlock powerful insights.\nGene Expression (scRNAseq): The primary purpose of scRNAseq is to measure the gene expression in individual cells. This allows to understand which genes are active or inactive and to identify different cell types based on their gene expression profiles.\nAntibody-Based Protein Analysis (AbSeq): You can use antibodies conjugated with unique barcodes to measure protein expression alongside with gene expression in individual cells.\nSample multiplexing with antibody-based techniques (SMK): Sample multiplexing kit (SMK) uses generic antibody conjugated with unique barcodes to label cells from different samples. This enables pooling of multiple samples on one cartridge.\nImmune Repertoire Profiling (Full length V(D)J TCR/BCR): Full length V(D)J assay profiles the diversity of T cell and/or B cell receptor repertoires. This is valuable for studying the immune response and identifying antigen-specific cells.\nAntigen-Specific T-cell Analysis (DCode): Immudex’s DCode technology enables the profiling of T cells that recognize specific antigens such as viral epitopes or tumor-related antigens. This expands the offering of immune profiling, aiding vaccine development and immunotherapy research.\nFrom gene expression profiling to antibody-based protein analysis, all assays can be combined or performed standalone to explore cellular functions and molecular dynamics in single cell resolution."
  },
  {
    "objectID": "precourse_preparation_theory.html#overview-of-single-cell-data-analysis",
    "href": "precourse_preparation_theory.html#overview-of-single-cell-data-analysis",
    "title": "Precourse Preparation - Theory",
    "section": "2.2 Overview of Single Cell Data Analysis",
    "text": "2.2 Overview of Single Cell Data Analysis\nIn general, the analysis of single cell data can be split into two parts.\nThe primary analysis transforms raw data (usually in fastq.gz format) into an expression matrix, where each row represents a gene, each column represents a cell, and each entry in the matrix contains the molecule counts of a particular feature (gene or protein) in a cell. Secondary analysis focuses on extracting meaningful biological insights from the expression matrix."
  },
  {
    "objectID": "precourse_preparation_theory.html#primary-analysis---from-sequencing-data-to-expression-matrix",
    "href": "precourse_preparation_theory.html#primary-analysis---from-sequencing-data-to-expression-matrix",
    "title": "Precourse Preparation - Theory",
    "section": "2.3 Primary analysis - From Sequencing Data to Expression Matrix",
    "text": "2.3 Primary analysis - From Sequencing Data to Expression Matrix\nAfter sequencing, one will receive raw sequecning data. The raw sequencing data is usually in fastq.gz format. You may also see fq.gz.\nThe raw sequencing data is usually handled by the software, BD Rhapsody™ Primary Analysis Pipeline, to enables fast and easy data processing. In this chapter, we will cover key features of the pipeline and explain key concepts necessary to understand prior working with single cell data.\n\n2.3.1 BD Rhapsody™ Sequencing Analysis Pipeline\nThe BD Rhapsody™ Sequencing Analysis Pipeline contains a series of computational steps to process and extract meaningful information from the raw sequencing data generated by the BD Rhapsody™ Sinlge Cell System.\nThe goal of the primary analysis is to transform text-based genomic data into numerical data, and we achieve this through a series of steps in the pipeline. The steps of the pipeline are listed in simplified graphics below.\n\nThe main steps include decoding the unique barcodes and feature molecules associated with individual cells. Oftentimes, scRNAseq relies on unique molecular identifiers (UMIs) to quantify feature expression.\n\n\n2.3.2 Quantify feature expression with UMIs\nUnique molecular identifiers (UMIs) are used to quantify featuer molecules in a cell. Here’s how it works:\n\nBead structure: UMIs are small, unique sequences of nucleotides that are added to the capture sequence of beads. Each bead contains tens of thousands of unique UMIs followed by the polyA capture sequence. Each UMI is specific to the molecule it attaches to and becomes its unique tag.\n\nThousands RNA molecule copies are created by PCR during library preparation.\nThe RNA molecule copies, including the attached UMIs, are then sequenced.\n\nUMIs can help to differentiate PCR copies and we can quantify correctly the feature expression. After sequencing, we count the number of unique UMIs rather than the number of reads of a transcript as the feature expression. UMIs help to:\n\nRemove PCR copies: Because UMIs are unique to each original RNA molecule, any duplicates (multiple copies of the same RNA molecule) with the same UMI are likely the result of PCR amplification rather than a true molecule.\nCount unique molecules: By looking at the UMIs, one can count how many unique RNA molecules are originally present in the cell.\nQuantify gene expression: By counting the unique UMIs associated with each gene, one can measure the expression level of that gene in a cell. Genes with more UMIs are more active, while genes with fewer UMIs are less active.\n\nIn summary, UMIs are used to distinguish real feature molecules from PCR copies by providing a unique identifier for each original molecule.\n\n\n2.3.3 Output Files from the Primary Pipeline\nThe primary pipeline produces many output files. Below you can find a summary of output files relating to different assays.\n\nThe output files from the primary analysis are the input of the secondary analysis. In the course, we will work with demo data that includes WTA, AbSeq and SMK. You will get to know how to load the expression matrix (in MEX format), how to perform quality control and other steps that are commonly included in single cell analysis in Chapter 1 - 9.\n\n\n\n\n\n\nImportant\n\n\n\nThe course will ONLY cover the secondary analysis."
  },
  {
    "objectID": "02_quality_control.html#combine-metrics-to-come-up-the-filtering-threshold",
    "href": "02_quality_control.html#combine-metrics-to-come-up-the-filtering-threshold",
    "title": "Chapter 2 Quality Control",
    "section": "3.4 Combine metrics to come up the filtering threshold",
    "text": "3.4 Combine metrics to come up the filtering threshold\nWe can combine the metrics to decide the filtering threshold.\n\nrna@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500, colour = \"red\") +\n  geom_hline(yintercept = 300, colour = \"red\") +\n  facet_wrap(~Sample_Name) +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n\n\n\nThe data is fitted with a linear regression line. We expect when UMI counts increase, gene counts also increase.\nUpper right quadrant: Cells with high gene counts and UMI counts. We generally consider these cells to be good-quality cells.\nBottom right quadrant: Cells with low gene counts and UMI counts. We generally consider these cells are low-quality cells.\nDarker cells: Cells with high mitochondrial percentage. Many of these cells have low gene counts at the same time. This may indicate damaged/dying cells whose cytoplasmic mRNA leaks out through a broken membrane, so only mRNA located in the mitochondria is still conserved."
  },
  {
    "objectID": "03_normalization_exercise.html",
    "href": "03_normalization_exercise.html",
    "title": "Chapter 3 Normalization and PCA",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\n\nLoad RData\nLoad the RData which contains all files from previous chapter.\n\nload(\"data/intermediate_data/chapter2.RData\")\n\n1. Normalization\nWe will perform normalization on UMI counts using LogNormalize.\n\nfiltered.rna &lt;- NormalizeData(filtered.rna, \n                              normalization.method = \"LogNormalize\")\n\n\n\n\n\n\n\n@QUESTION1\n\n\n\nWhere are the normalized counts stored? And how to extract the normalized counts?\n\n\n\n\n\n\nTIP\n\n\n\nClick on the Seurat object filtered.rna in the top right window. What’s the difference between counts and data?\n\n\n\n\n# extract normalized counts\nnorm_counts &lt;- Seurat::GetAssayData(filtered.rna, slot = \"data\")\n\n\n\n2. Scaling and find the most variable genes\n\n# Identify the most variable genes\nfiltered.rna &lt;- FindVariableFeatures(filtered.rna,\n                                     selection.method = \"vst\",\n                                     nfeatures = 2000, \n                                     verbose = F)\n\n# Identify the 10 most highly variable genes\ntop10 &lt;- head(Seurat::VariableFeatures(filtered.rna), 10)\n\n# plot them in a nicely labeled scatterplot\nvf_plot &lt;- Seurat::VariableFeaturePlot(filtered.rna)\nSeurat::LabelPoints(plot = vf_plot,\n            points = top10, repel = TRUE)\n\n\n\n\nNext, we apply scaling, a linear transformation that is a standard pre-processing step prior to dimensional reduction techniques like PCA.\n\n# Scale the data\nfiltered.rna &lt;- ScaleData(filtered.rna, \n                          features = rownames(filtered.rna))\n\n\n\n\n\n\n\n@QUESTION2\n\n\n\nWhere are the scaled data stored?\n\n\n\n\n\n\nTIP\n\n\n\nClick on the Seurat object filtered.rna in the top right window."
  },
  {
    "objectID": "01_data_import_exercise.html",
    "href": "01_data_import_exercise.html",
    "title": "Chapter 1 Data Import",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\n\n1. Loading single cell data\n\nexpMat &lt;- Read10X(\"data/raw_data/WTA-AB-SMK-v2-0_DBEC_MolsPerCell_MEX/\",\n                  gene.column = 2,\n                  cell.column = 1,\n                  unique.features = TRUE)\n\nClick on the expMat on the right.\n\nA window will pop up and you should be able to see the structure of expMat.\n\nWe will first focus on Gene Expression.\n\nexpMat$`Gene Expression`[1:5, 1:5]\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n         74 391 440 1222 2690\nA1BG      .   .   .    .    .\nA1BG-AS1  .   .   .    .    .\nA1CF      .   .   .    .    .\nA2M       .   .   .    .    .\nA2M-AS1   .   .   .    .    .\n\n\n\n\n\n\n\n\n@QUESTION1\n\n\n\nWhat are the dots “.” in the matrix?\n\n\n2. Create a Seurat object to store Gene Expression\n\nrna &lt;- Seurat::CreateSeuratObject(counts = expMat$`Gene Expression`, \n                                min.cells = 1, \n                                min.features = 100, \n                                assay = \"RNA\")\n\n\n\n\n\n\n\n@QUESTION2\n\n\n\nHow many genes and cells are stored in the Seurat object rna?\n\n\n\n\n\n\nTip\n\n\n\nClick on the Seurat object rna in the top right window. What is 28127 x 4948?\n\n\n\n\n\n3. Add sample tag information into meta.data\n\n\n# load sample tag info into R\nsmk &lt;- fread(file = \"data/raw_data/WTA-AB-SMK-v2-0_Sample_Tag_Calls.csv\", \n                     sep = \",\", \n                     header=TRUE) %&gt;% \n  data.frame(row.names = 1)\n\n\n# add sample tag info into seurat object\nrna &lt;- AddMetaData(object = rna, metadata = smk)\n\n\n\n\n\n\n\n@QUESTION3\n\n\n\nHow do we know the sample tag information is added into the Seurat object rna?\n\n\n\n\n\n\nTip\n\n\n\nClick on rna in the top right window, then click on meta.data. What do you see?"
  },
  {
    "objectID": "supplementary_targeted_analysis.html",
    "href": "supplementary_targeted_analysis.html",
    "title": "Supplementary: Data import and quality control for targeted assays",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(clustree)\nlibrary(HGNChelper)\nlibrary(openxlsx)\nThe BD Rhapsody™ Targeted mRNA Kits profile a subset of genes, from dozens to hundreds. These genes are in the targeted panel.\nIn Chapter 2, we introduce filtering low quality cell labels using WTA assays. WTA assays profile whole transcriptome which can have up to 30,000 genes. Because the number of profiling genes is substantially higher in WTA assays, and the targeted assays often do not include mitochondrial genes, the filtering threthold for low quality cell labels in targeted assays is different from WTA."
  },
  {
    "objectID": "supplementary_targeted_analysis.html#data-import",
    "href": "supplementary_targeted_analysis.html#data-import",
    "title": "Supplementary: Data import and quality control for targeted assays",
    "section": "2.1 Data import",
    "text": "2.1 Data import\n\n\n\n\n\n\nNote\n\n\n\nWhen creating the Seurat object, it is important to specify min.cells = 1 and min.features = 1.\n\n\n\nexpMat &lt;- Read10X(\"data/raw_data/16HIRP_DBEC_MolsPerCell_MEX//\",\n                  gene.column = 2,\n                  cell.column = 1,\n                  unique.features = TRUE)\n\nrna &lt;- Seurat::CreateSeuratObject(counts = expMat, \n                                min.cells = 1, \n                                min.features = 1, \n                                assay = \"RNA\")"
  },
  {
    "objectID": "supplementary_targeted_analysis.html#ncount_rna-umi-counts-per-cell",
    "href": "supplementary_targeted_analysis.html#ncount_rna-umi-counts-per-cell",
    "title": "Supplementary: Data import and quality control for targeted assays",
    "section": "2.2 nCount_RNA UMI counts per cell",
    "text": "2.2 nCount_RNA UMI counts per cell\n\nrna@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  ggtitle(\"nCount_RNA\")"
  },
  {
    "objectID": "supplementary_targeted_analysis.html#nfeature_rna-gene-counts-per-cell",
    "href": "supplementary_targeted_analysis.html#nfeature_rna-gene-counts-per-cell",
    "title": "Supplementary: Data import and quality control for targeted assays",
    "section": "2.3 nFeature_RNA Gene counts per cell",
    "text": "2.3 nFeature_RNA Gene counts per cell\n\nrna@meta.data %&gt;% \n  ggplot(aes(x=nFeature_RNA)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  ggtitle(\"nFeature_RNA\")"
  },
  {
    "objectID": "supplementary_targeted_analysis.html#combine-metrics-to-come-up-the-filtering-threshold",
    "href": "supplementary_targeted_analysis.html#combine-metrics-to-come-up-the-filtering-threshold",
    "title": "Supplementary: Data import and quality control for targeted assays",
    "section": "2.4 Combine metrics to come up the filtering threshold",
    "text": "2.4 Combine metrics to come up the filtering threshold\n\nrna@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 90, colour = \"black\") +\n  geom_vline(xintercept = 3000, colour = \"black\") +\n  geom_hline(yintercept = 25, colour = \"red\") +\n  geom_hline(yintercept = 170, colour = \"red\") +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n\n\n\nMajority of cells have nFeature_RNA between 30 - 170 and nCount_RNA between 90 - 3000. The cells on the right with high nCount_RNA are likely multiplets. We will filter the cell groups with the identified threshold."
  },
  {
    "objectID": "supplementary_targeted_analysis.html#filter-on-cells",
    "href": "supplementary_targeted_analysis.html#filter-on-cells",
    "title": "Supplementary: Data import and quality control for targeted assays",
    "section": "3.1 Filter on cells",
    "text": "3.1 Filter on cells\nBased on the quality metrics, we use the following thresholds to filter out low quality cells:\nnCount_RNA &gt; 90\nnCount_RNA &lt; 3000\nnFeature_RNA &gt; 30\nnFeature_RNA &lt; 170\n\nfiltered.rna &lt;- subset(x = rna, \n                       subset = (nCount_RNA &gt; 90) & \n                         (nCount_RNA &lt; 3000) &\n                         (nFeature_RNA &gt; 30) &\n                         (nFeature_RNA &lt; 170))"
  },
  {
    "objectID": "supplementary_targeted_analysis.html#filter-on-genes",
    "href": "supplementary_targeted_analysis.html#filter-on-genes",
    "title": "Supplementary: Data import and quality control for targeted assays",
    "section": "3.2 Filter on genes",
    "text": "3.2 Filter on genes\nWe keep only genes that are expressed in at least one cells. GetAssayData is a convenient command to get information from the Seurat object. We use GetAssayData to extract the UMI counts.\n\n# Extract counts\ncounts &lt;- GetAssayData(object = filtered.rna, slot = \"counts\")\n\n# Output a logical matrix specifying for each gene whether or not \n# there are more than zero counts per cell\nnonzero &lt;- counts &gt; 0\n\n# Sum all TRUE values and return TRUE \n# if equal or more than 5 TRUE values per gene\nkeep_genes &lt;- Matrix::rowSums(nonzero) &gt;= 1\n\n# Only keep those genes\nfiltered_counts &lt;- counts[keep_genes, ]\n\n# Create Seurat object\nfiltered.rna &lt;- CreateSeuratObject(filtered_counts, meta.data = filtered.rna@meta.data)"
  },
  {
    "objectID": "supplementary_targeted_analysis.html#re-assess-metrics",
    "href": "supplementary_targeted_analysis.html#re-assess-metrics",
    "title": "Supplementary: Data import and quality control for targeted assays",
    "section": "3.3 Re-assess metrics",
    "text": "3.3 Re-assess metrics\nAfter filtering, we look back to the metrics to ensure the filtered data matches expectations and is suitable for downstream analysis. We plot QC metrics using the filtered data.\n\nfiltered.rna@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 90, colour = \"black\") +\n  geom_vline(xintercept = 3000, colour = \"black\") +\n  geom_hline(yintercept = 25, colour = \"red\") +\n  geom_hline(yintercept = 170, colour = \"red\") +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n\n\n\nThe feature number and cell number before filtering:\n\nrna\n\nAn object of class Seurat \n382 features across 16771 samples within 1 assay \nActive assay: RNA (382 features, 0 variable features)\n\n\nThe feature number and cell number after filtering:\n\nfiltered.rna\n\nAn object of class Seurat \n381 features across 16675 samples within 1 assay \nActive assay: RNA (381 features, 0 variable features)"
  },
  {
    "objectID": "07_differential_expression_analysis.html#de-analysis-across-conditions",
    "href": "07_differential_expression_analysis.html#de-analysis-across-conditions",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "1.1 DE analysis across conditions",
    "text": "1.1 DE analysis across conditions\nIn the last chapter, we used FindMarkers to find the marker genes between two clusters by specifying ident.1 and ident.2.\nChanging the ident.1 and ident.2 arguments, we can perform differential expression analysis between two groups.\nFor instance, we want to find genes deferentially expressed between naïve and treated PBMC.\n\n# assign the sample identity that we want to work on different sample groups\nIdents(integrate.filtered.rna) &lt;- \"Sample_Name\"\n\n# change default assay to \"RNA\"\nDefaultAssay(integrate.filtered.rna) &lt;- \"RNA\"\n\n# Find genes differentially expressed\ntreated_naive &lt;- \n  FindMarkers(integrate.filtered.rna, ident.1 = \"treated\", ident.2 = \"naive\") %&gt;% \n  rownames_to_column(\"gene\") %&gt;% \n  dplyr::filter(p_val_adj &lt; 0.05)\n\nWe can compare the gene expression between two groups by specifying ident.1 and ident.2.\n\nhead(treated_naive)\n\n   gene         p_val avg_log2FC pct.1 pct.2     p_val_adj\n1  GBP1  0.000000e+00   2.843551 0.688 0.072  0.000000e+00\n2 STAT1  0.000000e+00   2.745853 0.855 0.165  0.000000e+00\n3  TAP1 1.208876e-296   1.971221 0.758 0.178 2.338813e-292\n4  GBP4 7.757109e-268   2.250739 0.642 0.087 1.500768e-263\n5  XAF1 4.844772e-251   2.252528 0.639 0.114 9.373181e-247\n6  GBP5 3.297043e-247   2.334895 0.625 0.094 6.378789e-243\n\n\n\ngene Gene symbol.\np_val P-value without multiple testing.\navg_log2FC log2 fold-change of the average expression between the two groups."
  },
  {
    "objectID": "07_differential_expression_analysis.html#perform-de-analysis-within-the-same-cell-type-across-conditions",
    "href": "07_differential_expression_analysis.html#perform-de-analysis-within-the-same-cell-type-across-conditions",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "1.2 Perform DE analysis within the same cell type across conditions",
    "text": "1.2 Perform DE analysis within the same cell type across conditions\nWe can also perform DE analysis within the same cell type across conditions.\n\n# subset CD4 T cells\nintegrate.filtered.rna$celltype.stim &lt;- paste(integrate.filtered.rna$Sample_Name, integrate.filtered.rna$predicted.celltype.l1, sep = \"_\")\n\n# Find genes differentially expressed between activated vs. naive samples in CD4 T cells\nIdents(integrate.filtered.rna) &lt;- \"celltype.stim\"\n\ncd4t.sc &lt;- FindMarkers(integrate.filtered.rna, \n                       ident.1 = \"treated_CD4 T\", \n                       ident.2 = \"naive_CD4 T\", \n                       verbose = FALSE)\n\nhead(cd4t.sc, n = 10)\n\n                 p_val avg_log2FC pct.1 pct.2     p_val_adj\nSTAT1    1.287895e-250  2.7850893 0.888 0.150 2.491691e-246\nIL7R     1.520720e-198 -2.4675759 0.406 0.856 2.942137e-194\nENO1     2.757226e-191  2.7814107 0.774 0.206 5.334405e-187\nTAP1     2.897556e-174  2.0199856 0.764 0.142 5.605902e-170\nHSP90AB1 2.834735e-171  2.3884659 0.863 0.533 5.484362e-167\nHSP90AA1 8.922351e-160  2.5514135 0.841 0.484 1.726207e-155\nLDHA     2.572990e-155  2.3324541 0.714 0.192 4.977964e-151\nGBP1     3.395478e-155  2.1078868 0.672 0.080 6.569232e-151\nTUBA1B   1.790942e-152  3.0084674 0.669 0.161 3.464935e-148\nRPS27    1.123880e-148 -0.8740197 0.981 1.000 2.174370e-144"
  },
  {
    "objectID": "log.html",
    "href": "log.html",
    "title": "Log",
    "section": "",
    "text": "The following chapters have the below changes:\n\n\nAdd instruction to install Seurat V4.\nAdd instruction to update packages.\nDelete packages to be installed: SingleR, celldex, muscat.\nAdd packages to be installed: HGNChelper, ggpubr, RTools.\nUpdate Data download link.\n\n\nAdd data download link\n\n\nAdd clustree\n\n\n\nReplace singleR with ScType\n\nAdd VlnPlot stack plot\n\n\nReplace muscat with functions in Seurat V4 to perform pseudobulk analysis\n\n\nReplace ranking in GSEA gene list from stat to log2FC\nForce enrich bar plots to plot GO terms with the key word “T Cell”\n\n\nRunUMAP\n\n\nSolution: Downgrading Matrix\nIf Mac is updated to Sonoma 14.x.x, you may see errors related to gfortran, like:\nld: warning: search path ‘/opt/R/arm64/gfortran/lib/gcc/aarch64-apple-darwin20.2.0/11.0.0’ not found\nld: warning: search path ‘/opt/R/arm64/gfortran/lib’ not found\nld: library ‘gfortran’ not found\nIf that’s the case, please download and install gfortran-12.2-universal.pkg https://cran.r-project.org/bin/macosx/tools/ before proceed.\n\ninstall.packages(\"remotes\")\nremotes::install_version(\"Matrix\", version = \"1.6-1\")\npackageVersion(\"Matrix\")\n\nSource: https://cran.r-project.org/bin/macosx/tools/\n\ngetBM\n\n\nSolution: Downgrading dbplyr\n\ndevtools::install_version(\"dbplyr\", version = \"2.3.4\")\n\nSource: https://stackoverflow.com/questions/77370659/error-failed-to-collect-lazy-table-caused-by-error-in-db-collect-using\n\nuseMart\n\n\nSolution: Go to http://status.ensembl.org to check the status of Ensembl. If it says service is down, wait a few hours and try again."
  },
  {
    "objectID": "log.html#setup",
    "href": "log.html#setup",
    "title": "Log",
    "section": "",
    "text": "Add instruction to install Seurat V4.\nAdd instruction to update packages.\nDelete packages to be installed: SingleR, celldex, muscat.\nAdd packages to be installed: HGNChelper, ggpubr, RTools.\nUpdate Data download link."
  },
  {
    "objectID": "log.html#precourse-preperation---r",
    "href": "log.html#precourse-preperation---r",
    "title": "Log",
    "section": "",
    "text": "Add data download link"
  },
  {
    "objectID": "log.html#chapter-5-clustering",
    "href": "log.html#chapter-5-clustering",
    "title": "Log",
    "section": "",
    "text": "Add clustree"
  },
  {
    "objectID": "log.html#chapter-6-marker-identification",
    "href": "log.html#chapter-6-marker-identification",
    "title": "Log",
    "section": "",
    "text": "Replace singleR with ScType\n\nAdd VlnPlot stack plot"
  },
  {
    "objectID": "log.html#chapter-7-differential-expression-analysis",
    "href": "log.html#chapter-7-differential-expression-analysis",
    "title": "Log",
    "section": "",
    "text": "Replace muscat with functions in Seurat V4 to perform pseudobulk analysis"
  },
  {
    "objectID": "log.html#chapter-8",
    "href": "log.html#chapter-8",
    "title": "Log",
    "section": "",
    "text": "Replace ranking in GSEA gene list from stat to log2FC\nForce enrich bar plots to plot GO terms with the key word “T Cell”"
  },
  {
    "objectID": "log.html#error-log",
    "href": "log.html#error-log",
    "title": "Log",
    "section": "",
    "text": "RunUMAP\n\n\nSolution: Downgrading Matrix\nIf Mac is updated to Sonoma 14.x.x, you may see errors related to gfortran, like:\nld: warning: search path ‘/opt/R/arm64/gfortran/lib/gcc/aarch64-apple-darwin20.2.0/11.0.0’ not found\nld: warning: search path ‘/opt/R/arm64/gfortran/lib’ not found\nld: library ‘gfortran’ not found\nIf that’s the case, please download and install gfortran-12.2-universal.pkg https://cran.r-project.org/bin/macosx/tools/ before proceed.\n\ninstall.packages(\"remotes\")\nremotes::install_version(\"Matrix\", version = \"1.6-1\")\npackageVersion(\"Matrix\")\n\nSource: https://cran.r-project.org/bin/macosx/tools/\n\ngetBM\n\n\nSolution: Downgrading dbplyr\n\ndevtools::install_version(\"dbplyr\", version = \"2.3.4\")\n\nSource: https://stackoverflow.com/questions/77370659/error-failed-to-collect-lazy-table-caused-by-error-in-db-collect-using\n\nuseMart\n\n\nSolution: Go to http://status.ensembl.org to check the status of Ensembl. If it says service is down, wait a few hours and try again."
  }
]