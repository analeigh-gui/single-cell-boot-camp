[
  {
    "objectID": "01_data_import.html",
    "href": "01_data_import.html",
    "title": "Chapter 1 Data Import",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\n\nDemo data\nThe demo data is generated from freshly isolated human PBMCs. The PBMCs were grown for 24 hours in the presence of CD3/CD28 stimulation (“treated”) and compared to PBMCs grown for 24 hours in regular media (“naive”). Cells were then labeled with a 20plex AbSeq panel consisting of lineage markers and T-cell activation markers, as well as unique Sample Tags from the BD Rhapsody™ Human Single Cell Multiplexing Kit (resting PBMC: ST1; treated PBMC: ST2). The cells were mixed at a 1:1 ratio and processed using the BD Rhapsody™ Single-Cell Analysis System. Sequencing libraries for RNA and AbSeq antibodies were generated using the BD Rhapsody WTA Amplification kit.\n\n\n\n\n\n\nNote\n\n\n\nPlease review the setup chapter to ensure that R packages are installed and data is downloaded.\n\n\n1. Data import\nThe expression matrix stores the UMI counts of a feature (gene or protein). Depending on the single cell platform, common format of expression matrix include CSV, MEX (Market Exchange) or H5AD.\nRhapsody single cell platform outputs expression matrix in two formats: MEX and H5AD.\nWe import MEX using the function from Seurat, Read10x. We assign a name to the created object, expMat (expression Matrix).\n\n\n\n\n\n\nNote\n\n\n\nThe expression matrix in Rhapsody v1 pipeline is in CSV format. If you run Rhapsody v2 pipeline, the expression matrix is available in MEX format.\n\n\n\nexpMat &lt;- Read10X(\"data/raw_data/WTA-AB-SMK-v2-0_DBEC_MolsPerCell_MEX/\",\n                  gene.column = 2,\n                  cell.column = 1,\n                  unique.features = TRUE)\n\nClick on the expMat on the right.\n\nA window will pop up and you should be able to see the structure of expMat.\n\nexpMat contains two matrices: Gene Expression and Antibody Capture. You may recall that the demo dataset has two assays: WTA, whole transcriptome analysis, to capture Gene Expression; and AbSeq for Antibody Capture.\nWe will first focus on Gene Expression, the scRNA-seq.\nTake a look on the first 5 row x first 5 column of Gene Expression matrix. It is organized as feature x cell.\n\nexpMat$`Gene Expression`[1:5, 1:5]\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n         74 391 440 1222 2690\nA1BG      .   .   .    .    .\nA1BG-AS1  .   .   .    .    .\nA1CF      .   .   .    .    .\nA2M       .   .   .    .    .\nA2M-AS1   .   .   .    .    .\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhat are the dots “.” in the matrix?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe “.” corresponds to 0.\nscRNA-seq usually contains many zeros. The zeros can come from\n\nStochastic gene expression\nLimitation of single cell technology: On average, 5-8% of mRNA transcripts can be captured by the machine.\n\n\n\n\n2. Create a Seurat object to store Gene Expression\nLet’s create a Seurat object to store Gene Expression.\n\nrna &lt;- CreateSeuratObject(counts = expMat$`Gene Expression`, \n                                min.cells = 1, \n                                min.features = 100, \n                                assay = \"RNA\")\n\nmin.cells Specify the minimum number of cells that need to be detected per feature. Setting this argument will filter out zero or lowly expressed features.\nmin.features Specify the minimum number of features that need to be detected per cell. Setting this argument will filter out cell indexes with random counts but without any cell present.\nassay Specify the name of the created assay. By default, it is “RNA”.\n\n\n\n\n\n\nQuestion\n\n\n\nCreateSeuratObject has many arguments in the function. These arguments allow users to control the behavior of the function. One can look at the Help tab to see the arguments and their default settings.\n\n\n\nWhen creating a Seurat object, Seurat automatically creates some metadata for each cell. This information is stored in the meta.data slot.\n\nrna@meta.data %&gt;% head\n\n        orig.ident nCount_RNA nFeature_RNA\n74   SeuratProject       2389         1135\n391  SeuratProject       5252         2088\n440  SeuratProject       1205          630\n1222 SeuratProject       2390         1152\n2690 SeuratProject       1533          810\n2782 SeuratProject       1106          105\n\n\nmeta.data stores information related to each cell. We will add more information into the meta.data later. For now, it contains three columns:\norig.ident Sample identity or sample name. By default, it is SeuratProject.\nnCount_RNA UMI counts per gene per cell.\nnFeature_RNA Genes counts per cell.\n3. Add cell assignment into meta.data\n\nThe demo dataset has Sample Multiplexing Kit (SMK) to pool two samples in one cartridge.\nTo demultiplex the samples, we need to use Demo-WTA-AbSeq-SMK_Sample_Tag_Calls.csv.\n\nsmk &lt;- fread(file = \"data/raw_data/WTA-AB-SMK-v2-0_Sample_Tag_Calls.csv\", \n                     sep = \",\", \n                     header=TRUE) %&gt;% \n  data.frame(row.names = 1)\n\n\nsmk[1:5, ]\n\n         Sample_Tag Sample_Name\n74   SampleTag01_hs       naive\n391  SampleTag02_hs     treated\n440  SampleTag01_hs       naive\n1222 SampleTag01_hs       naive\n2690 SampleTag01_hs       naive\n\n\nsmk is a matrix with two columns. The row names are the cell labels.\nSample_Tag: Which tag the cell belongs to.\nSample_Name: Which sample the cell belongs to.\nWe can add the cell assignment into the meta.data of Seurat object by AddMetaData.\n\nrna &lt;- AddMetaData(object = rna, metadata = smk)\n\n\nrna@meta.data %&gt;% head()\n\n        orig.ident nCount_RNA nFeature_RNA     Sample_Tag Sample_Name\n74   SeuratProject       2389         1135 SampleTag01_hs       naive\n391  SeuratProject       5252         2088 SampleTag02_hs     treated\n440  SeuratProject       1205          630 SampleTag01_hs       naive\n1222 SeuratProject       2390         1152 SampleTag01_hs       naive\n2690 SeuratProject       1533          810 SampleTag01_hs       naive\n2782 SeuratProject       1106          105      Multiplet   Multiplet\n\n\nNow we know which cell belongs to which sample.\n4. Remove Multiplet and Undetermined\nThe Multiplet are cell labels with more than one SMK tags. They could be Multiplets from one microwell containing two cells, or single cells with high ambient SMK noise.\nThe Undetermined are cell labels without sufficient SMK tag reads. They could be noisy cell labels, or single cells without SMK tag reads.\n\nrna@meta.data %&gt;% \n  group_by(Sample_Name) %&gt;% \n  tally() %&gt;% \n  mutate(pct = n/sum(n)) %&gt;% \n  ggplot(aes(x=Sample_Name, y=n, fill= Sample_Name)) + \n  geom_bar(stat = \"identity\") +\n  geom_text(aes(y = n,\n                label = paste0(n, \"\\n\", scales::percent(pct)),\n                vjust= -0.5, size = 2.5), show.legend = FALSE) + \n  theme_classic()\n\n\n\n\nMultiplet and Undetermined are removed from the downstream analysis by subset.\n\nrna &lt;- subset(rna, subset = Sample_Name %in% c(\"Multiplet\", \"Undetermined\"), invert = T)\n\n5. Save\nSave the files into RData for documentation.\n\n# save.image(\"data/intermediate_data/chapter1.RData\")"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Introduction",
    "section": "",
    "text": "How to use the materials?\nThis repository contains the materials for the Single Cell Boot Camp.\nIt has two chapters of precourse preparation and nine chapters of the course.\nFor those who are new to R, please review Precourse Preparation - R. If you are familiar with the functions listed in this chapter, you can skip it.\nFor all participants, please review Precourse Preparation - Theory.\nFor chapters 1 to 9, we will go through it together in the course. Welcome to review them before the course if you have time (The learning outcome is much better if you go through the materials before attending the course from feedback of our previous students).\n\n\nNext occurrence\nSept 19 - 20, 2023 | 10 am - 2:30 ~ 3:00 pm | Online\n\n\nDescription\nThe Single Cell Boot Camp: Analysis of scRNA-seq with R is to provide an overview of the analysis of single-cell RNA-seq using R. It is designed for early-stage researchers who want to adopt single-cell analysis in their toolbox. The workshop consists of theory in presentation and application in hands-on practice.\nThe workshop starts with a fast-paced training session on the common workflow of single-cell RNA-seq analysis, then continues with sessions on the common workflow of scRNA-seq using bioinformatics packages like Seurat.\n\n\nPrerequisites\nEach participant are expected to have:\n1. An introductory background in statistics, specifically in the below concepts: Median, log2 fold change, p-value, adjusted p-value, variance, PCA.\n2. Basic familiarity with R and tidyr package, specifically in the below functions: %&gt;% (pipe), filter, mutate, pivot_longer, pivot_wider, map, pmap, select, left_join.\nIf you would like to learn on your own with publicly available resources:\nChapter 1 - 4 from MordernDive: https://moderndive.com/index.html\n\nIf you would like to participate in an instructor-led R course:\nR for Biologist from Edinburgh Genomics (https://genomics.ed.ac.uk/services/r-biologists-0#overlay-context=services/training). For details, please contact Edinburgh Genomics.\n\n\nExpected outcome\nBy the end of the workshop, participants will be familiar with the following topics: - Common workflow of single cell analysis (pre-processing, quality control, filtering, normalization, Clustering, Cell type annotation) - Combining AbSeq and scRNA-seq for downstream analysis\nFor further information, please contact: biox_support_emea@bd.com\n\n\nDisclaimer\nRecommendations given by representatives of BD in the context of the creation and setup of customer-specific applications and assays and the composition of antibody panels for use in flow cytometry assays are provided in a diligent manner. However, the Customer acknowledges that (i) such recommendations should not be treated as a substitute for the Customer’s own examination, (ii) BD does not make any promises nor guarantees that recommendations are accurate and complete and will meet the Customer’s present or future needs or will produce positive or specific results and (iii) Customer remains solely responsible for validating and deciding on any such recommendations.\nBD therefore accepts no liability whatsoever in connection with any such recommendation and/or any results generated on the basis of such recommendations and, to the fullest extent permitted by law, expressly disclaims any and all warranties and any liability in this respect. In particular, the Customer assumes sole responsibility for the validation, use, selection, and suitability of the recommendations for its needs and objectives.\n\n\nLicense\nSee the LICENSE file for license rights and limitations (MIT)."
  },
  {
    "objectID": "precourse_preparation_R.html",
    "href": "precourse_preparation_R.html",
    "title": "Precourse Preparation - R",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(readxl)\nlibrary(data.table)\nlibrary(tidyverse)\nlibrary(Seurat)"
  },
  {
    "objectID": "precourse_preparation_R.html#what-is-data-frame",
    "href": "precourse_preparation_R.html#what-is-data-frame",
    "title": "Precourse Preparation - R",
    "section": "1.1 What is data frame",
    "text": "1.1 What is data frame\nData frame is data structure in R that store values of any type. You can think of it as a table with columns and rows storing the data as in below example.\n\nCredit: https://www.geeksforgeeks.org/r-data-frames/\nOften in data science language the columns are named as variables, the rows are observations and each entry in a table is a value.\nSome of the most common examples of input files that can be loaded into R as data frames are spreadsheets, TSVs, CSVs files. TSV and CSV stands for tab-separated or coma-separated values.\nAnother way to view data frame is as list of vectors of the same length. The vector can be defined as type of data structure that contains elements of the same type. Below you can find example on how create the table presented in Figure 1 from vectors.\n\n#define vectors which will create columns with data in data frame\n\n## Vector of names\nName &lt;- c(\"Avrey Bradley\",\"John Holland\",\"Jonas Jerebko\",\"Jordan Midkey\",\"Terry Rozier\",\"Jared Sullinger\",\"Evan Turner\")\n\n## Vector of team's names\nTeam &lt;- c(\"Boston Celtics\", \"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\",\"Boston Celtics\")\n\n## Vector of values\nNumber &lt;- c(0.0,30.0,8.0,NaN,12.0,7.0,11.0)\n\n## Vector of positions\nPosition &lt;- c(\"PG\",\"SG\",\"PF\",\"PF\",\"PG\",\"C\",\"SG\")\n\n## Vector of age\nAge &lt;- c(25.0,27.0,29.0,21.0,22.0,NaN,27.0)\n\n#create data frame from vectors\ndata.frame(Name,Team,Number,Position,Age)\n\n             Name           Team Number Position Age\n1   Avrey Bradley Boston Celtics      0       PG  25\n2    John Holland Boston Celtics     30       SG  27\n3   Jonas Jerebko Boston Celtics      8       PF  29\n4   Jordan Midkey Boston Celtics    NaN       PF  21\n5    Terry Rozier Boston Celtics     12       PG  22\n6 Jared Sullinger Boston Celtics      7        C NaN\n7     Evan Turner Boston Celtics     11       SG  27"
  },
  {
    "objectID": "precourse_preparation_R.html#convenient-version-of-data-frame-tibble",
    "href": "precourse_preparation_R.html#convenient-version-of-data-frame-tibble",
    "title": "Precourse Preparation - R",
    "section": "1.2 Convenient version of data frame: “Tibble”",
    "text": "1.2 Convenient version of data frame: “Tibble”\nThe tibble is package that manipulate data frames. The tibble type of table looks like data frame but have some advantages over using regular data frames.\nFor example, while loading data as classical data frame, the spaces in names are conversed to periods or “x” before numeric columns is added. While using tibbles, the input names and types remain unchanged. In this tutorial we will work mainly with tibble data frame type."
  },
  {
    "objectID": "precourse_preparation_R.html#working-with-data-frames-in-r",
    "href": "precourse_preparation_R.html#working-with-data-frames-in-r",
    "title": "Precourse Preparation - R",
    "section": "1.3 Working with data frames in R",
    "text": "1.3 Working with data frames in R\n1.3.1 Example data\nIn this part of tutorial, we will work on table downloaded from supplementary data of Salcher, Stefan et al. publication (doi:10.1016/j.ccell.2022.10.008). The table contains the metadata of patients for which samples were processed on different single-cell platforms.\n1.3.2 Loading data\nDepending on the input format, there are different dedicated libraries to load data into R. Here we start from excel spreadsheet and use function from readxl library. The readxl library is part of tidyverse packages that will be covered in second chapter of this tutorial.\n\ndf_example &lt;- read_excel(\"data/precourse_preparation_data/mmc4.xlsx\", skip = 2)\n\nNOTE:\n\nThe two first rows in the table are empty and therefore skipped while loading.\nOne of the columns in excel spreadsheet is empty (column N). The R assign automatically the default name to that column and keep it within data frame.\nAll the missing entries in rows will be filled with “NA” values automatically.\n1.3.3 Viewing the content\nThere are different ways to view the content of data frame. You can directly click on df_example to display the content.\nThe “str” function lists directly in the console: the type of data (tibble), dimensions (322x18), columns with first values displayed and type of values.\n\nstr(df_example)\n\ntibble [322 × 18] (S3: tbl_df/tbl/data.frame)\n $ ...1                    : num [1:322] 0 1 2 3 4 5 6 7 8 9 ...\n $ study                   : chr [1:322] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" ...\n $ dataset                 : chr [1:322] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" ...\n $ patient                 : chr [1:322] \"Adams_Kaminski_2020_001C\" \"Adams_Kaminski_2020_002C\" \"Adams_Kaminski_2020_003C\" \"Adams_Kaminski_2020_8CO\" ...\n $ uicc_stage              : chr [1:322] NA NA NA NA ...\n $ tumor_stage             : chr [1:322] NA NA NA NA ...\n $ sex                     : chr [1:322] \"male\" \"female\" \"female\" \"male\" ...\n $ ever_smoker             : chr [1:322] \"no\" \"no\" \"no\" \"yes\" ...\n $ driver_genes            : chr [1:322] NA NA NA NA ...\n $ condition               : chr [1:322] \"non-cancer\" \"non-cancer\" \"non-cancer\" \"COPD\" ...\n $ age                     : num [1:322] 22 25 67 65 66 49 62 57 66 20 ...\n $ platform                : chr [1:322] \"10x\" \"10x\" \"10x\" \"10x\" ...\n $ platform_fine           : chr [1:322] \"10x_3p_v2\" \"10x_3p_v2\" \"10x_3p_v2\" \"10x_3p_v2\" ...\n $ ...14                   : logi [1:322] NA NA NA NA NA NA ...\n $ tissue: normal          : num [1:322] 1 1 1 1 1 1 1 1 1 1 ...\n $ tissue: normal_adjacent : num [1:322] 0 0 0 0 0 0 0 0 0 0 ...\n $ tissue: tumor_primary   : num [1:322] 0 0 0 0 0 0 0 0 0 0 ...\n $ tissue: tumor_metastasis: num [1:322] 0 0 0 0 0 0 0 0 0 0 ...\n\n\n1.3.4 Extracting information\nExtracting data from an R data frame means to access its rows or columns. First let’s list all columns available in the dataset.\n\ncolnames(df_example)\n\n [1] \"...1\"                     \"study\"                   \n [3] \"dataset\"                  \"patient\"                 \n [5] \"uicc_stage\"               \"tumor_stage\"             \n [7] \"sex\"                      \"ever_smoker\"             \n [9] \"driver_genes\"             \"condition\"               \n[11] \"age\"                      \"platform\"                \n[13] \"platform_fine\"            \"...14\"                   \n[15] \"tissue: normal\"           \"tissue: normal_adjacent\" \n[17] \"tissue: tumor_primary\"    \"tissue: tumor_metastasis\"\n\n\nTo extract values from single column of the data frame different options can be used:\n\nUsing $ operator and providing the column name\n\n\nhead(df_example$study) # head allows to display only 10 first elements \n\n[1] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n[4] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n\n\n\nUsing [ , ] and providing the column number (index)\n\n\ndf_example[,2] %&gt;% head() # head allows to display only 10 first elements \n\n# A tibble: 6 × 1\n  study              \n  &lt;chr&gt;              \n1 Adams_Kaminski_2020\n2 Adams_Kaminski_2020\n3 Adams_Kaminski_2020\n4 Adams_Kaminski_2020\n5 Adams_Kaminski_2020\n6 Adams_Kaminski_2020\n\n\n\nUsing [[]] and providing column number (index)\n\n\ndf_example[[2]] %&gt;% head()\n\n[1] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n[4] \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\" \"Adams_Kaminski_2020\"\n\n\n\nUsing column name\n\n\ndf_example[,c(\"study\")] %&gt;% head\n\n# A tibble: 6 × 1\n  study              \n  &lt;chr&gt;              \n1 Adams_Kaminski_2020\n2 Adams_Kaminski_2020\n3 Adams_Kaminski_2020\n4 Adams_Kaminski_2020\n5 Adams_Kaminski_2020\n6 Adams_Kaminski_2020\n\n\nTo extract multiple columns or rows at the same time the following rules apply:\n\n\nExtract rows range, include all columns.\n\n\ndf_example[c(2:4),] #display rows from 2-4 and all columns\n\n# A tibble: 3 × 18\n   ...1 study           dataset patient uicc_stage tumor_stage sex   ever_smoker\n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;      \n1     1 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n2     2 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n3     3 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  yes        \n# ℹ 10 more variables: driver_genes &lt;chr&gt;, condition &lt;chr&gt;, age &lt;dbl&gt;,\n#   platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\n\nExtract rows, include all columns.\n\n\ndf_example[c(2,4),] #display rows 2 and 4 and all columns\n\n# A tibble: 2 × 18\n   ...1 study           dataset patient uicc_stage tumor_stage sex   ever_smoker\n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;      \n1     1 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n2     3 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  yes        \n# ℹ 10 more variables: driver_genes &lt;chr&gt;, condition &lt;chr&gt;, age &lt;dbl&gt;,\n#   platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\n\nExtract columns range, include all rows.\n\n\ndf_example[,c(2:4)] %&gt;% head #display columns from 2-4 and all rows\n\n# A tibble: 6 × 3\n  study               dataset             patient                 \n  &lt;chr&gt;               &lt;chr&gt;               &lt;chr&gt;                   \n1 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_001C\n2 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_002C\n3 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_003C\n4 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_8CO \n5 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_23CO\n6 Adams_Kaminski_2020 Adams_Kaminski_2020 Adams_Kaminski_2020_034C\n\n\n\nExtract columns, include all rows.\n\n\ndf_example[,c(2,4)] %&gt;% head #display columns 2 and 4 and all rows\n\n# A tibble: 6 × 2\n  study               patient                 \n  &lt;chr&gt;               &lt;chr&gt;                   \n1 Adams_Kaminski_2020 Adams_Kaminski_2020_001C\n2 Adams_Kaminski_2020 Adams_Kaminski_2020_002C\n3 Adams_Kaminski_2020 Adams_Kaminski_2020_003C\n4 Adams_Kaminski_2020 Adams_Kaminski_2020_8CO \n5 Adams_Kaminski_2020 Adams_Kaminski_2020_23CO\n6 Adams_Kaminski_2020 Adams_Kaminski_2020_034C\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise\n\nExtract rows from 5-10 and columns from 3-8.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer\n\n\ndf_example[c(5:10),c(3,8)]\n\n\n\n\n1.3.4 Modifying information\nThe columns or rows can be removed or added to data frame as needed. It is possible to drop specific columns indicating the column indexes.\n\nmodified_df_example &lt;- df_example[, -c(1,2,5)]    # Drop columns 1,2,5 and include all columns\nmodified_df_example %&gt;% head # data frame with excluded columns \n\n# A tibble: 6 × 15\n  dataset     patient tumor_stage sex   ever_smoker driver_genes condition   age\n  &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;     &lt;dbl&gt;\n1 Adams_Kami… Adams_… &lt;NA&gt;        male  no          &lt;NA&gt;         non-canc…    22\n2 Adams_Kami… Adams_… &lt;NA&gt;        fema… no          &lt;NA&gt;         non-canc…    25\n3 Adams_Kami… Adams_… &lt;NA&gt;        fema… no          &lt;NA&gt;         non-canc…    67\n4 Adams_Kami… Adams_… &lt;NA&gt;        male  yes         &lt;NA&gt;         COPD         65\n5 Adams_Kami… Adams_… &lt;NA&gt;        male  yes         &lt;NA&gt;         COPD         66\n6 Adams_Kami… Adams_… &lt;NA&gt;        male  yes         &lt;NA&gt;         non-canc…    49\n# ℹ 7 more variables: platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;,\n#   `tissue: normal` &lt;dbl&gt;, `tissue: normal_adjacent` &lt;dbl&gt;,\n#   `tissue: tumor_primary` &lt;dbl&gt;, `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\nThe same principle apply to excluding the rows\n\nmodified_df_example &lt;- df_example[-c(1,2,5),]     # Drop rows 1,2,5 and include all columns\nmodified_df_example %&gt;% head\n\n# A tibble: 6 × 18\n   ...1 study           dataset patient uicc_stage tumor_stage sex   ever_smoker\n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;      \n1     2 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n2     3 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  yes        \n3     5 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  yes        \n4     6 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… yes        \n5     7 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… yes        \n6     8 Adams_Kaminski… Adams_… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no         \n# ℹ 10 more variables: driver_genes &lt;chr&gt;, condition &lt;chr&gt;, age &lt;dbl&gt;,\n#   platform &lt;chr&gt;, platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\nWe can remove column with specific name. To drop column, we chose all the columns (called by “colnames”) except (!=) “patient”.\n\nmodified_df_example &lt;- df_example[ , colnames(df_example) != \"patient\"]    # Drop column \"patient\"\nmodified_df_example %&gt;% head\n\n# A tibble: 6 × 17\n   ...1 study      dataset uicc_stage tumor_stage sex   ever_smoker driver_genes\n  &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;       \n1     0 Adams_Kam… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  no          &lt;NA&gt;        \n2     1 Adams_Kam… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no          &lt;NA&gt;        \n3     2 Adams_Kam… Adams_… &lt;NA&gt;       &lt;NA&gt;        fema… no          &lt;NA&gt;        \n4     3 Adams_Kam… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  yes         &lt;NA&gt;        \n5     4 Adams_Kam… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  yes         &lt;NA&gt;        \n6     5 Adams_Kam… Adams_… &lt;NA&gt;       &lt;NA&gt;        male  yes         &lt;NA&gt;        \n# ℹ 9 more variables: condition &lt;chr&gt;, age &lt;dbl&gt;, platform &lt;chr&gt;,\n#   platform_fine &lt;chr&gt;, ...14 &lt;lgl&gt;, `tissue: normal` &lt;dbl&gt;,\n#   `tissue: normal_adjacent` &lt;dbl&gt;, `tissue: tumor_primary` &lt;dbl&gt;,\n#   `tissue: tumor_metastasis` &lt;dbl&gt;\n\n\nThe new columns can be added to data frame. To add new column, use $ to indicate the column name for a new column as in the example below.\nHere we assign the values from already existing column to a new column. The new column is added at the end of the data table.\n\ndf_example$technology_type &lt;- df_example$platform # add new column named \"technology_type\" with values from \"platform\" existing column\ndf_example[,ncol(df_example)] %&gt;% head #show all rows and last column\n\n# A tibble: 6 × 1\n  technology_type\n  &lt;chr&gt;          \n1 10x            \n2 10x            \n3 10x            \n4 10x            \n5 10x            \n6 10x            \n\n\nThe values from chosen column can be replaced with other values. In example below we search in df_example data frame in technology_type column for rows that contain “BD-Rhapsody” text. For those values we assign “microwell-based”.\n\ndf_example$technology_type[df_example$technology_type == \"BD-Rhapsody\"] &lt;- \"microwell-based\"\ndf_example$technology_type[df_example$technology_type == \"10x\"] &lt;- \"droplet-based\"\n\ndf_example[,c(\"platform\",\"technology_type\")] %&gt;% head #display columns\n\n# A tibble: 6 × 2\n  platform technology_type\n  &lt;chr&gt;    &lt;chr&gt;          \n1 10x      droplet-based  \n2 10x      droplet-based  \n3 10x      droplet-based  \n4 10x      droplet-based  \n5 10x      droplet-based  \n6 10x      droplet-based  \n\n\nThe last useful function to cover in this chapter is summary(). The function gives the statistical summary of each of the columns when applied on data frame. It can be applied on slice of data as for example only on one column or chosen columns and rows.\n\nsummary(df_example)\n\n      ...1           study             dataset            patient         \n Min.   :  0.00   Length:322         Length:322         Length:322        \n 1st Qu.: 80.25   Class :character   Class :character   Class :character  \n Median :160.50   Mode  :character   Mode  :character   Mode  :character  \n Mean   :160.50                                                           \n 3rd Qu.:240.75                                                           \n Max.   :321.00                                                           \n                                                                          \n  uicc_stage        tumor_stage            sex            ever_smoker       \n Length:322         Length:322         Length:322         Length:322        \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n                                                                            \n driver_genes        condition              age          platform        \n Length:322         Length:322         Min.   :20.00   Length:322        \n Class :character   Class :character   1st Qu.:56.00   Class :character  \n Mode  :character   Mode  :character   Median :63.00   Mode  :character  \n                                       Mean   :60.73                     \n                                       3rd Qu.:69.00                     \n                                       Max.   :90.00                     \n                                       NA's   :89                        \n platform_fine       ...14         tissue: normal   tissue: normal_adjacent\n Length:322         Mode:logical   Min.   :0.0000   Min.   :0.0000         \n Class :character   NA's:322       1st Qu.:0.0000   1st Qu.:0.0000         \n Mode  :character                  Median :0.0000   Median :0.0000         \n                                   Mean   :0.2267   Mean   :0.3261         \n                                   3rd Qu.:0.0000   3rd Qu.:1.0000         \n                                   Max.   :1.0000   Max.   :1.0000         \n                                                                           \n tissue: tumor_primary tissue: tumor_metastasis technology_type   \n Min.   :0.0000        Min.   :0.0000           Length:322        \n 1st Qu.:0.0000        1st Qu.:0.0000           Class :character  \n Median :1.0000        Median :0.0000           Mode  :character  \n Mean   :0.5497        Mean   :0.1398                             \n 3rd Qu.:1.0000        3rd Qu.:0.0000                             \n Max.   :1.0000        Max.   :1.0000                             \n                                                                  \n\n\n\nsummary(df_example$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  20.00   56.00   63.00   60.73   69.00   90.00      89"
  },
  {
    "objectID": "precourse_preparation_R.html#pipe",
    "href": "precourse_preparation_R.html#pipe",
    "title": "Precourse Preparation - R",
    "section": "2.1 Pipe",
    "text": "2.1 Pipe\nA pipe is a type of operator in R %&gt;%. It takes the output of one function and passes it as the first argument of the next function, allowing us to chain together several steps in R.\n\nCredit: tidyverse.org\nThe pipe sends the data on left side of the pipe to be the first argument of the function on the right side of the pipe.\n\n16 %&gt;% sqrt() # is equivalent to sqrt(16)\n\n[1] 4\n\n\nWe can pipe multiple functions together. The operations are performed from the left to the right sequentially.\n\n16 %&gt;% sqrt() %&gt;% log2() # is equivalent to log2(sqrt(16))\n\n[1] 2\n\n\nBelow you can find exercises with more examples of piping mathematical functions in R together.\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise: What would be the equivalent mathematical expression to below piped sequence of operations?\n\n\n26 %&gt;% -22 %&gt;% sqrt() %&gt;% +4\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer:\n\n\nsqrt(26-22) + 4\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nExercise: How below mathematical operation can be shown with pipe option?\n\n\nsqrt(log2(64)) - 8\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nAnswer\n\n\n64 %&gt;% log2() %&gt;% sqrt() %&gt;% -8"
  },
  {
    "objectID": "precourse_preparation_R.html#example-data-1",
    "href": "precourse_preparation_R.html#example-data-1",
    "title": "Precourse Preparation - R",
    "section": "2.2 Example data",
    "text": "2.2 Example data\nIn this chapter we will work on an expression matrix table which is in CSV format. Below is example of how to load the table.\n\nexpMat &lt;- fread(file = \"data/precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE)\n\n# file: provide full directory to file\n# sep: indicate separator, in this case coma\n# header = True is indicating to take the first row as a column names\n\nDisplaying first rows and columns of the table gives us a glimpse on what the data contain.\n\nexpMat[c(1:5),c(1:5)]\n\n         V1 A1BG A1BG.AS1 A1CF A2M\n1:  3261781    0        0    0   0\n2:  9155806    0        0    0   0\n3:  4304661    0        0    0   0\n4:  2216902    0        0    0   0\n5: 13160139    0        0    0   0\n\n\nThe gene names are displayed in columns and rows contain information about the cells. The column named V1 hold information about the cell index that is given to each cell in primary analysis.\nWe will set the V1 column as row names. In that way all the columns will contain the gene or protein counts.\n\n#use first column as row names\nexpMat &lt;- data.frame(expMat, row.names = 1)\n\nThe same set of above operations can be performed with pipe in one line of code. We read the file and convert first column to row names and save as data frame. The result is assigned to expMat variable by using the arrow.\n\n#pipe operations\nexpMat &lt;- fread(file = \"data/precourse_preparation_data/Demo-WTA-AbSeq.csv\", sep = \",\", header=TRUE) %&gt;% data.frame(row.names = 1)"
  },
  {
    "objectID": "precourse_preparation_R.html#select",
    "href": "precourse_preparation_R.html#select",
    "title": "Precourse Preparation - R",
    "section": "2.3 select()\n",
    "text": "2.3 select()\n\nFunctionality: Select only the columns (variables) that you want to see. Gets rid of all other columns.\nImagine you are interested to extract the data only for one gene existing in your dataset. You can use the gene name, for example “CD4”, to indicate in select function which column should be selected.\n\n# choosing the column of CD4 gene\nexpMat %&gt;% dplyr::select(\"CD4\") -&gt; CD4_column\n\nIn the table we work on, the protein and gene expression information are provided. All the protein markers are labeled with “pAbO” abbreviation, in addition to marker name. We can select all the columns that contain pAbO in name and save to new table.\n\n#choosing all the columns with AbSeq counts and saving to abseq_data\nexpMat %&gt;% dplyr::select(contains(\"pAbO\")) -&gt; abseq_data\n\nAll the columns that does not contain the “pAbO” are representing genes. To create a gene data, we can use the contains() function with exclamation mark as in below example.\nThe “!” is used for negation in R language and is interpreted as “do not”. Below expression will be interpreted as “select from expMat columns that do not contain pAbO.”.\n\n# choosing all columns that does not contain AbSeq counts (mRNA only)\nexpMat %&gt;% dplyr::select(!contains(\"pAbO\")) -&gt; mrna_data"
  },
  {
    "objectID": "precourse_preparation_R.html#mutate",
    "href": "precourse_preparation_R.html#mutate",
    "title": "Precourse Preparation - R",
    "section": "2.4 mutate()\n",
    "text": "2.4 mutate()\n\nFunctionality: Adds new columns or modifies current variables in the dataset.\nThe mutate function allows in easy way to add new columns in existing tables. Let’s say we want to add column named “measurement_type” and fill with “protein expression” in abseq data table we created in previous step.\n\n#add new column with the same value\nabseq_data %&gt;% mutate(data_modality = \"protein_expression\") -&gt; abseq_data \n\nThe new column will be added at the end of table. We can show the column by selecting the column name.\n\n#display results\nabseq_data %&gt;% dplyr::select(\"data_modality\") %&gt;% head\n\n              data_modality\n3261781  protein_expression\n9155806  protein_expression\n4304661  protein_expression\n2216902  protein_expression\n13160139 protein_expression\n11951658 protein_expression\n\n\nMutate function can be used in combination with other functions.\nIn this example we will calculate sum of expression count for each cell and store information in table. We summarize the counts from all rows ad add as a new column. The rowSums function is useful for calculating the sum of counts in each row.\n\nrowSums(mrna_data) -&gt; mRNA_count_sum\n\n#display results\nmRNA_count_sum %&gt;% head\n\n 3261781  9155806  4304661  2216902 13160139 11951658 \n   35231    34733    33238    31618    31664    30786 \n\n\nAfter running rowSums we got for each cell the number of counts. The values can be added in mrna data table as a new column.\n\nmrna_data %&gt;% mutate(counts = mRNA_count_sum) -&gt; mrna_data\nmrna_data %&gt;% dplyr::select(counts) %&gt;% head\n\n         counts\n3261781   35231\n9155806   34733\n4304661   33238\n2216902   31618\n13160139  31664\n11951658  30786\n\n\nThe same result can be generated with option below, where the rowSums function is nested inside the mutate function.\n\nmrna_data %&gt;% mutate(counts = rowSums(mrna_data)) -&gt; mrna_data\n\nNotice that mrna_data is given twice in that case as an argument. The mrna_data is taken by mutate function as first argument and then in rowSums function as second argument.\nIn above example we used pipe to direct the mrna_data to mutate() function as argument. However the mrna_data was not forwarded by pipe to rowSums. For that reason we had to type it in the rowSums function. By default pipe operator forwards data only as first argument to a function. If you want the pipe to forward data as well as second (and next) argument to function you can use a dot.\n\nmrna_data %&gt;% mutate(counts = rowSums(.)) -&gt; mrna_data"
  },
  {
    "objectID": "precourse_preparation_R.html#summarise",
    "href": "precourse_preparation_R.html#summarise",
    "title": "Precourse Preparation - R",
    "section": "2.5 summarise()\n",
    "text": "2.5 summarise()\n\nFunctionality: Collapses all rows and returns a one-row summary.\nIn the example below, summarize function allow us to calculate the max/min, median and mean values for counts.\n\nmrna_data %&gt;% dplyr::summarise(mean = mean(counts),    #mean counts\n                             median = median(counts),    #median counts\n                             max = max(counts),    #maximum count\n                             min = min(counts))   #minimum count\n\n      mean median    max  min\n1 9142.064   4392 105693 1146\n\n\nIn above summary we have the overview of the expression range and how minimum and maximum values of molecules expressed differ. Some of cells will have very low transcriptome size in comparison to others."
  },
  {
    "objectID": "precourse_preparation_R.html#if_else",
    "href": "precourse_preparation_R.html#if_else",
    "title": "Precourse Preparation - R",
    "section": "2.6 if_else()\n",
    "text": "2.6 if_else()\n\nThe if_else() function in R is a conditional function. It allows to test the hypothesis and perform actions based on answer.\nLet’s assume we want to label the cells according to transcriptom size. Based on threshold of counts we give a label of “low_transcriptome” or “high_transcriptome” for a cell status. We can make assumption that all cells with sum of counts lower then thousand are low transcriptome cells and remaining cells are categorized as high transcriptome cells.\nThe if_else function with combination of mutate will help us to achieve the goal.\nFirst we need to know what is the structure of if_else statement. The first argument of if_else function is the hypotheses or the statement. In our case we want to test if count for cell is below or above the threshold. Second argument of a function is an action to perform if the statement is true. Third argument of if_else function is an action to perform when the statement is false.\n\nIn our case the hypothesis to test is if counts in a cell are below or above the threshold. We can set the condition to have a counts above 2000. If the counts are above the threshold the statement is true. When the statement is true the action is to set the label as “high_transcriptome”. When the statement is false we set the label as “low_transciptome”.\n\nif_else(mrna_data$counts &gt; 2000, \"high_transcriptome\", \"low_transcriptome\") -&gt; cell_status\n\nIn that way we created a cell status for cells based on counts. We should see in a cell_status that was generated two labels. To verify if that is the case we can display unique values of a created vector.\n\nunique(cell_status)\n\n[1] \"high_transcriptome\" \"low_transcriptome\" \n\n\nIf we would like to add that information as a new column to data table, we can use mutate function as in previous examples.\n\n#calcuate and add cell_status to mrna table\nmrna_data %&gt;% mutate(cell_status = if_else(mrna_data[\"counts\"] &gt; 2000, \"high_transcriptome\", \"low_transcriptome\")) -&gt; mrna_data\n\n#display cell status column \nmrna_data %&gt;% dplyr::select(cell_status) %&gt;% head\n\n                cell_status\n3261781  high_transcriptome\n9155806  high_transcriptome\n4304661  high_transcriptome\n2216902  high_transcriptome\n13160139 high_transcriptome\n11951658 high_transcriptome"
  },
  {
    "objectID": "precourse_preparation_R.html#count",
    "href": "precourse_preparation_R.html#count",
    "title": "Precourse Preparation - R",
    "section": "2.7 count()\n",
    "text": "2.7 count()\n\nFunctionality: Collapses the rows and counts the number of observations per group of values.\nThe count function is a quick way to have an overview on number of occurrences. For example to we can use count() to see how many cells were categorized as low or high transcriptome cells.\n\nmrna_data %&gt;% dplyr::count(cell_status)\n\n         cell_status    n\n1 high_transcriptome 5204\n2  low_transcriptome  597"
  },
  {
    "objectID": "precourse_preparation_R.html#group_by",
    "href": "precourse_preparation_R.html#group_by",
    "title": "Precourse Preparation - R",
    "section": "2.8 group_by()\n",
    "text": "2.8 group_by()\n\nFunctionality: Takes existing data and groups specific variables together for future operations.\nThe function takes an existing table and convert it into grouped table where operations are performed by group.\nLet’s have a look into following example and assume that we want to compare the mean and median counts for low and high transcriptome cells. In that case we can group data by cell status and calculate average values for those groups.\n\nmrna_data %&gt;% \n  group_by(cell_status) %&gt;% \n  summarize(mean = mean(counts),\n            median = median(counts),\n            n = n())  #calculates the total number of observations\n\n# A tibble: 2 × 4\n  cell_status          mean median     n\n  &lt;chr&gt;               &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;\n1 high_transcriptome 10006.  4684.  5204\n2 low_transcriptome   1611.  1638    597\n\n\nIn the above code, we have grouped by cell status, meaning that calculations performed on our data will account for high transcriptome and low transcriptome cells separately. Following code execution, the console displays the mean count, the median count and the total number of cells (n()) for low transcriptome and for high transcriptome cells (group_by(cell_status))."
  },
  {
    "objectID": "precourse_preparation_R.html#filter",
    "href": "precourse_preparation_R.html#filter",
    "title": "Precourse Preparation - R",
    "section": "2.8 filter()\n",
    "text": "2.8 filter()\n\nFunctionality: Only retain specific rows of data that meet the specified requirement(s).\nFilter function display from the data values that meet defined condition. For example, we can filter all cells with low transcriptome cell status and retain only high transcriptome cells.\n\nmrna_data %&gt;% filter(cell_status == \"high_transcriptome\") -&gt; signal_cells\n\n#display last column\nsignal_cells %&gt;% dplyr::select(last_col()) %&gt;% head()\n\n         cell_status\n1 high_transcriptome\n2 high_transcriptome\n3 high_transcriptome\n4 high_transcriptome\n5 high_transcriptome\n6 high_transcriptome"
  },
  {
    "objectID": "precourse_preparation_R.html#rename",
    "href": "precourse_preparation_R.html#rename",
    "title": "Precourse Preparation - R",
    "section": "2.9 rename()\n",
    "text": "2.9 rename()\n\nFunctionality: Renames a column/variable by name and index.\nRenames the cell_status variable as SIGNAL_CELLS (notice that the new label goes first in the argument).\n\nmrna_data %&gt;% rename(SIGNAL_CELLS = cell_status) -&gt; mrna_data\n\n#display results\nmrna_data %&gt;% dplyr::select(last_col()) %&gt;% head #chose last column from mrna_data\n\n               SIGNAL_CELLS\n3261781  high_transcriptome\n9155806  high_transcriptome\n4304661  high_transcriptome\n2216902  high_transcriptome\n13160139 high_transcriptome\n11951658 high_transcriptome"
  },
  {
    "objectID": "precourse_preparation_R.html#seurat-object-structure",
    "href": "precourse_preparation_R.html#seurat-object-structure",
    "title": "Precourse Preparation - R",
    "section": "3.1 Seurat Object Structure",
    "text": "3.1 Seurat Object Structure\nSeurat object stores information about the single cell multiomics data and the analysis that was done during downstream workflow. As we move through the workflow and make calculations, the results are added to Seurat object and stored in different “boxes”. Those different “boxes” are called slots.\nLet’s load the Seurat object into R.\n\nseuratObj &lt;- readRDS(\"data/precourse_preparation_data/seuratObj.rds\")\n\nLoaded Seurat object was created including mRNA counts table obtained from primary analysis. While Seurat object is generated the following information are added to Seurat slots by default: assays, meta data, active assay, active identity, project name and version.\n\nThe remaining Seurat slots highlighted in grey are empty and filled in with information while it is calculated over analysis.\nYou can open the Seurat object in separate tab and review its content."
  },
  {
    "objectID": "precourse_preparation_R.html#assays",
    "href": "precourse_preparation_R.html#assays",
    "title": "Precourse Preparation - R",
    "section": "3.2 Assays",
    "text": "3.2 Assays\nThe assays slot contain different assays loaded into Seurat object. Those can be for example mRNA expression data or protein expression data. The assay slot is described by additional subslots that stores ‘transformations’ of the data, including raw counts (counts slot), normalized data (data slot), and scaled data for dimensional reduction (scale.data slot).\nThe assays slots can be accessed by function GetAssayData. In example below we access the counts slot.\n\n#Seurat object saved before normalization\nGetAssayData(object = seuratObj, slot = \"counts\") %&gt;% \n  .[1:5 , c(\"6660551\",\"2066735\",\"9164959\",\"3709837\")]\n\n5 x 4 sparse Matrix of class \"dgCMatrix\"\n         6660551 2066735 9164959 3709837\nA1BG           .       1       .       .\nA1BG.AS1       1       .       1       .\nA1CF           .       .       .       .\nA2M            .       .       .       2\nA2M.AS1        .       .       .       .\n\n\nWe can perform normalization and store the normalized counts in data slot.\n\n#Seurat object saved after normalization\nNormalizeData(seuratObj) %&gt;% \nGetAssayData(object = ., slot = \"data\") %&gt;% \n  .[1:5 , c(\"6660551\",\"2066735\",\"9164959\",\"3709837\")]\n\n5 x 4 sparse Matrix of class \"dgCMatrix\"\n          6660551   2066735   9164959   3709837\nA1BG     .        0.3399948 .         .        \nA1BG.AS1 0.330402 .         0.3532289 .        \nA1CF     .        .         .         .        \nA2M      .        .         .         0.6642082\nA2M.AS1  .        .         .         .        \n\n\nBy running above example you can see the raw values in data slot are changed due to LogTransform normalization.\nBelow you can find a useful graphics indicating how data are altered in assays slots in Seurat object after applying different functions related to normalization and scaling the data.\n\nCredit: Lior Pachter https://twitter.com/lpachter/status/1524413513233575936"
  },
  {
    "objectID": "precourse_preparation_R.html#meta-data",
    "href": "precourse_preparation_R.html#meta-data",
    "title": "Precourse Preparation - R",
    "section": "3.3 Meta Data",
    "text": "3.3 Meta Data\nmeta.data slot stores information calculated for cells as for example number of features in each cell, number of counts or cell clusters calculated in downstream process.\nThe meta.data information is stored in a table that can be accessed in Seurat object as below.\n\nseuratObj@meta.data %&gt;% head\n\n            orig.ident nCount_RNA nFeature_RNA\n3261781  SeuratProject      35231         5823\n9155806  SeuratProject      34733         5943\n4304661  SeuratProject      33238         5480\n2216902  SeuratProject      31618         5573\n13160139 SeuratProject      31664         5592\n11951658 SeuratProject      30786         5457\n\n\nTo view list of all available meta.data in Seurat object we can view the column names from the data table.\n\nseuratObj@meta.data %&gt;% colnames()\n\n[1] \"orig.ident\"   \"nCount_RNA\"   \"nFeature_RNA\"\n\n\nIt is possible to add new information to meta data. It can be any information about the cells as experimental batch or sub-population identity.\n\n#add meta data\nseuratObj &lt;- AddMetaData(seuratObj, #indicate object\n            \"experiment_1\", #metadata to be added\n            \"batch\") #column name for metadata\n\n#display results\nseuratObj@meta.data %&gt;% head\n\n            orig.ident nCount_RNA nFeature_RNA        batch\n3261781  SeuratProject      35231         5823 experiment_1\n9155806  SeuratProject      34733         5943 experiment_1\n4304661  SeuratProject      33238         5480 experiment_1\n2216902  SeuratProject      31618         5573 experiment_1\n13160139 SeuratProject      31664         5592 experiment_1\n11951658 SeuratProject      30786         5457 experiment_1"
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "",
    "section": "",
    "text": "Copyright (c) 2011-2023 GitHub Inc.\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "03_normalization.html",
    "href": "03_normalization.html",
    "title": "Chapter 3 Normalization and PCA",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\n\nLoad RData\nLoad the RData which contain all files from previous chapter.\n\nload(\"data/intermediate_data/chapter2.RData\")\n\n\n1. Normalization\nWe will perform normalization on UMI counts using LogNormalize.\nLogNormalize divides the UMI counts of a gene in a cell into the total UMI counts in that cell. After division, we take the natural log.\n\nfiltered.rna &lt;- NormalizeData(filtered.rna, \n                              normalization.method = \"LogNormalize\")\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhere are the normalized counts stored?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe normalizaed counts are stored in the slot RNA.\n\nfiltered.rna@assays[[\"RNA\"]]@data[1:5, 1:5]\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n          74 391 440 1222 2690\nA1BG-AS1   .   .   .    .    .\nA1CF       .   .   .    .    .\nA2M        .   .   .    .    .\nA2M-AS1    .   .   .    .    .\nA2ML1-AS1  .   .   .    .    .\n\n\n\n\n\n2. Evaluating effects of mitochondrial percentage\nThe unwanted variation, such as the difference in mitochondrial percentage, could affect the downstream analysis.\nFor example, we don’t want the cells clustered based on the difference in mitochondrial percentage.\nLet’s first look at if the mitochondrial percentage introduces unwanted variation. We take the normalized counts and see if we have unwanted variation from the mitochondrial percentage.\n\nThe mitochondrial percentage is a series of numbers. We can turn the mitochondrial percentage variable into a categorical variable based on quartiles.\n\n\nsummary(filtered.rna$percent.mt)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.2155 10.1004 12.4155 12.6649 15.1489 24.9487 \n\n\nBelow 1st quartile: Low.\nBetween 1st and Median: Median.\nBetween Median and 3rd quartile: Median high.\nbeyond 3rd quartile (15.4158%): High.\nNext, we create a new variable based on the cutoff.\n\nfiltered.rna$quartile.mt &lt;- cut(filtered.rna$percent.mt, \n                                breaks=c(-Inf, 10.1004, 12.4155, 15.1489, Inf),\n                                labels=c(\"Low\",\"Medium\",\"Medium high\", \"High\"))\n\nWe want to check whether the mitochondrial percentage is a source of variation using PCA. We plot the first two principal components to visualize the data.\n\n# Identify the most variable genes\nfiltered.rna &lt;- FindVariableFeatures(filtered.rna,\n                                           selection.method = \"vst\",\n                                           nfeatures = 2000, \n                                           verbose = FALSE)\n             \n# Scale the data\nfiltered.rna &lt;- ScaleData(filtered.rna, features = rownames(filtered.rna))\n\n# perform PCA\nfiltered.rna &lt;- RunPCA(filtered.rna)\n\n# Plot pc1 and pc2\nDimPlot(filtered.rna,\n        reduction = \"pca\",\n        group.by= \"quartile.mt\",\n        split.by = \"quartile.mt\")\n\n\n\n\nBased on the above plot, we can see a different scatter pattern in cells with “Low” mitochondrial percentage.\nWe observe that the lobe of cells in the left middle side of the plot is in the category “Low”. For all other levels of mitochondrial percentage, we see a more even distribution of cells across the PCA plot.\n\n\n\n\n\n\nTip\n\n\n\nOftentimes, it is helpful to regress out variation due to mitochondrial percentage. However, if the differences in mitochondrial gene expression represent a biological phenomenon that might help to distinguish cell clusters, then we do not regress it out.\n\n\n\n\n\n\n\n\nTip\n\n\n\nCell cycle is another common variation. For instructions, please refer to https://satijalab.org/seurat/articles/cell_cycle_vignette.html\n\n\nTo regress out the effect mitochondrial percentage, add the argument vars.to.regress = \"percent.mt\" to the ScaleData.\n\n# Scale the data\nfiltered.rna &lt;- ScaleData(filtered.rna, \n                                features = rownames(filtered.rna), \n                                vars.to.regress = \"percent.mt\")\n\n# perform PCA\nfiltered.rna &lt;- RunPCA(filtered.rna)\n\n3. Save\nSave the files into RData for documentation.\n\n# save(filtered.rna, expMat, file = \"data/intermediate_data/chapter3.RData\")"
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setting up",
    "section": "",
    "text": "Note\n\n\n\nNote The course will run on virtual machine. We have materials and RStuio setting up on the virtual machine, so you do not need to set up anything on the desktop for the course.\nHowever, if you are going to run through the prerequisites and the course chapters, please follow the instructions and set up RStudio on the desktop.\nThe learning outcome is much better if you go through the materials before attending the course from feedback of our previous students.\n\n\n1. R and RStudio\nPlease follow the instruction to set up R and RStudio on desktop: https://posit.co/download/rstudio-desktop/\n2. Install R packages\n\n\n\n\n\n\nNote\n\n\n\nInstall the packages in the order listed below.\nThe package names are case sensitive.\nAt any point (especially if you’ve used R/Bioconductor in the past), in the console R may ask you if you want to update any old packages by asking Update all/some/none? [a/s/n]:. If you see this, type “a” at the prompt and hit Enter to update any old packages. Updating packages can sometimes take quite a bit of time to run, so please account for that before you start with these installations.\n\n\n\nInstall the packages listed below one by one from CRAN using the install.packages() function.\n\ninstall.packages(\"tidyverse\")\ninstall.packages(\"Seurat\")\ninstall.packages(\"BiocManager\")\ninstall.packages(\"Matrix\")\ninstall.packages(\"RCurl\")\ninstall.packages(\"scales\")\ninstall.packages(\"data.table\")\ninstall.packages(\"readxl\")\n\nInstall the packages listed below one by one from bioconductor using the BiocManager::install() function.\n\nBiocManager::install(\"AnnotationHub\")\nBiocManager::install(\"ensembldb\")\nBiocManager::install(\"SingleR\")\nBiocManager::install(\"celldex\")\nBiocManager::install(\"org.Hs.eg.db\")\nBiocManager::install(\"clusterProfiler\")\nBiocManager::install(\"AnnotationDbi\")\nBiocManager::install(\"biomaRt\")\nBiocManager::install(\"enrichplot\")\nBiocManager::install(\"muscat\")\n\nCheck that all the packages were installed successfully by loading them one at a time using the library() function.\n\n\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(BiocManager)\nlibrary(Matrix)\nlibrary(RCurl)\nlibrary(readxl)\nlibrary(scales)\nlibrary(data.table)\nlibrary(AnnotationHub)\nlibrary(ensembldb)\nlibrary(SingleR)\nlibrary(celldex)\nlibrary(org.Hs.eg.db)\nlibrary(clusterProfiler)\nlibrary(AnnotationDbi)\nlibrary(biomaRt)\nlibrary(enrichplot)\nlibrary(muscat)\n\n3. Data required to run the materials\nPlease access the below folder to download data to run the prerequisites and course chapters.\nData"
  },
  {
    "objectID": "precourse_preparation_theory.html",
    "href": "precourse_preparation_theory.html",
    "title": "Precourse Preparation - Theory",
    "section": "",
    "text": "Inside our bodies, there’s a huge variety of cell types that have different functions and interact with each other. Imagine it like a bustling city with different kinds of workers.\nTo understand these cells better, scientists use single-cell RNA sequencing (scRNA-seq) technique. It’s like taking a close-up picture of each cell to see which genes are active. This helps us learn what each cell is up to in a really detailed way.\nThis new and advanced technique can be employed to:\n\nInvestigating the different types of cells in a specific part of the body. Example: Understanding the various cell types in the brain to study its functions better.\nDiscovering cell types or states that are not well-known or rare. Example: Identifying unique cell types in the immune system that might have important roles.\nFiguring out how genes change their activity as cells transform or over time. Example: Tracking how genes behave as stem cells develop into specialized heart cells.\nSpotting genes that are only active in certain cell types under different conditions, like when there’s a disease. Example: Finding genes that are switched on only in lung cells during asthma.\nExamining how gene activity changes within a cell type and also consider aspects like where the genes are located, how they’re controlled, and their protein products. Example: Studying how nerve cells in the spinal cord change their gene activity and what proteins they make in response to injury."
  },
  {
    "objectID": "precourse_preparation_theory.html#bd-rhapsody-single-cell-assays",
    "href": "precourse_preparation_theory.html#bd-rhapsody-single-cell-assays",
    "title": "Precourse Preparation - Theory",
    "section": "2.1 BD Rhapsody Single-Cell Assays",
    "text": "2.1 BD Rhapsody Single-Cell Assays\n\nThe BD Rhapsody™ System, along with diverse range of assays, enables simultaneous measurement of multiple cell parameters across tens of thousands of individual cells in parallel. By combining available assays, researchers can generate robust and intricate datasets, unlocking powerful insights:\nGene Expression: The primary purpose of scRNA-seq is to measure the expression of genes within individual cells. This allows to understand which genes are active or inactive in each cell and to identify different cell types based on their gene expression profiles.\nAntibody-Based Protein Analysis: You can use antibodies conjugated with unique barcodes to simultaneously measure the expression of specific proteins in individual cells. This enables protein-level analysis alongside gene expression.\nSample multiplexing with antibody-based techniques: involves using generic antibody conjugated with unique barcodes to label the cells for different samples. Each sample is labeled and idenfied with unique antibody barcode.\nImmune Repertoire Profiling: Rhapsody can be used for immune profiling, allowing researchers to analyze the diversity and clonality of T-cell and B-cell receptor repertoires. This is valuable for studying the immune response and identifying antigen-specific cells.\nAntigen-Specific T-cell Analysis: Immudex’s technology combined with the Rhapsody system, enables the precise profiling of T cells that recognize specific antigens, like viral epitopes or tumor-related antigens. This expands immune profiling possibilities, aiding vaccine development, immunotherapy research, and the study of immune-related diseases.\nFrom scRNA-seq for gene expression profiling to antibody-based protein analysis, these assays empower researchers to explore and dissect the multifaceted world of cellular functions and molecular dynamics with precision"
  },
  {
    "objectID": "precourse_preparation_theory.html#analysis-of-single-cell-data",
    "href": "precourse_preparation_theory.html#analysis-of-single-cell-data",
    "title": "Precourse Preparation - Theory",
    "section": "2.2 Analysis of Single Cell Data",
    "text": "2.2 Analysis of Single Cell Data\nThe analysis of single cell data can be split into two parts. The primary analysis transforms raw data into an expression matrix, where each row represents a gene, each column represents a cell, and each entry in the matrix contains the count of molecules for a particular gene or protein in a specific cell. Secondary analysis focus on extracting meaningful biological insights from this expression matrix, such as identifying cell types, studying differential gene expression, and understanding cellular processes and functions.\n\nThe workshop will focus on providing insights into secondary analysis. At the same time the primary analysis lays the foundation for secondary and downstream analyses. The next chapter covers information about primary analysis useful to know while working with single-cell data."
  },
  {
    "objectID": "precourse_preparation_theory.html#from-sequencing-data-to-expression-matrix",
    "href": "precourse_preparation_theory.html#from-sequencing-data-to-expression-matrix",
    "title": "Precourse Preparation - Theory",
    "section": "2.3 From Sequencing Data to Expression Matrix",
    "text": "2.3 From Sequencing Data to Expression Matrix\nThe analysis of sequencing data is handled by the software provided by BD to Rhapsody users that enables fast and easy data processing. In this chapter we will cover a key features of the pipeline and explain key concepts necessary to understand while working with single cell data.\n\n2.3.1 BD Rhapsody Sequencing Analysis Pipeline\nThe BD Rhapsody sequencing analysis pipeline is a series of computational and analytical steps used to process and extract meaningful information from the raw sequencing data generated by the BD Rhapsody system.\nThe goal of sequencing analysis is to transform text-based genomic data into numerical data, and we achieve this through a series of steps in our pipeline. The steps of the pipeline are listed in simplified graphics below.\n\nThe main steps of the pipeline include quality control of raw sequencing data, molecule counting, identifying the putative cells and sample of origin if multiple samples were processed in one experiment.\nCrucial Steps in the process are decoding the unique barcodes associated with individual cells and the information about gene expression. Additionally, we use a technique called Unique Molecular Identifiers (UMIs) to count gene expression accurately. These steps enable us to precisely identify and quantify the activity of genes in each cell, forming the basis for further analysis.\n\n\n2.3.2 Expression Counts by UMIs\nUnique Molecular Identifiers (UMIs) are used to distinguish between molecules expressed in a cell by providing a way to count individual molecules accurately. Here’s how they work to differentiate and quantify molecules in a cell:\n\nAdding UMIs during RNA sequencing preparation: UMIs are small, unique sequences of DNA that are added to the capture sequences of the bead during the production. Each bead contains tens of thousands of unique UMI barcodes which are followed by the polyA capture sequence. During the cell processing, the polyadenylated molecules in a cell, as mRNAs are captured on the bead. Each UMI is specific to the molecule it’s attached to and become it’s unique tag (see Figure below).\n\n\n\n\nCreating copies of RNA molecules: After adding UMIs, scientists make many copies of all the RNA molecules in the cell by running PCR. This step ensures that there are enough copies to work with.\nSequencing the molecules: The copies of RNA molecules, including the attached UMIs, are then sequenced. Sequencing means reading the genetic code of these molecules to determine their identity.\n\nAnalyzing the data: When the sequencing is done, scientists look at the data. Here’s where UMIs become important:\n\nRemoving duplicates: Because UMIs are unique to each original RNA molecule, any duplicates (multiple copies of the same RNA molecule) with the same UMI are likely the result of PCR (Polymerase Chain Reaction) amplification during the sequencing process. Scientists can identify and remove these duplicates to get an accurate count of different RNA molecules.\nCounting unique molecules: By looking at the UMIs, scientists can count how many unique RNA molecules were originally present in the cell. This helps them understand which genes were active in the cell and to what extent.\nQuantifying gene expression: By counting the unique UMIs associated with each gene, scientists can measure the expression level of genes in the cell. Genes with more UMIs were more active in the cell, while genes with fewer UMIs were less active.\n\nIn summary, UMIs are used to distinguish between molecules expressed in a cell by providing a unique identifier for each original molecule. This helps in accurately counting and quantifying gene expression, which is crucial for understanding how genes function in single cells and studying cellular processes in detail.\n\n\n2.3.3 Output Files\nWe handle various types of data all at once during primary analysis. This includes data related to gene expression at first but can include as well protein expression or information about T-cell receptors (TCR), B-cell receptors (BCR), and sample tags depending on experimental part. The assays run during experiments determine what type of data will be generated and what output files are available for the users for downstream analysis.\nThe information about cells is stored in multiple output files. In below you can find summary of what output files relates to which information about the cell.\n\nThe primary analysis output files are taken as an input to secondary analysis. During the workshop we will work with data that include mRNA, protein and sample tag information. You will get to know how to load the expression matrice in MEX format for downstream analysis."
  },
  {
    "objectID": "02_quality_control.html",
    "href": "02_quality_control.html",
    "title": "Chapter 2 Quality Control",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)"
  },
  {
    "objectID": "02_quality_control.html#ncount_rna-umi-counts-per-cell",
    "href": "02_quality_control.html#ncount_rna-umi-counts-per-cell",
    "title": "Chapter 2 Quality Control",
    "section": "3.1 nCount_RNA UMI counts per cell",
    "text": "3.1 nCount_RNA UMI counts per cell\nWe look at nCount_RNA for the sum of UMI counts per cell.\n\nrna@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=nCount_RNA, fill= Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  ggtitle(\"nCount_RNA\")"
  },
  {
    "objectID": "02_quality_control.html#nfeature_rna-gene-counts-per-cell",
    "href": "02_quality_control.html#nfeature_rna-gene-counts-per-cell",
    "title": "Chapter 2 Quality Control",
    "section": "3.2 nFeature_RNA Gene counts per cell",
    "text": "3.2 nFeature_RNA Gene counts per cell\nWe look at nFeature_RNA for sum of gene counts per cell. The majority of cells have gene counts more than 300.\n\nrna@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=nFeature_RNA, fill= Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  ylab(\"Cell density\") +\n  ggtitle(\"nFeature_RNA\")"
  },
  {
    "objectID": "02_quality_control.html#percent.mt-mitochondrial-percentage-per-cell",
    "href": "02_quality_control.html#percent.mt-mitochondrial-percentage-per-cell",
    "title": "Chapter 2 Quality Control",
    "section": "3.3 percent.mt Mitochondrial percentage per cell",
    "text": "3.3 percent.mt Mitochondrial percentage per cell\nWe look at percent.mt for mitochondrial percentage per cell. The majority of cells have mitochondrial percentage below 25%.\n\nrna@meta.data %&gt;% \n  ggplot(aes(color=Sample_Name, x=percent.mt, fill=Sample_Name)) + \n  geom_density(alpha = 0.2) + \n  theme_classic() +\n  ggtitle(\"percent.mt\")"
  },
  {
    "objectID": "02_quality_control.html#combine-metrics-to-come-up-filtering-threshold",
    "href": "02_quality_control.html#combine-metrics-to-come-up-filtering-threshold",
    "title": "Chapter 2 Quality Control",
    "section": "3.4 Combine metrics to come up filtering threshold",
    "text": "3.4 Combine metrics to come up filtering threshold\nWe can combine the metrics to decide the filtering threshold.\n\nrna@meta.data %&gt;% \n  ggplot(aes(x=nCount_RNA, y=nFeature_RNA, color=percent.mt)) + \n  geom_point() + \n  scale_colour_gradient(low = \"gray90\", high = \"black\") +\n  stat_smooth(method=lm) +\n  scale_x_log10() + \n  scale_y_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 500, colour = \"red\") +\n  geom_hline(yintercept = 300, colour = \"red\") +\n  facet_wrap(~Sample_Name) +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))\n\n\n\n\nThe data is fitted with a linear regression line. We expect when UMI counts increase, gene counts also increase.\nUpper right quadrant: Cells with high number of genes and UMI counts. We generally consider these cells to be good-quality cells.\nBottom right quadrant: Cells with low number of genes and UMI counts. We generally consider these cells are low-quality cells.\nDarker cells: Cells with high mitochondrial percentage. Many of these cells have low gene counts. This could indicate damaged/dying cells whose cytoplasmic mRNA leaked out through a broken membrane, so only mRNA located in the mitochondria is still conserved."
  },
  {
    "objectID": "02_quality_control.html#filter-on-cells",
    "href": "02_quality_control.html#filter-on-cells",
    "title": "Chapter 2 Quality Control",
    "section": "4.1 Filter on cells",
    "text": "4.1 Filter on cells\nBased on the quality metrics, we use the following thresholds to filter out low quality cells:\nnCount_RNA &gt; 500\nnFeature_RNA &gt; 300\nnFeature_RNA &lt; 5000\npercent.mt &lt; 25%\n\nfiltered.rna &lt;- subset(x = rna, \n                       subset = (nCount_RNA &gt;= 500) & \n                         (nFeature_RNA &gt;= 300) &\n                         (nFeature_RNA &lt;= 5000) &\n                         (percent.mt &lt; 25))"
  },
  {
    "objectID": "02_quality_control.html#filter-on-genes",
    "href": "02_quality_control.html#filter-on-genes",
    "title": "Chapter 2 Quality Control",
    "section": "4.2 Filter on genes",
    "text": "4.2 Filter on genes\nSome of the genes have zero counts or are only expressed in a handful of cells. These genes don’t bring much information, and they reduce the average expression of a cell.\nWe keep only genes that are expressed in five or more cells. GetAssayData is a convenient command to get information from the Seurat object. We use GetAssayData to extract the UMI counts.\n\n# Extract counts\ncounts &lt;- GetAssayData(object = filtered.rna, slot = \"counts\")\n\n# Output a logical matrix specifying for each gene whether or not there are more than zero counts per cell\nnonzero &lt;- counts &gt; 0\n\n# Sum all TRUE values and return TRUE if equal or more than 5 TRUE values per gene\nkeep_genes &lt;- Matrix::rowSums(nonzero) &gt;= 5\n\n# Only keep those genes\nfiltered_counts &lt;- counts[keep_genes, ]\n\n# Create Seurat object\nfiltered.rna &lt;- CreateSeuratObject(filtered_counts, meta.data = filtered.rna@meta.data)\n\n\n\n\n\n\n\nTip\n\n\n\nTargeted assay contains genes expressing in the profiling cells, so “Filter on genes” is usually not performed on targeted assays."
  },
  {
    "objectID": "sessioninfo.html",
    "href": "sessioninfo.html",
    "title": "SessionInfo",
    "section": "",
    "text": "sessionInfo()\n\nR version 4.3.0 (2023-04-21)\nPlatform: x86_64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.5\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Amsterdam\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.0    fastmap_1.1.1     cli_3.6.1        \n [5] tools_4.3.0       htmltools_0.5.6   rstudioapi_0.15.0 yaml_2.3.7       \n [9] rmarkdown_2.24    knitr_1.43        jsonlite_1.8.7    xfun_0.40        \n[13] digest_0.6.33     rlang_1.1.1       evaluate_0.21"
  },
  {
    "objectID": "04_integration.html",
    "href": "04_integration.html",
    "title": "Chapter 4 Integration",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\n\nLoad RData\nLoad the RData which contain all files from previous chapter.\n\nload(\"data/intermediate_data/chapter3.RData\")\n\n1. To integrate or not to integrate?\nThe goal of integration is to find corresponding cell states across conditions (or experiments). We want to identify cell types which are present in all samples/conditions/modalities within our dataset. We expect to observe a representation of cells from samples/conditions/modalities in every cluster.\nWe first look at how cells cluster without integration to determine whether integration is necessary. Integration is considered if cells cluster separately on samples, conditions, modalities, etc.\n\n# Run the standard workflow for visualization\nfiltered.rna &lt;- RunUMAP(filtered.rna, dims = 1:15)\n\nDimPlot(filtered.rna, group.by = \"Sample_Name\")\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nJudging on the UMAP, do the two samples need to be integrated?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe same cell types from the two samples are not aligned. We can perform integration.\n\n\n\n2. Perform integration\nFirst, we select the features for the integration. The features should be selected in each dataset.\n\n# split the dataset into a list of two seurat objects (activated and naive)\nsplit.filtered.rna &lt;- SplitObject(filtered.rna, split.by = \"Sample_Name\")\n\n# normalize and identify variable features for each dataset independently\nsplit.filtered.rna &lt;- lapply(X = split.filtered.rna, FUN = function(x) {\n    x &lt;- NormalizeData(x)\n    x &lt;- FindVariableFeatures(x, selection.method = \"vst\", nfeatures = 2000)\n})\n\n# Select the most variable features to use for integration\ninteg.features &lt;- SelectIntegrationFeatures(object.list = split.filtered.rna, \n                                            nfeatures = 2000) \n\nNext, we perform the integration across samples. This step can take a while to run.\n\nanchors &lt;- FindIntegrationAnchors(object.list = split.filtered.rna,\n                                  anchor.features = integ.features)\n\nFinally, we can integrate across samples. By default, normalization.method is set to LogNormalize.\n\nintegrate.filtered.rna &lt;- IntegrateData(anchorset = anchors)\n\n3. Visualize in UMAP\nAfter integration, we look at the integrated data with UMAP. To calculate UMAP, we need to first calculate PCA and select top PCs.\nMethods to select top PCs were used a lot more often when the data was normalized with LogNormalize.\n\nintegrate.filtered.rna &lt;- ScaleData(integrate.filtered.rna, verbose = FALSE)\nintegrate.filtered.rna &lt;- RunPCA(integrate.filtered.rna, npcs = 30, verbose = FALSE)\n\nElbow plot can help to select top PCs. The PC number where the elbow is is used to calculate UMAP.\n\nElbowPlot(integrate.filtered.rna)\n\n\n\n\n\nintegrate.filtered.rna &lt;- RunUMAP(integrate.filtered.rna, \n                                        reduction = \"pca\", \n                                        dims = 1:10)\n\nintegrate.filtered.rna &lt;- FindNeighbors(integrate.filtered.rna, \n                                              reduction = \"pca\", \n                                              dims = 1:10)\n\n\n# Plot UMAP                             \nDimPlot(integrate.filtered.rna, group.by = \"Sample_Name\")   \n\n\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nChange the number of PCs and see how the UMAP changes.\nYou can change the PC numbers by dims argument in RunUMAP.\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nDimplot has many arguments to control the plots.\n\nSearch Dimplot in the “Help” section and read the documentation.\nChange group.by to split.by. What is the difference?\n\n\n\nWhen we compare the similarity between the naive and activated clusters in the below plot with what we see using the integrated dataset, it is clear that this dataset benefited from the integration.\n\np1 &lt;- DimPlot(filtered.rna, group.by = \"Sample_Name\") + NoLegend()\np2 &lt;- DimPlot(integrate.filtered.rna, group.by = \"Sample_Name\")  + NoLegend()\n\np1|p2\n\n\n\n\n4. Save\nSave the files into RData for documentation.\n\n# save(integrate.filtered.rna, expMat, file = \"data/intermediate_data/chapter4.RData\")"
  },
  {
    "objectID": "09_combining.html",
    "href": "09_combining.html",
    "title": "Chapter 9 Combine scRNAseq and AbSeq",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\n\nLoad RData\nLoad the RData which contain all files from previous chapter.\n\nload(\"data/intermediate_data/chapter8.RData\")\n\nWhen the experiment has RNA profiling (scRNA) and protein profiling (AbSeq) in single cell resolution, each measurement is one modality. The combined analysis of scRNA and AbSeq is so called “multimodal analysis”.\nSeurat package also provides the framework to analyze multimodal data. The framework is the the weighted nearest neighbors (WNN) approach, which enables simultaneous clustering of cells based on weighted combination of both modalities.\n\n\n\n\n\n\nNote\n\n\n\nRNA profiling and protein profiling should be analyzed separately before combing for downstream analysis.\n\n\n1. Processing AbSeq\nWhen we analyzed the scRNAseq, the dataset was filtered and only high quality cells are kept. AbSeq dataset is filtered to have the same cells in.\n\n# get AbSeq from expMat\nab &lt;- expMat$`Antibody Capture`\n\n# filter abseq data based on cell id from rna seurat object\nab &lt;- ab[, colnames(integrate.filtered.rna)]\n\nCreating a new Seurat object with AbSeq.\n\n# create a new assay to store AbSeq information\nab &lt;- CreateAssayObject(counts = ab)\n\n# create a new Seurat object to store the combined analysis\ncombined &lt;- integrate.filtered.rna\ncombined[[\"AB\"]] &lt;- ab\n\n# Validate that the object now contains multiple assays\ncombined\n\nAn object of class Seurat \n40809 features across 4160 samples within 7 assays \nActive assay: RNA (19347 features, 0 variable features)\n 6 other assays present: integrated, refAssay, prediction.score.celltype.l1, prediction.score.celltype.l2, prediction.score.celltype.l3, AB\n 4 dimensional reductions calculated: pca, umap, integrated_dr, ref.umap\n\n\nNext, we split the Seurat object by sample to normalize them separately.\nThe recommended normalization method for AbSeq is CLR, Centered Log Ratio. Due to the unspecific binding background signal of antibody, log-normalization doesn’t work well in AbSeq data.\nThere are 20 AbSeq in the experiment. We are going to use all of them as variable features.\n\n# switch the default assay to AbSeq\nDefaultAssay(combined) &lt;- 'AB'\n\n# set variable features\nVariableFeatures(combined) &lt;- rownames(combined[[\"AB\"]])\n\n# set a name for the dimentionality reduction to avoid overwriting\ncombined &lt;- NormalizeData(combined, normalization.method = 'CLR', margin = 2) %&gt;% \n  ScaleData() %&gt;% \n  RunPCA(reduction.name = 'apca', approx = F)\n\n2. Weighted nearest neighbour (WNN)\nThe weighted nearest neighbor (WNN) is a statistical framework implemented in Seurat for the multimodal analysis. WNN requires pre-processing and dimentionality reduction on both assays independently.\n\ncombined &lt;- FindMultiModalNeighbors(combined, \n                                    reduction.list = list(\"pca\", \"apca\"), \n                                    dims.list = list(1:15, 1:18), \n                                    modality.weight.name = \"RNA.weight\")\n\nreduction.list Dimentionality reduction to use from each element\ndims.list Number of PCs to include from each element\nmodality.weight.name Give a name to the weight of each element\nNow, we run UMP using the calculated WNN.\nFor each cell, we calculate its closest neighbors in the dataset based on a weighted combination of RNA and protein similarities. We specify the dimensionality of each modality (similar to specifying the number of PCs to include in scRNA-seq clustering). We use the same number of PCs as we did in previous steps.\n\n# run UMAP\ncombined &lt;- RunUMAP(combined, \n                    nn.name = \"weighted.nn\", \n                    reduction.name = \"wnn.umap\", \n                    reduction.key = \"wnnUMAP_\")\n\n# find clusters\ncombined &lt;- FindClusters(combined, \n                         graph.name = \"wsnn\", \n                         resolution = 0.4, \n                         verbose = FALSE)\n\nLook at the results in UMAP.\n\n# visualize the result in UMAP\np1 &lt;- DimPlot(combined, reduction = 'wnn.umap', label = TRUE, repel = TRUE, label.size = 2.5, group.by = \"predicted.celltype.l1\")\n\np2 &lt;- DimPlot(combined, reduction = 'wnn.umap', label = TRUE, repel = TRUE, label.size = 2.5)\n\np1|p2\n\n\n\n\nLet’s compare the UMAPs from RNA only and from WNN. The T cells cluster better in WNN UMAP. Becuase AbSeq is often handpicked and cell type specific, bringing AbSeq in can have a better resolution.\n\n# compare the UMAPs based on RNA and on WNN\np1 &lt;- DimPlot(combined, reduction = 'umap', group.by = 'predicted.celltype.l1', label = TRUE, repel = TRUE, label.size = 2.5) + NoLegend() + ggtitle(\"RNA\")\n\np2 &lt;- DimPlot(combined, reduction = 'wnn.umap', group.by = 'predicted.celltype.l1', label = TRUE, repel = TRUE, label.size = 2.5) + NoLegend() + ggtitle(\"WNN\")\n\np1|p2\n\n\n\n\n3. AbSeq visualization\nWe have several assays stored in the Seurat object. We can easily switch between them and work on different assays.\n\n\n\n\n\n\nNote\n\n\n\nIt is important to know which assay you are working on. We may get unexpected results if working on the wrong assay.\n\n\n\ncombined\n\nAn object of class Seurat \n40809 features across 4160 samples within 7 assays \nActive assay: AB (20 features, 20 variable features)\n 6 other assays present: RNA, integrated, refAssay, prediction.score.celltype.l1, prediction.score.celltype.l2, prediction.score.celltype.l3\n 6 dimensional reductions calculated: pca, umap, integrated_dr, ref.umap, apca, wnn.umap\n\n\nLet’s look at the protein and gene expression side by side. By setting the default assay, we can visualize one or the other.\nCD19 is a B cell marker. We can plot the UMAP with annotation side by side with the CD19 AbSeq.\n\n# switch default assay to AbSeq to plot protein expression\nDefaultAssay(combined) &lt;- \"AB\"\np1 &lt;- FeaturePlot(combined, \"CD19-CD19-AHS0030-pAbO\", cols = c(\"lightgrey\", \"darkgreen\"), reduction = 'wnn.umap')\n\n# switch default to RNA to plot gene expression\nDefaultAssay(combined) &lt;- \"RNA\"\np2 &lt;- FeaturePlot(combined, \"CD19\", reduction = 'wnn.umap')\n\n# place plots side-by-side\np1 | p2\n\n\n\n\n4. Save\nSave the files into RData for documentation.\n\n# save(combined, expMat, ab, integrate.filtered.rna, file = \"data/intermediate_data/chapter9.RData\")"
  },
  {
    "objectID": "05_clustering.html",
    "href": "05_clustering.html",
    "title": "Chapter 5 Clustering",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\n\nLoad RData\nLoad the RData which contain all files from previous chapter.\n\nload(\"data/intermediate_data/chapter4.RData\")\n\n1. Clustering cells\nNow that we have our high quality cells integrated, we want to know the different cell types present within our population of cells.\nSeurat uses a graph-based clustering approach, which embeds cells in a graph structure, using a K-nearest neighbor (KNN) graph (by default), with edges drawn between cells with similar gene expression patterns. Then, it attempts to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.\nWe will use the FindClusters function to perform the graph-based clustering. The `resolution` is an important argument that sets the “granularity” of the downstream clustering and will need to be optimized for every individual experiment.\n\n\n\n\n\n\nNote\n\n\n\nIncreased resolution values lead to a greater number of clusters, which is often required for larger datasets.\n\n\nThe FindClusters function allows us to enter a series of resolutions and will calculate the “granularity” of the clustering. This is very helpful for testing which resolution works for moving forward without having to run the function for each resolution.\n\n# Determine the K-nearest neighbor graph\nintegrate.filtered.rna &lt;- FindNeighbors(object = integrate.filtered.rna, dims = 1:10)\n                                \n# Determine the clusters for various resolutions                                \nintegrate.filtered.rna &lt;- FindClusters(object = integrate.filtered.rna,\n                               resolution = c(0.2, 0.4, 0.6,  0.8, 1, 1.2, 1.4), verbose = F)\n\nThe meta.data has a separate column for each of the different resolution calculated. We can look at how many clusters in each resolution.\n\nintegrate.filtered.rna@meta.data %&gt;% \n  dplyr::select(contains(\"integrat\")) %&gt;% \n  map_int(~ unique(.x) %&gt;% length)\n\nintegrated_snn_res.0.2 integrated_snn_res.0.4 integrated_snn_res.0.6 \n                     9                     11                     13 \nintegrated_snn_res.0.8   integrated_snn_res.1 integrated_snn_res.1.2 \n                    15                     16                     17 \nintegrated_snn_res.1.4 \n                    19 \n\n\nWe start with the resolution of 0.6. We will assign the identity of the clusters using the Idents function.\n\nIdents(object = integrate.filtered.rna) &lt;- \"integrated_snn_res.0.6\"\n\n# UMAP visualization\nDimPlot(integrate.filtered.rna,\n        reduction = \"umap\",\n        label = TRUE,\n        label.size = 6)\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nChange the other resolutions. How do the clusters change?\n\n\n2. Distribution of cells per cluster\nThe number of clusters are sensitive to the resolution. We have PBMC from both samples, and we expect each cluster contains cells from both samples.\n\nFetchData(integrate.filtered.rna, \n                     vars = c(\"ident\", \"Sample_Name\")) %&gt;%\n  dplyr::count(ident, Sample_Name) %&gt;%\n  tidyr::spread(ident, n)\n\n  Sample_Name   0   1   2   3   4   5   6   7  8  9 10 11 12\n1       naive 355 243 428 226   8   5 281  70 96 62 13 35 28\n2     treated 508 332 140 217 322 304  14 177 53 71 82 59 31\n\n\n\n# UMAP of cells in each cluster by sample\nDimPlot(integrate.filtered.rna, \n        label = TRUE, \n        split.by = \"Sample_Name\")  + NoLegend()\n\n\n\n\n3. Exploring known cell type markers\nWe can explore some known cell type markers to get an idea about the identity of clusters.\nCell Type Markers:\nCD14+ monocytes: CD14, LYZ\nConventional dendritic cells: FCER1A, CST3\nB cells: CD79A, MS4A1\nT cells: CD3D\nCD4+ T cells: CD3D, IL7R, CCR7\nCD8+ T cells: CD3D, CD8A\nNK cells: GNLY, NKG7\nMacrophages: MARCO, ITGAM, ADGRE1\nThe FeaturePlot makes it easy to visualize a handful of genes using the gene IDs stored in the Seurat object. We can easily explore the expression of known gene markers on top of our UMAP visualizations. Let’s go through and determine the identities of the clusters. To access the normalized expression levels of all genes, we can use the normalized count stored in the RNA assay slot.\n\nDefaultAssay(integrate.filtered.rna) &lt;- \"RNA\"\n\nCD14+ monocytes: CD14, LYZ\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD14\", \"LYZ\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nB cells: CD79A, MS4A1\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD79A\", \"MS4A1\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nNK cells: GNLY, NKG7\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"GNLY\", \"NKG7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nT cells: CD3D\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nCD4+ T cells: CD3D, IL7R, CCR7\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"IL7R\", \"CCR7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nCD8+ T cells: CD3D, CD8A\n\nFeaturePlot(integrate.filtered.rna, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"CD8A\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n4. Save\nSave the files into RData for documentation.\n\n# save(integrate.filtered.rna, expMat, file = \"data/intermediate_data/chapter5.RData\")"
  },
  {
    "objectID": "06_marker_identification.html",
    "href": "06_marker_identification.html",
    "title": "Chapter 6 Marker Identification",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\nlibrary(cellpypes)"
  },
  {
    "objectID": "06_marker_identification.html#findallmarkers",
    "href": "06_marker_identification.html#findallmarkers",
    "title": "Chapter 6 Marker Identification",
    "section": "1.1 FindAllMarkers",
    "text": "1.1 FindAllMarkers\nThis type of analysis is typically for evaluating a single sample group/condition. With the FindAllMarkers function we are comparing each cluster against all other clusters to identify potential marker genes. The cells in each cluster are treated as replicates, and essentially a differential expression analysis is performed with some statistical test. By default, the test is Wilcoxon Rank Sum test.\nThe FindAllMarkers function has three arguments to determine if a gene is a marker gene.\nlogfc.threshold Limit testing to genes that show, on average, at least an X-fold difference (log-scale) between the two groups of cells. The default is 0.25. Increasing logfc.threshold speeds up the function but can miss weaker signals.\nmin.pct Only test genes that are detected in a minimum fraction of min.pct cells in either of the two populations. It is meant to speed up the function by not testing infrequently expressed genes. The default is 0.1.\nonly.pos Only return positive markers (FALSE by default)\nWe can combine these arguments. We can change the arguments depending on how stringent we want to be. Here we will use the default settings.\nWe look at the marker genes in the clusters in sample “activated”.\n\ntreated.markers &lt;- FindAllMarkers(subset(integrate.filtered.rna, subset = Sample_Name == \"treated\"), \n                                    assay = \"RNA\",\n                                    only.pos = TRUE, \n                                    min.pct = 0.25, \n                                    logfc.threshold = 0.25)\n\nLet’s look at the top 2 significant marker genes in each cluster.\n\ntreated.markers %&gt;%\n    group_by(cluster) %&gt;%\n    slice_max(n = 2, order_by = avg_log2FC)\n\n# A tibble: 26 × 7\n# Groups:   cluster [13]\n       p_val avg_log2FC pct.1 pct.2 p_val_adj cluster gene      \n       &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;   &lt;chr&gt;     \n 1 9.89e-158       2.63 0.744 0.212 1.91e-153 0       MAL       \n 2 3.62e-104       2.10 0.734 0.379 7.01e-100 0       PCED1B-AS1\n 3 0               5.06 0.961 0.055 0         1       GNLY      \n 4 3.65e-259       4.13 0.892 0.108 7.07e-255 1       CCL5      \n 5 5.52e- 12       1.07 0.75  0.515 1.07e-  7 2       HSPD1     \n 6 6.86e- 17       1.00 0.957 0.787 1.33e- 12 2       NPM1      \n 7 5.53e- 82       2.41 0.594 0.119 1.07e- 77 3       RGS1      \n 8 5.81e- 25       1.82 0.304 0.09  1.12e- 20 3       FOXP3     \n 9 1.24e-122       2.25 0.916 0.276 2.39e-118 4       LTA       \n10 1.65e-159       1.97 0.941 0.225 3.20e-155 4       MIR155HG  \n# ℹ 16 more rows\n\n\nWe get a table with the information on marker genes.\np_val p-value before multiple testing.\navg_log2FC log2 fold change on the average of gene expression between one cluster and the rest of cluster combined.\npct.1 Percentage of cells express the gene in one group. Here is one cluster.\npct.2 Percentage of cells express the gene in another group. Here is the rest of cluster combined.\np_val_adj p-value with multiple testing correction."
  },
  {
    "objectID": "06_marker_identification.html#findconservedmarkers",
    "href": "06_marker_identification.html#findconservedmarkers",
    "title": "Chapter 6 Marker Identification",
    "section": "1.2 FindConservedMarkers",
    "text": "1.2 FindConservedMarkers\nWe have two samples, naïve and treated. We can find conserved markers between the conditions with the function, FindConservedMarkers.\nThis function internally separates out cells by sample group/condition, then performs differential gene expression testing for a single specified cluster against all other clusters (or a second cluster, if specified).\nGene-level p-values are computed for each condition and then combined across groups using meta-analysis methods from the MetaDE R package.\nMany of the arguments in FindConservedMarkers are shared with FindAllMarkers. Here, we list some additional arguments when using FindConservedMarkers:\nident.1 This function only evaluates one cluster at a time; here, you would specify the cluster of interest. grouping.var The variable (column header) in your metadata specifies the separation of cells into groups.\n\nfcm &lt;- FindConservedMarkers(integrate.filtered.rna,\n                     assay = \"RNA\",\n                     ident.1 = \"1\",\n                     grouping.var = \"Sample_Name\",\n                     only.pos = TRUE,\n                     min.diff.pct = 0.25,\n                     min.pct = 0.25,\n                     logfc.threshold = 0.25)\n\nhead(fcm)\n\n       naive_p_val naive_avg_log2FC naive_pct.1 naive_pct.2 naive_p_val_adj\nGNLY  0.000000e+00         4.823298       0.947       0.024    0.000000e+00\nGZMA 8.973490e-245         3.778985       0.835       0.041   1.736101e-240\nPRF1 1.103550e-125         2.671046       0.453       0.021   2.135038e-121\nNKG7 1.504853e-212         3.572770       0.823       0.060   2.911439e-208\nCCL5 9.363098e-161         3.319940       0.852       0.120   1.811479e-156\nCST7 5.390018e-149         3.014122       0.634       0.053   1.042807e-144\n     treated_p_val treated_avg_log2FC treated_pct.1 treated_pct.2\nGNLY  0.000000e+00           5.060457         0.961         0.055\nGZMA  0.000000e+00           3.813904         0.976         0.082\nPRF1  0.000000e+00           3.855625         0.907         0.068\nNKG7 8.396253e-261           3.398566         0.982         0.150\nCCL5 3.653151e-259           4.133251         0.892         0.108\nCST7 6.882951e-236           3.135928         0.759         0.068\n     treated_p_val_adj      max_pval minimump_p_val\nGNLY      0.000000e+00  0.000000e+00   0.000000e+00\nGZMA      0.000000e+00 8.973490e-245   0.000000e+00\nPRF1      0.000000e+00 1.103550e-125   0.000000e+00\nNKG7     1.624423e-256 1.504853e-212  1.679251e-260\nCCL5     7.067750e-255 9.363098e-161  7.306301e-259\nCST7     1.331645e-231 5.390018e-149  1.376590e-235\n\n\nWe also get a table with information on marker genes. The statistics are computed for each group (naïve vs. treated), and the last two columns are the combined p-value across the two groups.\ncondition_p_val p-value before multiple testing.\ncondition_avg_log2FC log2 fold change on the average of gene expression between one cluster and the rest of the clusters combined.\ncondition_pct.1 Percentage of cells expressing the gene in one group.\ncondition_pct.2 Percentage of cells expressing the gene in another group.\ncondition_p_val_adj p-value with multiple testing correction.\n\n\n\n\n\n\nNote\n\n\n\nThe more significant the difference between pct.1 and pct.2, the higher the confidence for the marker gene. If pct.1 is 0.9 and pct.2 is 0.8, it is not as interesting as if pct.2 is 0.1.\nMarker genes express in a specific cell type. If pct.1 is low, such as 0.3, it is not as interesting as if it is 0.9.\n\n\nWe can visualize the marker gene expression by FeaturePlot and VlnPlot.\n\nFeaturePlot(object = integrate.filtered.rna, \n            features = c(\"GNLY\", \"GZMA\"),\n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE,\n            repel = TRUE)\n\n\n\n\n\nVlnPlot(object = integrate.filtered.rna, \n        features = c(\"GNLY\", \"GZMA\"))"
  },
  {
    "objectID": "06_marker_identification.html#findmarkers",
    "href": "06_marker_identification.html#findmarkers",
    "title": "Chapter 6 Marker Identification",
    "section": "1.3 FindMarkers",
    "text": "1.3 FindMarkers\nWe can use the FindMarkers to determine the differentially expressed genes between two clusters.\n\nexample_findmarkers &lt;- FindMarkers(integrate.filtered.rna,\n                          assay = \"RNA\",\n                          ident.1 = 1,\n                          ident.2 = 2) %&gt;% \n  rownames_to_column(\"gene\")"
  },
  {
    "objectID": "06_marker_identification.html#reference-based",
    "href": "06_marker_identification.html#reference-based",
    "title": "Chapter 6 Marker Identification",
    "section": "2.1 Reference-based",
    "text": "2.1 Reference-based\nWe look at the publicly available dataset with annotation and build a reference set based on its information. Then we can “transfer” the annotation from the reference to the query. Seurat provides the interface to connect with Azimuth.\n\n\n\n\n\n\nNote\n\n\n\nBecause the annotation information is based on the reference set, the reference ideally are similar to the query. They may come from the same tissue, same organism, similar experimental procedure, etc.\n\n\n\nintegrate.filtered.rna &lt;- Azimuth::RunAzimuth(integrate.filtered.rna, reference = \"pbmcref\", verbose = F)\n\nAn AzimuthData object - reference version: 1.0.0 \nContains 3 meta.data field(s) to transfer.\n\n\nWe can look at the prediction on UMAP.\n\np1 &lt;- DimPlot(integrate.filtered.rna, reduction = \"umap\", group.by = \"predicted.celltype.l1\", label = TRUE, label.size = 3 ,repel = TRUE) + NoLegend()\n\np2 &lt;- DimPlot(integrate.filtered.rna, reduction = \"umap\", group.by = \"integrated_snn_res.0.6\", label = TRUE, label.size = 3 ,repel = TRUE) + NoLegend()\n\np1|p2"
  },
  {
    "objectID": "06_marker_identification.html#marker-based",
    "href": "06_marker_identification.html#marker-based",
    "title": "Chapter 6 Marker Identification",
    "section": "2.1 Marker-based",
    "text": "2.1 Marker-based\nThe celldex contains several curated reference datasets, mostly assembled from bulk RNA-seq or microarray data of sorted cell types. Here, we will use a reference constructed from Blueprint and ENCODE data (Martens and Stunnenberg 2013; The ENCODE Project Consortium 2012).\n\n# get reference\n# ref_encode &lt;- BlueprintEncodeData()\nref_encode &lt;- readRDS(\"data/blueprint_encode_ref.rds\")\n\n# perform annotation\nannot_encode &lt;- SingleR(test = as.SingleCellExperiment(integrate.filtered.rna), ref = ref_encode, labels = ref_encode$label.main)\n\n# get labels into Seurat object\nintegrate.filtered.rna$annot_encode &lt;- annot_encode$labels\n\n# Visualizae\nDimPlot(integrate.filtered.rna, group.by = \"annot_encode\", label = T, reduction = \"umap\")"
  },
  {
    "objectID": "07_differential_expression_analysis.html",
    "href": "07_differential_expression_analysis.html",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\nlibrary(muscat)"
  },
  {
    "objectID": "07_differential_expression_analysis.html#setup",
    "href": "07_differential_expression_analysis.html#setup",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.1 Setup",
    "text": "2.1 Setup\nLet’s assume we have three biological replicates in each condition (we made them up for illustration).\n\n# read in dummy group\ndummy &lt;- read_csv(\"data/dummy.csv\")\n\n# add the dummy meta into the seurat object\nintegrate.filtered.rna &lt;- AddMetaData(integrate.filtered.rna, dummy$dummy_group, col.name = \"dummy_group\")"
  },
  {
    "objectID": "07_differential_expression_analysis.html#select-cell-groups",
    "href": "07_differential_expression_analysis.html#select-cell-groups",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.2 Select cell groups",
    "text": "2.2 Select cell groups\nLet’s take a look at the cell type annotation in UMAP.\n\n# visualize cell types in UMAP\nDimPlot(integrate.filtered.rna, \n        reduction = \"umap\", \n        group.by = \"predicted.celltype.l1\", \n        label = TRUE, \n        label.size = 3,\n        repel = TRUE, \n        split.by = \"Sample_Name\") + NoLegend()\n\n\n\n\nWe see some of the cell types have only a few cells.\nLet’s look at how many cells are in each cell type per dummy group.\n\n# Cell counts in per cell type per group\nFetchData(integrate.filtered.rna, \n                     vars = c(\"predicted.celltype.l1\", \"dummy_group\", \"Sample_Name\")) %&gt;%\n  dplyr::count(predicted.celltype.l1, Sample_Name, dummy_group) %&gt;%\n  tidyr::spread(predicted.celltype.l1, n)\n\n  Sample_Name dummy_group  B CD4 T CD8 T DC Mono  NK other other T\n1       naive     naive_1 22   309    65  3  127  68    19      14\n2       naive     naive_2 22   302    54  5  118  75    17       3\n3       naive     naive_3 24   311    58  4  113  93    12      12\n4     treated   treated_1 61   501    34 NA   36 137    15       1\n5     treated   treated_2 61   478    21 NA   35 123    21       2\n6     treated   treated_3 57   502    27 NA   36 137    22       3\n\n\nDendritic cells, other T cells, and other don’t have sufficient cells per dummy group. For demonstration, we will not include these cells for pseudo-bulk analysis. We will focus on “CD4 T”, “Mono”, and “NK”.\n\nsubset.rna &lt;- subset(integrate.filtered.rna, \n                     subset = predicted.celltype.l1 %in% \n                       c(\"CD4 T\", \"Mono\", \"NK\"))"
  },
  {
    "objectID": "07_differential_expression_analysis.html#setup-singlecellexperiment",
    "href": "07_differential_expression_analysis.html#setup-singlecellexperiment",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.3 Setup SingleCellExperiment\n",
    "text": "2.3 Setup SingleCellExperiment\n\nThe muscat package requires the input object as the SingleCellExperiment object. We first transform the Seurat object into SCE object.\nmuscat requires three pieces of meta data information: sample_id sample IDs, corresponds to dummy_group in the meta.data cluster_id cell types, corresponds to predicted.celltype.l1 in the meta.data group_id sample groups, corresponds to sample in the meta.data\nLet’s first tidy up the meta data.\n\nsubset.rna@meta.data &lt;- subset.rna@meta.data %&gt;% \n  dplyr::select(Sample_Name, predicted.celltype.l1, dummy_group) %&gt;% \n  `colnames&lt;-`(c(\"group_id\", \"cluster_id\", \"sample_id\"))\n\nSeurat has a convenient function to convert Seurat object into SingleCellExperiment object, as.SingleCellExperiment.\n\n# construct experiment_info\nexperiment_info &lt;- subset.rna@meta.data %&gt;% \n  group_by(sample_id, group_id) %&gt;% \n  dplyr::summarise(n_cells = length(group_id))\n\n# convert seurat object into SingleCellExperiment object\nsubset.rna &lt;- as.SingleCellExperiment(subset.rna, assay = \"RNA\")\n\nThe SCE object doesn’t contain the experiment_info. We add the information into the SCE object.\n\n# assign experiment info into the created SingleCellExperiment\nsubset.rna@metadata[[\"experiment_info\"]] &lt;- experiment_info"
  },
  {
    "objectID": "07_differential_expression_analysis.html#aggregation",
    "href": "07_differential_expression_analysis.html#aggregation",
    "title": "Chapter 7 Differential Expression Analysis",
    "section": "2.4 Aggregation",
    "text": "2.4 Aggregation\nWe first aggregate measurements for each sample (in each cell type) to obtain pseudobulk data.\n\n# aggregate counts per cell type per dummy group\nsubset.pb &lt;- aggregateData(subset.rna,\n                           assay = \"counts\", \n                           fun = \"sum\",\n                           by = c(\"cluster_id\", \"sample_id\"))\n\nWe can look at how the pseudobulk samples cluster on the MDS plot.\n\nmuscat::pbMDS(subset.pb)\n\n\n\n\nNext, we can run DS analysis by specifying method as DESeq2.\n\n# change group_id into a factor\nsubset.pb$group_id &lt;- subset.pb$group_id %&gt;% as.factor()\n\n# run DS analysis with DESeq2\nres &lt;- pbDS(subset.pb, method = \"DESeq2\", verbose = F)\n\nThe result is stored in the table slot of res.\nWe will focus on the deferentially expressed genes in CD4 T cells.\n\ncd4t &lt;- res$table$treated$`CD4 T`\n\n# Filter the results with p_adj.loc &lt; 0.05, abs(logFC) &gt; 1\ncd4t.sig &lt;- dplyr::filter(cd4t, p_adj.loc &lt; 0.05, abs(logFC) &gt; 1) %&gt;% \n  arrange(p_adj.loc)\n\np_adj.loc is produced by correcting for multiple testing across all genes tested within a cluster. p_adj.glb is produced by correcting for multiple testing across all genes tested in all clusters.\nWe can plot the DEGs from CD4+ T cells in a heatmap.\n\n# scale the RNA data\nintegrate.filtered.rna &lt;- ScaleData(integrate.filtered.rna, features = rownames(integrate.filtered.rna), assay = \"RNA\")\n\n# plot heatmap\nintegrate.filtered.rna %&gt;%\n  subset(., subset = predicted.celltype.l1 == \"CD4 T\") %&gt;% \n  DoHeatmap(features = cd4t.sig$gene[1:40])"
  },
  {
    "objectID": "08_enrichment_analysis.html",
    "href": "08_enrichment_analysis.html",
    "title": "Chapter 8 Enrichment Analysis",
    "section": "",
    "text": "# libraries for this chapter\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(data.table)\nlibrary(celldex)\nlibrary(SingleR)\nlibrary(ExperimentHub)\nlibrary(org.Hs.eg.db)\nlibrary(clusterProfiler)\nlibrary(AnnotationDbi)\nlibrary(enrichplot)\nlibrary(biomaRt)\n\nLoad RData\nLoad the RData which contain all files from previous chapter.\n\nload(\"data/intermediate_data/chapter7.RData\")\n\nOftentimes, enrichment analysis takes in the differentially expressed genes and looks at which gene ontology (GO) terms are enriched.\nGO terms defines concepts/classes used to describe gene function and relationships between these concepts. clusterProfiler is an R package implementing many methods to analyze and visualize functional profiles from a group of features. It classifies functions along three aspects.\nMF: Molecular Function: molecular activities of gene products\nCC: Cellular Component: where gene products are active\nBP: Biological Process: pathways and larger processes made up of the activities of multiple gene products\nThis chapter uses the differentially expressed genes in CD4+ T cells from last chapter as an example.\n1. Get Entrez ID\nclusterProfiler prefers the input of Entrez ID. We use biomaRt package to convert the gene symbol into Entrez ID.\n\n\n\n\n\n\nNote\n\n\n\nbiomaRt is handy for getting information about a group of features. You can use it to get gene symbols, genomic coordinates, transcripts, etc. You can explore what data is stored in biomaRt with listAttributes.\n\n\nThe differentially expressed genes in CD4+ T cells between naïve and activated PBMCs are stored in cd4t. The gene symbol in this list can be converted into Entrez ID by biomaRt.\nFirstly, connect to the Ensembl database and specify we want to retrieve information from the dataset of Homo Sapien.\n\nmart &lt;- useMart(biomart = \"ensembl\", dataset = \"hsapiens_gene_ensembl\")\n\nbiomart BioMart database connect to. Here, we want to connect to ensembl database.\ndataset Dataset to use. Here specify hsapiens_gene_ensembl.\nNext, we can give a list of gene symbols and retrieve the Entrez ID through getBM.\n\nresults &lt;- getBM(attributes = c(\"entrezgene_id\", \"external_gene_name\"),\n                 filters = \"external_gene_name\", values = cd4t$gene,\n                 mart = mart)\n\nattributes Attributes to retrieve. We want to have the gene symbols and Entrez ID in the results.\nfilters Which filter to use to filter the dataset.\nvalues A list of features as a query.\nmart Object of class Mart, created with the useMart function.\nA table of two columns is created and stored in results.\n\nhead(results)\n\n  entrezgene_id external_gene_name\n1         81532               MOB2\n2         79602            ADIPOR2\n3        196513              DCP1B\n4         55449          DHRS4-AS1\n5         80344             DCAF11\n6         51016               EMC9\n\n\nNot every gene has the Entrez ID. We keep only genes that have a matched Entrez ID.\n\ncd4t &lt;- left_join(cd4t, results, by = c(\"gene\" = \"external_gene_name\")) %&gt;% \n  filter(!is.na(entrezgene_id))\n\n2. GO over-representation analysis\nOver Representation Analysis (ORA) is a widely used approach to determine whether known biological functions or processes are over-represented (= enriched) in an experimentally-derived gene list, e.g. a list of differentially expressed genes (DEGs).\nWe use the enrichGO to get the enriched GO terms in the list of features.\n\ncd4t.sig &lt;- dplyr::filter(cd4t, p_adj.loc &lt; 0.05, logFC &gt; 1) %&gt;% \n  arrange(p_adj.loc)\n\n# get the enriched GO terms\nego &lt;- enrichGO(gene = cd4t.sig$entrezgene_id,\n                keyType = \"ENTREZID\",\n                OrgDb = org.Hs.eg.db,\n                ont = \"BP\",\n                pAdjustMethod = \"BH\",\n                pvalueCutoff = 0.01,\n                qvalueCutoff = 0.05,\n                readable = TRUE)\n\ngene A list of Entrez gene id.\nkeyType The keytype of input gene.\nOrgDb The database with detailed information about the species.\norg.Hs.eg.db Specify the database of Homo Sapien.\nont One of “BP” (biological process), “MF” (molecular function), and “CC” (cellular component) subontologies, or “ALL” for all three.\npAdjustMethod Multiple testing method for p-value.\npvalueCutoff Adjusted pvalue cutoff on enrichment tests to report.\nqvalueCutoff Tge qvalue cutoff on enrichment tests to report as significant.\nreadable Whether mapping gene ID to gene Name.\nLet’s convert the ego object into a data frame and visualize the results in a bar plot.\n\nego.table &lt;- as.data.frame(ego)\n\nGeneRatio The gene counts from the input list found in the gene set of a GO term / gene counts of input list.\nBgRatio The gene counts of a geneset / size of all of the unique genes in the collection of genesets.\n\nbarplot(ego, showCategory = 18)\n\n\n\n\n3. GSEA\nAll genes can be used as input of GSEA (Gene set enrichment analysis). We first rank the genes based on stat.\n\n# order genes based on stat\ncd4t &lt;- cd4t[order(-cd4t$stat), ]\n\ngene_list &lt;- cd4t$stat\nnames(gene_list) &lt;- cd4t$entrezgene_id\n\nWe use gseGO to perform GSEA and convert the results into a dataframe.\n\n# perform GSEA\ngse &lt;- gseGO(gene_list,\n             keyType = \"ENTREZID\",\n             ont = \"BP\",\n             OrgDb = \"org.Hs.eg.db\")\n\n# convert the results into a dataframe\ngse.table &lt;- as.data.frame(gse) %&gt;% \n  mutate(geneSetID = 1:dim(.)[1])\n\nenrichmentScore The enrichment score (ES) represents the degree to which a set S is over-represented at the top or bottom of the ranked list L.\nWe can look at the enrichment of some GO terms in GSEA plot.\n\ngseaplot2(gse, geneSetID = c(158, 163))\n\n\n\n\nWe have significant enriched term in the unregulated genes. Along the x axis is the ranked genes. Each of the vertical line is one of those genes that are found in this gene set. Along the running line, you can see a lot of genes running together and it falls out when the gene becomes more sparse in the list.\n4. Save\nSave the files into RData for documentation.\n\n# save(integrate.filtered.rna, expMat, cd4t, ego.table, gse.table, file = \"data/intermediate_data/chapter8.RData\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "How to use the materials?\nThis repository contains the materials for the Single Cell Boot Camp.\nIt has two chapters of precourse preparation and nine chapters of the course.\nFor those who are new to R, please review Precourse Preparation - R. If you are familiar with the functions listed in this chapter, you can skip it.\nFor all participants, please review Precourse Preparation - Theory.\nFor chapters 1 to 9, we will go through it together in the course. Welcome to review them before the course if you have time (The learning outcome is much better if you go through the materials before attending the course from feedback of our previous students).\n\n\nNext occurrence\nSept 19 - 20, 2023 | 10 am - 2:30 ~ 3:00 pm | Online\n\n\nDescription\nThe Single Cell Boot Camp: Analysis of scRNA-seq with R is to provide an overview of the analysis of single-cell RNA-seq using R. It is designed for early-stage researchers who want to adopt single-cell analysis in their toolbox. The workshop consists of theory in presentation and application in hands-on practice.\nThe workshop starts with a fast-paced training session on the common workflow of single-cell RNA-seq analysis, then continues with sessions on the common workflow of scRNA-seq using bioinformatics packages like Seurat.\n\n\nPrerequisites\nEach participant are expected to have:\n1. An introductory background in statistics, specifically in the below concepts: Median, log2 fold change, p-value, adjusted p-value, variance, PCA.\n2. Basic familiarity with R and tidyr package, specifically in the below functions: %&gt;% (pipe), filter, mutate, pivot_longer, pivot_wider, map, pmap, select, left_join.\nIf you would like to learn on your own with publicly available resources:\nChapter 1 - 4 from MordernDive: https://moderndive.com/index.html\n\nIf you would like to participate in an instructor-led R course:\nR for Biologist from Edinburgh Genomics (https://genomics.ed.ac.uk/services/r-biologists-0#overlay-context=services/training). For details, please contact Edinburgh Genomics.\n\n\nExpected outcome\nBy the end of the workshop, participants will be familiar with the following topics: - Common workflow of single cell analysis (pre-processing, quality control, filtering, normalization, Clustering, Cell type annotation) - Combining AbSeq and scRNA-seq for downstream analysis\nFor further information, please contact: biox_support_emea@bd.com\n\n\nDisclaimer\nRecommendations given by representatives of BD in the context of the creation and setup of customer-specific applications and assays and the composition of antibody panels for use in flow cytometry assays are provided in a diligent manner. However, the Customer acknowledges that (i) such recommendations should not be treated as a substitute for the Customer’s own examination, (ii) BD does not make any promises nor guarantees that recommendations are accurate and complete and will meet the Customer’s present or future needs or will produce positive or specific results and (iii) Customer remains solely responsible for validating and deciding on any such recommendations.\nBD therefore accepts no liability whatsoever in connection with any such recommendation and/or any results generated on the basis of such recommendations and, to the fullest extent permitted by law, expressly disclaims any and all warranties and any liability in this respect. In particular, the Customer assumes sole responsibility for the validation, use, selection, and suitability of the recommendations for its needs and objectives.\n\n\nLicense\nSee the LICENSE file for license rights and limitations (MIT)."
  }
]